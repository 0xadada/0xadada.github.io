3:I[5613,[],""]
8:I[1778,[],""]
9:I[5250,["250","static/chunks/250-d7e0a94ebe194dac.js","931","static/chunks/app/page-f7ba098afe402509.js"],""]
a:I[1749,["250","static/chunks/250-d7e0a94ebe194dac.js","749","static/chunks/749-1aefd436964833c3.js","185","static/chunks/app/layout-6318541da324be16.js"],"Image"]
4:["year","2017","d"]
5:["month","12","d"]
6:["date","22","d"]
7:["slug","programming-phoenix","d"]
0:["O3Fzp52F4chEJECiXs_o1",[[["",{"children":[["year","2017","d"],{"children":[["month","12","d"],{"children":[["date","22","d"],{"children":[["slug","programming-phoenix","d"],{"children":["__PAGE__?{\"year\":\"2017\",\"month\":\"12\",\"date\":\"22\",\"slug\":\"programming-phoenix\"}",{}]}]}]}]}]},"$undefined","$undefined",true],["",{"children":[["year","2017","d"],{"children":[["month","12","d"],{"children":[["date","22","d"],{"children":[["slug","programming-phoenix","d"],{"children":["__PAGE__",{},["$L1","$L2",null]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children","$5","children","$6","children","$7","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ec967fd209f0dd40.css","precedence":"next","crossOrigin":""}]]}]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children","$5","children","$6","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children","$5","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[null,["$","html",null,{"lang":"en-US","children":["$","body",null,{"children":[["$","main",null,{"className":"layout_layout__dCqca","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}]}],["$","footer",null,{"className":"footer_footer__woFMY layout_layout__dCqca","children":["$","nav",null,{"children":["$","p",null,{"children":["Â© 2003-","2024"," 0xADADA (unless otherwise noted.)",["$","br",null,{}],["$","$L9",null,{"href":"/","title":"0xADADA","children":"Home"}]," ",["$","span",null,{"className":"h-card","children":[["$","$L9",null,{"href":"mailto:0xadada.pub@protonmail.com","className":"c-Meta u-email","rel":"me","title":"0xADADA","children":"Email"}]," "]}],["$","$L9",null,{"href":"https://warpcast.com/0xadada","rel":"me nofollow external noopener","title":"0xADADA on Warpcast","children":"Farcaster"}]," ",["$","$L9",null,{"href":"https://mastodon.cloud/@0xADADA","rel":"me nofollow external noopener","title":"0xADADA on Mastodon","children":"Mastodon"}]," ",["$","$L9",null,{"href":"https://bsky.app/profile/0xadada.bsky.social","rel":"me nofollow external noopener","title":"0xADADA on Bluesky","children":"Bluesky"}]," ",["$","$L9",null,{"href":"https://twitter.com/0xadada","rel":"me nofollow external noopener","title":"0xADADA on Twitter","children":"Twitter"}]," ",["$","$L9",null,{"href":"https://github.com/0xadada","rel":"me nofollow external noopener","title":"0xADADA on GitHub","children":"GitHub"}]," ",["$","$L9",null,{"href":"https://www.goodreads.com/review/list/60524683-0xadada?shelf=wanted","rel":"me nofollow external noopener","title":"0xADADA on Goodreads","children":"Goodreads"}]," ",["$","$L9",null,{"href":"/rss.xml","children":"RSS"}]," ",["$","$La",null,{"src":"/static/images/meta/avatar.svg","alt":"0xADADA icon","width":"20","style":{"marginBottom":"-0.125rem"}}]]}]}]}]]}]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/32a94118522b884a.css","precedence":"next","crossOrigin":""}]],"$Lb"]]]]
2:["$","article",null,{"className":"hentry h-entry","children":[["$","header",null,{"children":[["$","h1",null,{"className":"entry-title p-name","children":"Notes on Programming Phoenix for Elixir"}],["$","time",null,{"className":"display-date_published__A_L_d dt-published","dateTime":"2017-12-22T00:00:00.000Z","children":"Friday December 22, 2017"}],["$","br",null,{}],["$","span",null,{"className":"h-card page_byline___vuXv","children":["by:"," ",["$","span",null,{"className":"page_author__cAd1d fn p-author p-name","children":"0xADADA"}]]}]]}],["$","div",null,{"className":"entry-content e-content","children":[["$","p",null,{"children":["A summary of my notes taken while reading\n",["$","a",null,{"href":"https://pragprog.com/book/phoenix/programming-phoenix","children":"Programming Phoenix"}],"."]}],"\n",["$","h2",null,{"children":"Ch.1"}],"\n",["$","p",null,{"children":"The layers of phoenix, the endpoint is where the HTTP connection contacts\nphoenix, from there it goes to the router which directs a request to the\nappropriate controller, passing through a series of pipelines. Pipelines chain\nfunctions together to handle tasks that span across multiple controllers, such\nas browser requests vs API requests."}],"\n",["$","p",null,{"children":"connection\n|> endpoint\n|> router\n|> pipelines\n|> controller"}],"\n",["$","p",null,{"children":"The purpose of the web server is to route a request to a function that performs\nthe right task, called an action. These functions are grouped into controllers.\nA controller is also a series of pipelines"}],"\n",["$","p",null,{"children":"connection\n|> controller\n|> common_services\n|> action"}],"\n",["$","p",null,{"children":"An action to show a user would look like this:"}],"\n",["$","p",null,{"children":"connection\n|> find_user\n|> view\n|> template"}],"\n",["$","p",null,{"children":"Run phoenix inside an interactive shell: iex -S mix phx.server"}],"\n",["$","p",null,{"children":"In controllers, parameters come in as a Map of keys with string names:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"def world(conn, %{\"name\" => name}) do    # string key\n  render conn, \"world.html\", name: name  # atom key\nend\n"}]}],"\n",["$","p",null,{"children":"Phoenix specifically converts these from String keys to atoms once inside the\napplication boundry, because external data can't safely be converted to atoms."}],"\n",["$","p",null,{"children":"Phoenix encourages breaking big functions down into smaller ones. It provides a\nplace to explicitly register each smaller function in a way that makes it easy\nto understand and replace. These small pieces are orchestrated with the Plug\nlibrary. The Plug library is a specification for building applications that\nconnect with the web. Plug produces and consumes a struct called Plug.Conn,\ndescribing the entire request/response cycle of a web application, containing\nthe request, protocol, parameters, etc. Each individual Plug should do one-thing\nand do it well, take the conn struct, transform it, and return it."}],"\n",["$","p",null,{"children":"Plugs are just functions, and Phoenix web applications are just pipelines of\nPlugs."}],"\n",["$","p",null,{"children":"If you look at endpoint.ex you'll see that its essentially a pipeline of\nfunctions chained together at the beginning of each request:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"connection\n|> Plug.Static.call\n|> Plug.RequestId.call\n|> Plug.Logger.call\n|> Plug.Parsers.call\n|> Plug.MethodOverride.call\n|> Plug.Head.call\n|> Plug.Session.call\n|> <your app>.Router.call\n"}]}],"\n",["$","p",null,{"children":["The last call, to ",["$","code",null,{"children":"<your app>.Router.call"}]," is where endpoint.ex defers to your\napplications router.ex to define which controller, and subsequently, which\nfunction is invoked next in the pipeline chain. The router defines a set of\npipelines for dealing with which Plugs to use prior to your conroller being\ncalled, typically:"]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"connection\n|> endpoint\n|> router\n|> pipeline(s)\n|> controller\n"}]}],"\n",["$","p",null,{"children":["The pipeline(s) above will be things like :browser, handling common tasks as\npreventing request forgery, ",["$","code",null,{"children":":fetch_session"}],", ",["$","code",null,{"children":":fetch_flash"}],"."]}],"\n",["$","p",null,{"children":"The controller is where business logic specific to your application lives,\nmaking data available for a view. The view subsequently substitutes values\ninside a template which is rendered."}],"\n",["$","h2",null,{"children":"Ch.2"}],"\n",["$","p",null,{"children":"Start an interactive Elixir shell within an Elixir application project:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-bash","children":"iex -S mix\n"}]}],"\n",["$","p",null,{"children":["Structs add a constraint to Maps in that they offer protection from bad or\nmisspelled keynames at compilation time, while Maps only throw errors during\nruntime when the key is first accessed. Under the covers, a Struct is just a Map\nwith a ",["$","strong",null,{"children":"struct"}]," key."]}],"\n",["$","h2",null,{"children":"Ch3"}],"\n",["$","p",null,{"children":"A view is a module containing a rendering function that converts data into a\nformat the user will consume, like HTML or JSON. A template is a function on the\nview module, compiled from a file containing raw markup language and embedded\nElixir code to process substitutions and loops. Views are modules responsible\nfor rendering, and templates are the compiled functions that have static markup\nand native code to build pages."}],"\n",["$","p",null,{"children":["EEx executes Elixir code within ",["$","code",null,{"children":"<%= %>"}]," tags, injecting the result into the\ntemplate. EEx evalutes code within ",["$","code",null,{"children":"<% %>"}]," tags, but without injecting the\nresult."]}],"\n",["$","p",null,{"children":["The expression ",["$","code",null,{"children":"<%= for user <- @users do %>"}]," walks through the users, rendering\neach user using the template block between the ",["$","code",null,{"children":"do ... end"}]," block, rolling the\nresult up into the template."]}],"\n",["$","p",null,{"children":"In Phoenix, after compilation, templates are just functions. These templates are\njust linked lists (rather than other web frameworks that use string\nconcatenation)â this means Phoenix doesn't have to make huge copies of large\nstrings, resulting in performance improvements. This lets Elixir leverage modern\nCPU optimization since it only has a single copy of the largest strings in your\napplication."}],"\n",["$","p",null,{"children":"When a template is added to Phoenix, the view module extracts the template from\nthe filesystem and adds it as a function on the module itself, thats why the\nview module is required in the first place."}],"\n",["$","h2",null,{"children":"Ch.4"}],"\n",["$","p",null,{"children":"Ecto uses a DSL that specifies how the fields in a struct map to database tables\nand columns. The DSL is built using Elixir macros. Virtual fields are not\npersisted to the database."}],"\n",["$","p",null,{"children":"Models (called contexts & schemas in Phoenix 1.3) are layers of functions to\ntransform data according to business logic. A schema is the native database form\nof the data, and a struct is the data once pulled out of the database.\nChangesets in Ecto decouple the authentication update policy separately from the\ndatabase schema. This policy segregation makes handling change over time."}],"\n",["$","p",null,{"children":"Ecto helps you write code to make the minimal required database operation to\nupdate a record. Ecto can enforce constraints without hitting the database."}],"\n",["$","h2",null,{"children":"Ch.5"}],"\n",["$","p",null,{"children":[["$","code",null,{"children":"Ecto.Changeset.cast"}]," converts a bare Map to a changeset, for security it limits\nthe incoming parameters to those specified."]}],"\n",["$","p",null,{"children":["Module plugs vs function plugs: A function plug is a single function, a module\nplug is a module that provides two functions with some configuration details,\notherwise they work the same. ",["$","code",null,{"children":"lib/rumbl_web/endpoint.ex"}]," is an example of a\nmodule plug while ",["$","code",null,{"children":"lib/rumbl_web/router.ex"}]," is an example of a function plug.\nYou specify a module plug by providing a module name plug Plug.Logger while a\nfunction plug is specified by its name as an atom plug ",["$","code",null,{"children":":protect_from_forgery"}],"."]}],"\n",["$","p",null,{"children":"To share a Plug across more than one module, you want to use a Module Plug. All\nplugs take a connection and return a connection."}],"\n",["$","p",null,{"children":"Any values stored in conn.assigns.* is automatically available with the same\nname in our view. So if you assign to current_user, then @current_user can be\nused directly in a view."}],"\n",["$","h2",null,{"children":"Ch.6 Generators & Relationships"}],"\n",["$","p",null,{"children":"Generating resources, phx.gen.html generates simple HTML based scaffolds,\nphx.gen.json generates a REST-based API using JSON. They create resources for\nCRUD operations, creating migrations, controllers, and templates as well as\ntests."}],"\n",["$","p",null,{"children":"An example:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-bash","children":"mix phx.gen.html Medias \\\n  Video videos \\\n  user_id:references:users \\\n  url:string \\\n  title:string \\\n  description:text\n"}]}],"\n",["$","p",null,{"children":"This includes the name of the context that holds the module, the module defines\nthe model. The plural form of the model name, and each field with some type\ninformation. Phoenix consistently uses singular forms in models, controllers,\nand views. At the application boundry (URLs, table names you provide a bit more\ninformation because you can use pluralized names). Instead of using inflectors,\nyou just explicitly set the pluralized form yourself."}],"\n",["$","p",null,{"children":"Primary keys identify rows for each item in a table. Foreign keys point from one\ntable to the primary key in another table. Foreign key lets the database get in\non the act of maintaining consistency across our two relationships."}],"\n",["$","p",null,{"children":"The change function handles two database functions, one for migrating up and one\nfor migrating down. A migration up applies a migration, and a migration down\nreverts it. If you make a mistake a need to move a single migration up or down,\nyou can do so."}],"\n",["$","p",null,{"children":["If you meant to add a ",["$","code",null,{"children":"view_count"}]," field to your create_video migration, but\nbefore you migrated your database up. You would create a new migration adding\nthe view_count field, since you haven't pushed your changes to production yet,\nyou can roll back, make your changes, and then migrate up again. First you'd\nroll back your changes: mix ecto.rollback Verify the undo of the create_video\nmigration. At this point, add the missing view_count field and migrate forwards\nwith mix ecto.migrate."]}],"\n",["$","p",null,{"children":["A schema is responsible for tying the database fields to a field in the Elixir\nstruct, these are defined in ",["$","code",null,{"children":"lib/<appname>/<contextname>/<model>.ex"}],"."]}],"\n",["$","p",null,{"children":"Ecto associations are explicit, you need to ask to fetch associated records\nspecifically. Most persistence frameworks often fetch rows you don't need or\nfetch them in inefficient ways, over time these inefficiencies add up to major\nperformance problems. Ecto forces the developer to pay down these performance\nhits early so they don't add up over time, when they're more difficult to fix."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-bash","children":"iex> user = Repo.get_by!(User, username: \"josevalim\")\n%{Rumbl.User{...}\niex> user.videos\n#Ecto.Association.NotLoaded<association :videos is not loaded>\niex> user = Repo.preload(user, :videos)\n%{Rumbl.User{...}\niex> user.videos\n[] # loaded, but none are associated! yay\n"}]}],"\n",["$","p",null,{"children":"Repo.preload accepts one or a collection of association names, and fetches all\nassociated data."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"iex> user = Repo.get_by!(User, username: \"josevalim\")\niex> attrs = %{title: \"hi\", description: \"says hi\", url: \"example.com\"}\niex> video = Ecto.build_assoc(user, :videos, attrs)\niex> video = Repo.insert!(video)\n"}]}],"\n",["$","p",null,{"children":"Ecto.build_assoc builds a struct, with the proper relationship fields already\nset."}],"\n",["$","p",null,{"children":"To fetch videos associated with a user, without storing them in a user struct:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"iex> query = Ecto.assoc(user, :videos)\niex> Repo.all(query)\n[%Rumbl.Video{...}]\n"}]}],"\n",["$","p",null,{"children":"assoc is convenient in that it returns an Ecto.Query all videos scoped to a\nspecific user, or a list of users, we convert this query into data by calling\nRepo.all."}],"\n",["$","h2",null,{"children":"Ch.7 Ecto Queries and Constraints"}],"\n",["$","p",null,{"children":"Seeds are small scripts that populate the database with values every time the\nscript is run. Phoenix stores seed scripts in priv/repo/seeds.ex. Mix tasks will\nrun these scripts. Use mix run priv/repo/seeds.exs to add the seed data to the\ndatabase."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-bash","children":"Repo.all from c in Category, select: c.name\n"}]}],"\n",["$","p",null,{"children":[["$","code",null,{"children":"Repo.all"}]," means return all rows, ",["$","code",null,{"children":"from"}]," is a macro that builds a query,\n",["$","code",null,{"children":"c in Category"}]," means we're pulling rows (labeled c) from the Category schema.\n",["$","code",null,{"children":"select: c.name"}]," means we're going to return only the name field."]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-bash","children":"Repo.all from c in Category, order_by: c.name, select: c.name\n"}]}],"\n",["$","p",null,{"children":"will order the results by name and return a tuple containing the name and the id\nfields."}],"\n",["$","p",null,{"children":"Ecto queries are composable, you don't need to define the entire query at once,\nyou can combine them bit-by-bit."}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-bash","children":"iex> query = Category\niex> query = from c in query, order_by: c.name\niex> query = from c in query, select: {c.name, c.id}\n#Ecto.Query<>\niex> Repo.all(query)\n[...]\n"}]}],"\n",["$","p",null,{"children":["This works because Ecto defines a queryable protocol. from receives a queryable,\nand you can use any queryable as a base for a new query. An Elixir protocol\ndefines an API for specific language features, this one defines the API for\nsomething that can be queried. This is why we can invoke Repo.all(Category) or\nRepo.all(query) because both Category and query implement the ",["$","code",null,{"children":"Ecto.Queryable"}],"\nprotocol. By abiding to the protocol, developer can quickly layer together\nsophisticaed queries with Ecto.Query, maintaining sophistication without\ncomplexity."]}],"\n",["$","p",null,{"children":"Code that builds and transforms queries, and code that interacts with the\nrepository should belong to the context. Code that makes requests for the data\nshould belong to the controllerâbecause the controller is where the web logic\nshould live, and the database layer should be hidden within the application\ncontext with the rest of the business logic."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"iex> username = \"josevalim\"\niex> Repo.one(from u in User, where: u.username == ^username)\n%Rumbl.User{...}\n"}]}],"\n",["$","p",null,{"children":["Repo.one returns one row, from u in user means read from the User schema. where\nu.username == ^username means return the row ",["$","code",null,{"children":"where u.username == ^username"}],",\nusing the pin ",["$","code",null,{"children":"^"}]," operator means we don't want to assign the username but use\nits value."]}],"\n",["$","p",null,{"children":[["$","code",null,{"children":"Repo.one"}]," does not mean \"return the first result\" but \"one result is expected\",\nso if there is more, it fails. The Ecto Query API is not about composing query\nstrings, it uses Elixir macros such that Ecto knows where user-defined variables\nare located, it's easier to protect the user from security flaws like\nSQL-injection attacks. It also helps a bit with query normalization and\nleverages the data types as defined in the schema for casting values at runtime."]}],"\n",["$","p",null,{"children":"Any functions with side effectsâthe ones that change the worldâshould remain in\nthe controllers, while the context, model, and view layers remain side effect\nfree. The controller receives data, either from a traditional web request,\nreading data from a socket, and this data is passed from the controller to\nvarious functions that transform it as it moves through the functions to the\nshape of our business-model requirements. Finally it makes changes to the world\naround us, either delivering emails, adding entries to a database, or invoking a\nview which is again written to the connection (another side effect), any of\nwhich can result in a business operation."}],"\n",["$","p",null,{"children":["The query API supports many operators:\n",["$","code",null,{"children":"==, !=, <=, >=, <, >, and, or, not, in, like, ilike, is_nil, count, avg, sum, min, max, datetime_add, date_add, fragment, field, type"}],"."]}],"\n",["$","p",null,{"children":"Keyword syntax uses a keyword list to express a query."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"iex> Repo.one from u in User,\n              select: count(u.id),\n              where: ilike(u.username, ^\"j%\") or\n                     ilike(u.username, ^\"c%\")\n"}]}],"\n",["$","p",null,{"children":"the u variable is bound as part of Ecto's from macro, representing entries from\nthe User schema. Each join in a query gets a special binding."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"# count users\niex> users_count = from u in User, select: count(u.id)\n#Ecto.Query<from u in Rumbl.User, select: count(u.id)>\n# count usernames with a j\niex> j_users = from u in users_count, where: ilike(u.username, ^\"%j%\")\n#Ecto.Query<from u in Rumbl.User, where: ilike(u.username, ^\"%j%\"), select: count(u.id)>\n"}]}],"\n",["$","p",null,{"children":"This query builds up a new query, normalizing as it builds, upon the saved\nquery, we even built the query using the same bound variable name, u, but we\ndidn't have to."}],"\n",["$","p",null,{"children":"The pipe syntax allows developer to build queries by piping through query\nmacros. Each pipe takes a queryable and returns a queryable."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"iex> User |>\n     select([u], count(u.id)) |>\n     where([u], ilike(u.username, ^\"j%\") or ilike(u.username, ^\"c%\")) |>\n     Repo.one()\n[debug] QUERY OK source=\"users\" db=4.5ms\nSELECT count(u0.\"id\") FROM \"users\" AS u0 WHERE ((u0.\"username\" ILIKE $1) OR (u0.\"username\" ILIKE $2)) [\"j%\", \"c%\"]\n5\n"}]}],"\n",["$","p",null,{"children":"Because each segment of the pipe works independently of the others, we need to\nspecify the binding manually for each one."}],"\n",["$","p",null,{"children":"Fragments offer an escape hatch from Ecto's Query API. The best abstractions\noffer an escape hatch, and since Ecto's Query API doesn't represent every query\nthe database layer can provide, Ecto's query fragments send part of the query\ndirectly to the database but allows you to construct it in a safe way, like\nthis: iex> from(u in User, where: fragment(\"lower(username) = ?\",\n^String.downcase(uname)))"}],"\n",["$","p",null,{"children":"When all else fails, you can directly run SQL statements with\nEcto.Adapters.SQL.Query:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"iex> Ecto.Adapters.SQL.query(Rumbl.Repo, \"SELECT power($1, $2)\", [2, 10])\nSELECT power($1, $2) [2, 10]\n{:ok, %Postgrex.Result{ columns: [\"power\"], command: :select, connection_id: 5979, num_rows: 1, rows: [[1024.0]] }}\n"}]}],"\n",["$","p",null,{"children":"Ecto relationships are explicit:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"iex> user = Repo.one from(u in User, limit: 1)\niex> user.videos\n#Ecto.Association.NotLoaded<association :videos is not loaded>\niex> user = Repo.preload(user, :videos)\niex> []\n"}]}],"\n",["$","p",null,{"children":"Ecto allows us to preload associations directly as part of a query:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"iex> Repo.all from u in User, join: v in assoc(u, :videos), join: c in\nassoc(v, :category), where: c.name == \"Comedy\", select: {u, v}\n[{Rumbl.User{...}, %Rumbl.User{...}}]\n"}]}],"\n",["$","p",null,{"children":"Constraints allow developers to use underlying relational, and can solve\npotential race conditions:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"User sends a category ID through the form."}],"\n",["$","li",null,{"children":"Perform a query to check if the category ID exists in the DB."}],"\n",["$","li",null,{"children":"If the category ID exists, add the video with the category ID to the\ndatabase."}],"\n"]}],"\n",["$","p",null,{"children":"However, someone could delete the category ID between steps 2 and 3, allowing a\nvideo insertion without and existing category. This will lead to inconsistent\ndata over time. Phoenix uses constrains to manage change in a way that combines\nthe harsh protections of the database with Ecto's gentle guiding hand to report\nerrors without crashing. Some terms:"}],"\n",["$","p",null,{"children":"constraint: An explicit database constraint, a uniqueness constrain, or an\nindex, or and integrity constraint between primary and foreign keys."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"constraint error: The Ecto.ConstraintError.\nchangeset constraint: A constraint annotation allowing Ecto to convert constraint errors into changeset error messages.\nchangeset error messages: Beautiful error messages for the consumption of people.\n"}]}],"\n",["$","p",null,{"children":"Ecto allows the application layer (and web server) to use database services like\nreferential integrity and transactions to strike a balance between the needs of\nthe application layer and the needs of the database. Ecto rewards developers the\nmany guarantees databases offer with data integrity in the short term, by\ntransforming constraint errors into user feedback, and in the longer term by\nguaranteeing you wont be awake at 3am fixing bugs caused by inconsistent data."}],"\n",["$","p",null,{"children":"IEx allows us to fetch a previous value using v(n), where n is the number of the\nexpression, you can alsop ass negative values to grab the last nth expression."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"iex> alias Rumbl.Repo\nRumbl.Repo\niex> category = Repo.get_by(Rumbl.Medias.Category, name: \"Drama\")\n%Rumbl.Medias.Category{\n  __meta__: #Ecto.Schema.Metadata<:loaded, \"categories\">,\n  id: 2,\n  inserted_at: ~N[2017-11-05 18:02:12.006642],\n  name: \"Drama\",\n  updated_at: ~N[2017-11-05 18:02:12.006653]\n}\niex> Repo.delete(category)\n[debug] QUERY ERROR db=6.5ms\nDELETE FROM \"categories\" WHERE \"id\" = $1 [2]\n** (Ecto.ConstraintError) constraint error when attempting to delete struct: * foreign_key: videos_category_id_fkey\n"}]}],"\n",["$","p",null,{"children":"We previously added a video using the Drama category, so the database prevents\ndeletion of the category as it is tied to the video and would create orphaned\nrecords. Use foreign_key_constraint, which is like assoc_constraint used\nearlier, except it doesn't inflect the foreign key from the relationship."}],"\n",["$","p",null,{"children":"This is particularly useful if you want to provide reasons why a category can\nnot be deleted."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"iex> import Ecto.Changeset\nEcto.Changeset\niex(22)> changeset = Ecto.Changeset.change(category)\n#Ecto.Changeset<action: nil, changes: %{}, errors: [], data: #Rumbl.Medias.Category<>, valid?: true>\niex> changeset = foreign_key_constraint(changeset, :videos, name: :videos_category_id_fkey, message: \"still exists\")\n#Ecto.Changeset<action: nil, changes: %{}, errors: [],\n            data: #Rumbl.Medias.Category<>, valid?: true>\niex> Repo.delete(changeset)\n[debug] QUERY ERROR db=8.8ms\nDELETE FROM \"categories\" WHERE \"id\" = $1 [2]\n{\n  :error,\n  #Ecto.Changeset<\n    action: :delete,\n    changes: %{},\n    errors: [videos: {\"still exists\", []}],\n    data: #Rumbl.Medias.Category<>,\n    valid?: false\n  >\n}\n"}]}],"\n",["$","p",null,{"children":["because the foreign key is established in the videos table, we need to\nexplicitly call this out in the call to ",["$","code",null,{"children":"foreign_key_constraint"}],". The work best\nsuited for the database must be done in the database."]}],"\n",["$","p",null,{"children":["The ",["$","code",null,{"children":"constraint"}]," changeset functions are useful when the constraint being mapped\nis triggered by external data, often as part of the user request. Using\nchangeset constraints only makes sense if the error message can be something the\nuser can take useful action on."]}],"\n",["$","h2",null,{"children":"Ch.8 Testing MVC"}],"\n",["$","p",null,{"children":"Testing principals"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"Fast â tests should run quickly and concurrently if possible"}],"\n",["$","li",null,{"children":"Isolated â Tests that are too isolated wont have enough context to be useful,\ntests that aren't isolated enough are difficult to understand and maintain"}],"\n",["$","li",null,{"children":"DRY â Strive to eliminate repetition in tests"}],"\n",["$","li",null,{"children":"Repeatable â The same test on the same code should always yield the same\nresult"}],"\n",["$","li",null,{"children":"unit test â exercises a function for one layer of your application"}],"\n",["$","li",null,{"children":"integration test â focuses on the way different layers of an application fit\ntogether. An example is a controller test that makes a request to and\nendpoint, flows through the pipelines, reads from the database, and renders\nthrough views just like a Phoenix request would"}],"\n",["$","li",null,{"children":"acceptance test â test how multiple actions work together. A single acceptance\ntest case may sign the user on, perform several calculations that build upon\neach other, then sign off."}],"\n"]}],"\n",["$","p",null,{"children":"ExUnit has three main macros, setup macro specifies setup code that runs before\neach test is run. test macro defines a single isolated test, it defines a\nhypothesis about code. Finally, assert macro specifies something we believe to\nbe true about code, if true, the test passes."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"defmodule MyTest do\n  use ExUnit.Case, async: true\n  setup do\n    :ok\n  end\n  test \"pass\" do\n    assert true\n  end\n  test \"fail\" do\n    assert false\n  end\nend\n"}]}],"\n",["$","p",null,{"children":"This code runs two tests, first setup is run, then the \"pass\" test case. Next\nsetup is run, and the \"fail\" test case. The output is a passing test case and a\nfailing test case."}],"\n",["$","p",null,{"children":["Tests will generally use ",["$","code",null,{"children":"<AppName>.ConnCase"}]," meaning you get\n",["$","code",null,{"children":"<AppName>.Router.Helpers"}],", and Ecto imports along for free."]}],"\n",["$","p",null,{"children":"ExUnit calls tests with"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"test \"GET /\", %{conn: conn} do\n  conn = get(conn, \"/\")\n  assert html_response(conn, 200) =~ \"Welcome to Phoenix!\"\nend\n"}]}],"\n",["$","p",null,{"children":"by calling get(conn, \"/\") rather than calling the index action on the controller\ndirectly. This practice gives the test the right level of isolation because\nwe're using the controller the same way Phoenix does. Phoenix also provides test\nhelpers to make testing responses easier."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"assert html_response(conn, 200) ~= \"Welcome to Phoenix!\"\n"}]}],"\n",["$","p",null,{"children":"which does the following:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"asserts the response was 200\ncontent-type was text/html\nreturn the response body, allowing us to match on the contents\n"}]}],"\n",["$","p",null,{"children":"this also exists for JSON called json_response that allow for assertions like"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"assert %{user_id: user.id} = json_response(conn, 200)\n"}]}],"\n",["$","p",null,{"children":"ExUnit tags help when setup is different from test to test. When specifying a\ntag, ExUnit makes that information available within the setup block via\ncallbacks."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"setup %{conn: conn} = config do\n  if username = config[:login_as] do\n    user = insert_user(username: username)\n    conn = assign(conn, :current_user, user)\n    {:ok, conn: conn, user: user}\n  else\n    :ok\n  end\nend\n@tag login_as: \"max\" # this is the tag\ntest \"list all user's videos on index\", %{conn: conn, user: user} do\n# ...\n"}]}],"\n",["$","p",null,{"children":"tags take either a keyword list (above) or an atom as arguments. The config map\ncontains the conn and tag (either atom or keyword list). In this case if\nlogin_as has a value, we use it to login the user and return an updated conn\nwith the user, otherwise we return an :ok."}],"\n",["$","p",null,{"children":"Writing unit tests directly against a function like the Auth plug will result in\nunexpected errors during the testing/coding cycle because calls directly to the\nfunction will get results that have not gone through the endpoint, router or\nother pipelines. The data has not been fully transformed, so the results will\nnot reflect the state that the implementation sees when running in a server. The\nbypass_through helper that ConnCase provides allows developer to send a\nconnection through the endpoint, router, and desired pipelines but bypass the\nroute dispatch. This approach gives developer a connection wired up with all the\ntransformations the specific tests require, such as fetching the session and\nadding flash messages."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"setup %{conn: conn} do\n  conn =\n    conn\n    |> bypass_through(RumblWeb.Router, :browser)\n    |> get(\"/\")\n\n  {:ok, %{conn, conn}}\nend\ntest \"authenticate_user halts when no current_user exists\", %{conn: conn} do\n  conn = Auth.authenticate_user([])\n  assert conn.halted\nend\n"}]}],"\n",["$","p",null,{"children":["The setup block calls ",["$","code",null,{"children":"bypass_through"}],", passing the router and the :browser\npipeline to invoke. When the get request is invoked, it accesses the endpoint\nand stops at the browser pipeline, as requested. The path \"/\" given to the get\nisn't used by the router when bypassing, its just stored in the connection, this\nprovides all the requirements for a plug with a valid session and flash message\nsupport."]}],"\n",["$","p",null,{"children":"Since most repository-related functionality will be tested with integration\ntests as they insert and update records, but we want to be sure to catch some\nerror conditions as close to the breaking point as possible. One example is the\nuniqueness constraint checks in the changeset. It has side effects because we're\ngoing to need to create a record and then test against it."}],"\n",["$","h2",null,{"children":"Ch. 9: Watching Videos"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"alter table(:videos) do\n  add :slug, :string\nend\n"}]}],"\n",["$","p",null,{"children":"the alter macro changes the schema for both up and down migrations. The premise\nof a slug is so you can permanently generate a name from the data in other\nfields, some of which may be updatable."}],"\n",["$","p",null,{"children":"Because Ecto separates changesets from the definition of a database record\n(model), this gives developer the ability to have different change policies for\nany type of change to the record. Changesets act as a funnel to the database,\nfiltering and casting incoming data, making sure sensitive fields like user role\ncannot be set externally, while casting them to the type defined in the schema.\nChangesets can validate data, for example the length of a fieldâ on the fly, but\nvalidations that depend on database integrity are left to the database, in the\nform of constraints. Changesets make the code easier to reason about, can be\ncomposed, allowing each part of a data transformation to be a more easily\ncomprehendâable and testable function."}],"\n",["$","p",null,{"children":["In viws you may see a ",["$","code",null,{"children":"video_path"}],", or ",["$","code",null,{"children":"watch_path"}],", or ",["$","code",null,{"children":"x_path()"}]," helpers.\nThese helper functions are generated by RumblWeb.Router and imported into\ncontrollers and views by rumble_web/web.ex. ",["$","code",null,{"children":"watch_path(@conn, :show, video)"}],"\ntakes the Video struct, and by conventions it generates a URL by extracting the\nID from the Video struct. This works because Phoenix knows to use the ID field\nto generated the URL because Phoenix implements the Phoenix.Param protocol.\nDeveloper can customize this behavior by implementing our own functions to\noverride the default protocol implementation to generate the URL using the slug."]}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"defimpl Phoenix.Param, for: Rumbl.video do\n  def to_param(%{slug: slug, id: id}) do\n    \"#{id}-#{slug}\"\n  end\nend\n"}]}],"\n",["$","p",null,{"children":"The advantage of implementing this behavior change as a Protocol implementation\nis the clean polymorphism we get by extending Phoenix parameters without having\nto change Phoenix itself or the Video module itself."}],"\n",["$","h2",null,{"children":"Ch. 10: Using Channels"}],"\n",["$","p",null,{"children":"A client connects to a channel over a socket, then sends and receives messages,\nthat's it. A Phoenix channel is a conversation, the channel sends messages,\nreceives messages, and keeps state. Just as controllers receive requests,\nchannels receive events."}],"\n",["$","p",null,{"children":"A Phoenix conversation (messages sent, messages received) is about a topic, and\nthe topic maps onto application concepts like a chat room, local map, or\nannotations to a video. Each user's conversation on a topic has its own\nisolated, dedicated process."}],"\n",["$","p",null,{"children":"Whereas the traditional web-based request/response interactions are stateless,\nconversations in an Elixir process can be stateful. This means for sophisticated\ninteractions like games and more interactive pages, developer doesn't need to\nuse local storage, cookies, or databases to keep track of the state of the\nconversation. Each call to the channel simply picks up where it left off. This\nonly works if the framework supports true isolation and concurrency: one process\nmust be isolated, not affect others, and true concurrency means lightweight\nabstractions that don't bleed into one another. Channels must scale in the\ndimensions developer is most concerned about: code complexity, performance, and\nmanageability."}],"\n",["$","p",null,{"children":"The application channel is simple, but it must manage three things:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"making and breaking connections\nsending messages\nreceiving messages\n"}]}],"\n",["$","p",null,{"children":"A socket establishes a new connection with a socket. After a connection is made,\nthat same socket will be transformed through the life of the connection. The\nsocket is a representation of a continuous ongoing conversation between the\nclient and the server. When a connection is made, the initial socket is created,\nand that same socket is transformed with each new received event, through the\nwhole life of the conversation."}],"\n",["$","p",null,{"children":"The socket is an abstraction over a websocket, or to handle older clients, a\nlongpoll. The socket abstracts the transport layer, and Phoenix handles the\nrest."}],"\n",["$","p",null,{"children":["A channel is a conversation about a topic, the topic has an identifier of\nvideos:",["$","code",null,{"children":"<video id>"}]," where ",["$","code",null,{"children":"video_id"}]," is a dynamic id matching a record in the\ndatabase. Topic identifiers generally take the form topic:subtopic where topic\nis often a resource name and subtopic is the instance ID that usually identifies\na row in the database."]}],"\n",["$","p",null,{"children":"Topics are organizing concepts, they are used as parameters to functions, and\nused in URLs to identify conversations. Just like a URL passes an :id parameter\nto represent a request for a resource from a controller; with channels,\ndeveloper can use the topic ID to scope a channel connection."}],"\n",["$","p",null,{"children":"Phoenix channels define \"callbacks\", or functions that respond to channel events\nsuch as join below:"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"def join(\"videos:\" <> video_id, _params, socket) do\n  {:ok, assign(socket, :video_id, String.to_integer(video_id))}\nend\n"}]}],"\n",["$","p",null,{"children":["in the above code, assign(socket...) returns a socket, resulting in a ",["$","code",null,{"children":"{:ok, socket}"}]," returning for authorized users or ",["$","code",null,{"children":"{:error, socket}"}]," which will deny\njoining the channel. Sockets maintain state in a socket.assigns map, and the\nabove adds the video id to the assigns map using the helper function\n",["$","code",null,{"children":"assign(socket, :video_id, String.to_integer(video_id))"}],"."]}],"\n",["$","p",null,{"children":"Socket state is maintained for the duration of the connection. The socket is\ntransformed in a loop rather than a single pipeline. The socket state changed in\nthe above \"assign()\" call will be accessible later as events come into and out\nof the channel. This small difference leads to enormous differences in\nefficiency between the channels API and the controllers API."}],"\n",["$","p",null,{"children":"Channels receive events with an event name, such as new_message, and include a\npayload of arbitrary data. Each channel module can receive events in three ways"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"handle_in receives direct channel events\nhandle_out intercepts broadcast events\nhandle_info receives OTP messages\n"}]}],"\n",["$","p",null,{"children":[["$","code",null,{"children":"handle_info"}]," is invoked whenever an Elixir message reaches the channel."]}],"\n",["$","p",null,{"children":"Session-based authentication makes sense for request/responseâtype applications,\nbut for channels, token authentication works better because the connection is a\nlong-duration connection. With token authentication, each user gets a unique\ntoken. Tokens allow for a secure authentication mechanism that doesn't reply on\nany specific transport. Once the user is already authenticated using the\nrequest/response traditional approach, the application can expose the token to\nthe frontend, and this token can be used by the channel."}],"\n",["$","h2",null,{"children":"Ch. 11: OTP"}],"\n",["$","p",null,{"children":"OTP is a way to think about concurrency and distribution, using patterns that\nallow developer to use concurrency to build state without language features that\nrely on mutability."}],"\n",["$","p",null,{"children":"OTP is the name of the library encapsulating concurrent state and behavior, and\nthe abstractions is called generic server, or GenServer."}],"\n",["$","p",null,{"children":"Supervisors need to be able to restart processes in the right way, according to\npolicies that are best for the application. For example, suppose a database was\nupgraded, and the connection stopped. The application would need to\nautomatically kill and restart the connection pool. This policy should not\nimpact the code that uses the database. If developer can replace a simple\nsupervisor process with a supervisor tree, we can build much more robust\nfault-tolerance and recovery software."}],"\n",["$","p",null,{"children":"In Phoenix, there is little code attempting to deal with every possible error\nexception. Instead, we trust the error reporting to log the errors so developer\ncan fix what's broken, and in the meantime, supervisor tree can automatically\nrestart services in a last good state. OTP captures these clean abstractions in\na coherent library, allowing developer to declare the supervision properties\nthat most interest us. This allows developer to build robust self-healing\nsoftware without building complex self-healing software."}],"\n",["$","p",null,{"children":"A supervision strategy is what policy is used when a process dies, for example,\nthe :one_for_one policy will restart a child process when the child dies. If all\nresources depend on a common service, developer could specify :one_for_all to\nkill and restart all child processes if any child dies. Developer doesn't need\nto add any code to fully supervise every process, only configure a policy to\ntell OTP how to handle each crash."}],"\n",["$","p",null,{"children":["The default restart strategy is :permanent, the supervisor always restarts child\nprocesses with this strategy. With ",["$","code",null,{"children":":temporary"}],", the child process is never\nrestarted. Under :transient, the child is restarted of if it terminates\nabnormally, with an exit reason other than ",["$","code",null,{"children":":normal"}],", ",["$","code",null,{"children":":shutdown"}],", or ",["$","code",null,{"children":"{:shutdown, term}"}],"."]}],"\n",["$","p",null,{"children":[["$","code",null,{"children":":temporary"}]," is useful when a restart is unlikely to resolve a worker crash, or\nwhen restarting doesn't make sense based on the flow of the application."]}],"\n",["$","p",null,{"children":"Child processes can have different restart strategies, supervisors have\nconfigurable supervision strategies."}],"\n",["$","pre",null,{"children":["$","code",null,{"children":":one_for_one if a child terminates, the supervisor restarts only that process\n:one_for_all if a child terminates, a supervisor terminates all remaining children, the restarts all children\n:rest_for_one if a child terminates, a supervisor terminates all children defined after the one that died, then restarts all terminated processes\n:simple_on_for_one Similar to :one_for_one but used when a supervisor needs to dynamically supervise processes. For example, a web server would use it to supervise web requests, which may be 10, 10,000, or 100,000 processes.\n"}]}],"\n",["$","p",null,{"children":"A channel in Phoenix is an OTP process built to serve a single user in the\ncontext of a single conversation on a topic."}],"\n",["$","p",null,{"children":"When fetching real-time (pp 212) data about a video that will be synched in\nreal-time, a network or failure by the 3rd party can occur, but since we're\nmaking multiple requests, we can ignore the failure and use the responses from\nthe successful requests. The restart strategy spawns multiple processes and\nshouldn't restart the failures because its time sensitive, the errors can simply\nbe moved past, we'll accept any successful requests that return, so we'll use\nthe :temporary restart strategy."}],"\n",["$","p",null,{"children":"OTP applications protect in both directions, that is, if the Phoenix server\nitself crashes, we bring down the children processes and restart them so no\nresources are leaked. When a child process crashes, we bring down that process\nand restart it so we can attempt clean recovery. When building a supervisor and\nchildren, the process of defining the restart strategy and supervision strategy\nlets developer focus on the main application logic, as any unknowable error\nhandling is already taken care of. Let the errors crash gracefully, and OTP will\nhandle the rest."}],"\n",["$","p",null,{"children":"Because GenServer's are meant to be generic servers, they hold both computation\nand state. However, in many cases, we want a process to store state only, or\nonly execute a particular function. An agent is a simple GenServer"}],"\n",["$","h2",null,{"children":"Chapter 12: Observer and Umbrellas"}],"\n",["$","p",null,{"children":"Umbrella projects allow developer to develop and test multiple child\napplications in isolation side by side while providing conveniences for\nconfiguring and building them only once. Instead of breaking the application\ninto multiple applications in distinct source-code repositories, which adds too\nmuch overhead to the development workflow, you can use Umbrella projects. The\ncombination of Mix and OTP make this abstraction a good one for separating core\nconcerns and dealing with complexity."}],"\n",["$","p",null,{"children":"Observer is an Erlang tool for understanding all running processes in an\napplication. To start:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-bash","children":"iex -S mix\n> :observer.start\n"}]}],"\n",["$","p",null,{"children":"The tool visualizes different aspects of the application, lets developer see a\nlist of all running processes, how much memory, messages the system is using.\nDeveloper can more easily see where bottlenecks occur by finding processes with\nlarge numbers of messages."}],"\n",["$","p",null,{"children":"Each Umbrella has a parent directory that defines"}],"\n",["$","pre",null,{"children":["$","code",null,{"children":"The shared configuration of the project\nThe dependencies for that project\nthe apps directory with child applications\n"}]}],"\n",["$","p",null,{"children":["to create new Umbrella projects, use mix new ",["$","code",null,{"children":"<name> --umbrella"}]," outside of your\napplication, which stubs out a simpler Phoenix app, this project can then be\nmoved inside the parent project."]}],"\n",["$","h2",null,{"children":"Chapter 13: Testing Channels and OTP"}],"\n",["$","p",null,{"children":"Stubs and mocks are both testing fixtures that replace real world\nimplementations. A stub replaces real-world libraries with simpler, predictable\nbehavior. With a stub, developer can bypass code that would be difficult to\ntest. Stubs should have nothing to say whether a test should pass or fail. Stubs\nare a simple scaffold implementation standing in for a more complex real-world\nimplementation."}],"\n",["$","p",null,{"children":"A mock is similar, but replaces real-world behavior just as a stub does, but it\nallows developer to specify expectations and results, playing back those\nexpectations at runtime. A mock will fail a test if the test code doesn't\nreceive the expected function calls. A mock is an implementation that records\nexpected behavior at definition time and plays it back at runtime, expecting\nthose results."}],"\n",["$","p",null,{"children":"Within the Elixir community, avoid mocking whenever possible. Most mocking\nlibraries end up changing global behaviorâfor example, by replacing a function\nin the HTTP client library to return a particular result. These function\nreplacements are global, so a change in one place would change all code running\nat the same time. That means tests written in this way can no longer run\nconcurrently. These strategies will snowball, requiring more and more mocking\nuntil the dependencies among components are completely hidden."}],"\n",["$","p",null,{"children":"A better strategy is to identify code that's difficult to test live, and to\nbuild a configurable, replaceable testing implementation rather than a dynamic\nmock. The development and production code will use the simple :httpc client, and\nthe testing code will use a stub that is called during the tests."}],"\n",["$","p",null,{"children":"A major advantage of writing asynchronous tests in OTP is the tests run\nconcurrently, meaning they can be run in parallel, so the entire suite of tests\ncan finish more quickly than their synchronous counterparts."}],"\n",["$","h2",null,{"children":"References"}],"\n",["$","p",null,{"children":["McCord, Chris. Tate, Bruce. Valim, JosÃ©. (2016). ",["$","em",null,{"children":"Programming Phoenix"}],". The\nPragmatic Programmers. Print."]}]]}],["$","footer",null,{"className":"license_copyright__EpMnZ","children":["This is licensed under a Creative Commons ","cc-by-nc-sa"," International License"]}]]}]
b:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Notes on Programming Phoenix for Elixir"}],["$","meta","3",{"name":"description","content":"Notes and observations on the Phoenix web framework for Elixir."}],["$","link","4",{"rel":"author","href":"https://0xadada.pub"}],["$","meta","5",{"name":"author","content":"0xADADA"}],["$","meta","6",{"name":"keywords","content":"notes,software-development,Elixir"}],["$","link","7",{"rel":"alternate","type":"application/rss+xml","href":"https://0xadada.pub/rss.xml"}],["$","meta","8",{"property":"og:title","content":"Notes on Programming Phoenix for Elixir"}],["$","meta","9",{"property":"og:description","content":"Notes and observations on the Phoenix web framework for Elixir."}],["$","meta","10",{"property":"og:url","content":"https://0xadada.pub/2017/12/22/programming-phoenix/"}],["$","meta","11",{"property":"og:site_name","content":"0xADADA"}],["$","meta","12",{"property":"og:locale","content":"en_US"}],["$","meta","13",{"property":"og:image","content":"https://0xadada.pub/static/images/meta/avatar.svg"}],["$","meta","14",{"property":"og:image:width","content":"660"}],["$","meta","15",{"property":"og:image:height","content":"660"}],["$","meta","16",{"property":"og:type","content":"article"}],["$","meta","17",{"name":"twitter:card","content":"summary_large_image"}],["$","meta","18",{"name":"twitter:title","content":"Notes on Programming Phoenix for Elixir"}],["$","meta","19",{"name":"twitter:description","content":"Notes and observations on the Phoenix web framework for Elixir."}],["$","meta","20",{"name":"twitter:image","content":"https://0xadada.pub/static/images/meta/avatar.svg"}],["$","meta","21",{"name":"twitter:image:width","content":"660"}],["$","meta","22",{"name":"twitter:image:height","content":"660"}],["$","link","23",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"48x48"}],["$","link","24",{"rel":"apple-touch-icon","href":"/apple-icon.png?b764b3a1dbf00a82","type":"image/png","sizes":"180x180"}]]
1:null
