<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Essential Ember Addons: The State of the Ember Addon Ecosystem in 2019</title><meta property="og:site_name" content="0xADADA"/><meta property="og:title" content="Essential Ember Addons: The State of the Ember Addon Ecosystem in 2019"/><meta name="twitter:title" content="Essential Ember Addons: The State of the Ember Addon Ecosystem in 2019"/><link rel="canonical" href="https://0xadada.pub/2019/06/17/essential-ember-addons/"/><meta property="og:url" content="https://0xadada.pub/2019/06/17/essential-ember-addons/"/><meta name="twitter:url" content="https://0xadada.pub/2019/06/17/essential-ember-addons/"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@0xadada"/><meta name="author" content="0xADADA"/><meta property="og:type" content="article"/><meta name="description" content="A list of Ember addons that I use in most of my projects"/><meta name="twitter:description" content="A list of Ember addons that I use in most of my projects"/><meta property="og:image" content="https://0xadada.pub//static/images/2019-06-17-essential-ember-addons.png"/><meta property="og:image:height" content="180"/><meta property="og:image:width" content="180"/><meta name="twitter:image:height" content="512"/><meta name="twitter:image:width" content="512"/><meta property="twitter:image" content="https://0xadada.pub//static/images/2019-06-17-essential-ember-addons.png"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="https://0xadada.pub/favicon.ico"/><link rel="home" href="https://0xadada.pub/"/><link rel="manifest" href="https://0xadada.pub/static/images/meta/0xadada.webmanifest"/><link rel="apple-touch-icon" href="https://0xadada.pub/static/images/meta/apple-touch-icon.png"/><link rel="icon" type="image/png" href="https://0xadada.pub/static/images/meta/favicon-32x32.png" sizes="32x32"/><link rel="icon" type="image/png" href="https://0xadada.pub/static/images/meta/favicon-16x16.png" sizes="16x16"/><link rel="mask-icon" href="https://0xadada.pub/static/images/meta/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-config" content="https://0xadada.pub/static/images/meta/browserconfig.xml"/><meta name="theme-color" content="#FDF9F0"/><meta name="pocket-site-verification" content="7431f135e23a84de547e5b79dab406"/><meta name="next-head-count" content="31"/><link rel="preload" href="/_next/static/css/74865e03e3a036b2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/74865e03e3a036b2.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e491c5ad83d0116a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e491c5ad83d0116a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-22b044904a3f81e0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-929aade252cc0f2b.js" defer=""></script><script src="/_next/static/chunks/929-712c4c3eb0b6b9a9.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-3cef77e4e2f15fd3.js" defer=""></script><script src="/_next/static/9qo_q1KhDow3CWYkBlw8m/_buildManifest.js" defer=""></script><script src="/_next/static/9qo_q1KhDow3CWYkBlw8m/_ssgManifest.js" defer=""></script><script src="/_next/static/9qo_q1KhDow3CWYkBlw8m/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><main class="layout_layout__Xf50c"><article class="hentry h-entry" lang="en-US"><header><h1 class="entry-title p-name">Essential Ember Addons: The State of the Ember Addon Ecosystem in 2019</h1><time class="byline_published__8ePA_ dt-published" dateTime="2019-06-17T22:23:00.000Z">Monday June 17, 2019</time><br/><span class="byline_byline__jNP6Q h-card">by: <span class="author fn p-author p-name">0xADADA</span></span></header><div class="entry-content e-content"><p>2019 has been a great year for Ember so far, so while my peers are focused on
setting direction for the framework for the rest of 2019, I wanted to take stock
of the existing addons ecosystem.</p>
<p>In this article Iâ€™d like to present a list of Ember addons that I use in most of
my projects. I've been using Ember for the last few years as my goâ€“to framework
for developing web applications, and many of these addons make appearances in
nearly all of them.</p>
<p>Ember addons generally fall into one (or more) category of functionality I'll be
referring to throughout this guide:</p>
<ul>
<li><strong>Build-time</strong> Build-time addons provide command-line tools that help
developers during the creation of the application. An example is
<code>ember-cli-eslint</code> which provides code linting, or <code>ember-cli-typescript</code>
which adds a build pipeline for transforming TypeScript files into JavaScript
files. These addons don't ship features to your deployed application. These
addons typically start with the prefix <code>ember-cli-</code><strong>.</strong></li>
<li><strong>Runtime</strong> Runtime addons provide features that will be present in the final
application, these include Ember components like <code>ember-power-select</code> and
<code>ember-svg-jar</code> these addons increase the payload of the deployed application.
These addons typically start with the prefix <code>ember-</code></li>
<li><strong>Infrastructure</strong> Infrastructure addons provide features that aren't shipped
with the payload of your application, but provide functionality that improves
the development ergonomics or deployment of the project. For example
<code>ember-cli-fastboot</code> provides a backend Node.js server for rendering Ember
apps serverside.</li>
<li><strong>Quality Assurance</strong> Quality assurance addons provide tools for improving
quality of code over time, and improving the developer experience of writing
and testing code. These addons typically provide functionality that is used at
build and test time, but isn't shipped to your deployed application.
<code>qunit-dom</code>, <code>coveralls</code>, and <code>ember-test-selectors</code> are examples of quality
assurance addons.</li>
</ul>
<p>Some of these addons are included by default by <code>ember new &#x3C;project-name></code> but
I'll elaborate on their use a bit more.</p>
<p>Finally, before diving into the addon list, I wonâ€™t be discussing many standard
JavaScript packages. There are a bunch of JavaScript packages that I often use
(<code>ramda</code>, <code>lodash</code>, etc) but these are outside of the scope of this article.</p>
<h2>Contents</h2>
<ul>
<li><a href="#general-purpose-addons">General Purpose Addons</a>
<ul>
<li><a href="#ember-a11y-testing">ember-a11y-testing</a></li>
<li><a href="#ember-auto-import">ember-auto-import</a></li>
<li><a href="#ember-cli-update">ember-cli-update</a></li>
<li><a href="#ember-cli-code-coverage">ember-cli-code-coverage</a></li>
<li><a href="#ember-cli-dependency-lint">ember-cli-dependency-lint</a></li>
<li><a href="#ember-cli-deprecation-workflow">ember-cli-deprecation-workflow</a></li>
<li><a href="#ember-cli-document-title">ember-cli-document-title</a></li>
<li><a href="#ember-cli-dotenv">ember-cli-dotenv</a></li>
<li><a href="#ember-cli-template-lint">ember-cli-template-lint</a></li>
<li><a href="#ember-test-selectors">ember-test-selectors</a></li>
<li><a href="#ember-truth-helpers">ember-truth-helpers</a></li>
<li><a href="#eslint-plugin-ember">eslint-plugin-ember</a></li>
<li><a href="#eslint-plugin-prettier">eslint-plugin-prettier</a></li>
<li><a href="#prettier">prettier</a></li>
<li><a href="#qunit-dom">qunit-dom</a></li>
</ul>
</li>
<li><a href="#specific-usecase-addons">Specific Usecase Addons</a>
<ul>
<li><a href="#ember-cli-addon-docs">ember-cli-addon-docs</a></li>
<li><a href="#ember-cli-bundle-analyzer">ember-cli-bundle-analyzer</a></li>
<li><a href="#ember-cli-deploy">ember-cli-deploy</a></li>
<li><a href="#ember-cli-mirage">ember-cli-mirage</a></li>
<li><a href="#ember-cli-page-object">ember-cli-page-object</a></li>
<li><a href="#ember-cli-release">ember-cli-release</a></li>
<li><a href="#ember-cli-typescript">ember-cli-typescript</a></li>
<li><a href="#ember-cli-fastboot">ember-cli-fastboot</a></li>
<li><a href="#ember-cli-fastboot-testing">ember-cli-fastboot-testing</a></li>
<li><a href="#ember-concurrency">ember-concurrency</a></li>
<li><a href="#ember-css-modules">ember-css-modules</a></li>
<li><a href="#ember-intl">ember-intl</a></li>
<li><a href="#ember-intl-analyzer">ember-intl-analyzer</a></li>
<li><a href="#ember-fetch">ember-fetch</a></li>
<li><a href="#ember-power-select">ember-power-select</a></li>
<li><a href="#ember-simple-auth">ember-simple-auth</a></li>
<li><a href="#ember-svg-jar">ember-svg-jar</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2>General Purpose Addons</h2>
<p>These addons are used in nearly all my projects, I often install and configure
them right after I've created a new project.</p>
<h3>ember-a11y-testing</h3>
<p><a href="https://github.com/ember-a11y/ember-a11y-testing">ember-a11y-testing</a> is a
quality assurance addon that integrates into the existing Ember test framework,
adding tests that check for accessibility problems. The addon leverages the
wonderful <a href="https://github.com/dequelabs/axe-core">axe-core library</a> to test for
form labels, high contrast colors, ARIA attributes and much more.</p>
<h3>ember-auto-import</h3>
<p>Ember apps can import standard NPM libraries, but it wasn't straightforward,
until now.</p>
<p><a href="https://github.com/ef4/ember-auto-import">ember-auto-import</a> is included with
the new Ember Octane edition. It is a build time addon with optional runtime
lazy-loading that enables developers to use import statements from standard NPM
packages without having to wrap it in an Ember addon or manually wire it into
the build by adding it to <code>ember-cli-build.js</code></p>
<p>Now we can just:</p>
<pre><code>$ ember install ember-auto-import
$ yarn add -D lodash-es
</code></pre>
<p>and in your code:</p>
<pre><code>import { capitalize } from 'lodash-es';
let nameUpper = capitalize('edward faulkner');
// Edward Faulkner
</code></pre>
<h3>ember-cli-update</h3>
<p><a href="https://github.com/ember-cli/ember-cli-update">ember-cli-update</a> is a build
time addon that adds the <code>update</code> sub-command to the Ember CLI. This command
incrementally updates your app or addon to the latest Ember CLI version. It does
this by fetching the latest version and comparing it to your project's Ember CLI
version. It then applies a diff of the changes from the latest version to your
project. It will only modify the files if there are changes between your
project's version and the latest version, and it will only change the section
necessary, not the entire file.</p>
<p>This tool gets regular use over the lifecycle of all the Ember apps I maintain.</p>
<h3>ember-cli-code-coverage</h3>
<p>ember-cli-code-coverage is a quality assurance addon that runs at test time. The
addon introspects the code running during tests and analyses which code branches
were run and how often. It generates a report showing your source code and which
branches are covered by tests. This allows you to write test code that covers
all code branches. The report looks something like this:</p>
<pre><code>3x  export function asset(param) {
8x    const rootURL = config.rootURL ? config.rootURL : '';
8x    return `${rootURL}${param}`;
    }
</code></pre>
<p>Coveralls is a code-coverage-report-as-a-service provider that tracks your
projects code coverage over time. The tool auto-uploads your coverage report
after tests are run.</p>
<h3>ember-cli-dependency-lint</h3>
<p><a href="https://github.com/salsify/ember-cli-dependency-lint">ember-cli-dependency-lint</a>
is a build time addon that will lint your app's addon dependencies, making sure
your app or addon has only one version of any dependency. If your app has
multiple versions, which is actually packaged in the final build? This situation
can lead to anything from hard exceptions to subtle behavioral bugs.</p>
<pre><code>my-app
â”œâ”€â”¬ ember-modal-dialog
â”‚ â””â”€â”€ ember-wormhole@0.3.6
â””â”€â”¬ ember-power-select
  â””â”€â”¬ ember-basic-dropdown
    â””â”€â”€ ember-wormhole@0.5.1
</code></pre>
<p>This addon will throw a build error until the developer explicitly resolves the
dependency either by pinning the dependency with a resolution, or updating the
addon with the outdated dependency.</p>
<h3>ember-cli-deprecation-workflow</h3>
<p>ember-cli-deprecation-workflow is a runtime addon that comes in handy whenever
you are updating Ember.js or Ember Data, you'll eventually get deprecation
warnings that need to resolved. In the meantime the console is filled with
deprecation warning noise.</p>
<p>The addon listens for deprecation warnings in the console, and adds each to a
list. It allows you to add each deprecation warning to a config file where you
can work through resolving the deprecations one-by-one.</p>
<h3>ember-cli-document-title</h3>
<p>ember-cli-document-title is a runtime addon that lets you update the document
<code>&#x3C;title></code> on a per-route basis. It lets you define the title directly on a
<code>title</code> field on any route:</p>
<pre><code>// app/routes/post.js
export default Ember.Route.extend({
  title: 'A fresh new post ðŸ¥–'
});
</code></pre>
<p>This addon should probably be part of Ember core.</p>
<h3>ember-cli-dotenv</h3>
<p>ember-cli-dotenv is an addon that allows your app to consume environment
variables at build time, as defined in a <code>.env</code> file:</p>
<pre><code>API_HOST=https://api.webapp.dev
API_TOKEN=CHANGEME
API_SECRET=CHANGEME
</code></pre>
<p>This addon reads these variables and exposes them through the built-in
<code>config/environment.js</code> that you can then import in your app wherever you need
them. You might want to make your API endpoint URL, port, or any secrets
configured as environment variables.</p>
<h3>ember-cli-template-lint</h3>
<p>ember-cli-template-lint adds lint tooling for handlebars templates to the
ember-cli. The lint rules are also automatically added to the test runner so the
rules are tested against during <code>ember test</code> runs. This addon was recently
integrated into Ember core as a default addon.</p>
<h3>ember-test-selectors</h3>
<p>ember-test-selectors helps you write tests that look more semantic, and with
less churn between refactors. This is because the pattern leads you do bind your
tests to a test selector that shouldn't change during a refactor (instead of
directly to an HTML tag).</p>
<p>If your component produces HTML markup like this:</p>
<pre><code>&#x3C;!-- before ember-test-selectors -->
&#x3C;h1>{{post.title}}&#x3C;/h1>

&#x3C;!-- after ember-test-selectors -->
&#x3C;h1 data-test-heading>{{post.title}}&#x3C;/h1>
</code></pre>
<p>You'd change your testing patters to something like this:</p>
<pre><code>// without ember-test-selectors
assert.dom('h1').hasText('Example text'); /* you've explicitly tied the test harness
                                           * to an HTML tag &#x3C;h1>.
                                           */

// with ember-test-selectors
assert.dom('[data-test-heading]').hasText('Example text') /* Now you're free to change
                                                           * the HTML tag under test to
                                                           * anything, and the test
                                                           * assertion is less context
                                                           * dependent.
                                                           */
</code></pre>
<p>The test hooks, bindings, and data are removed from production builds leaving
your live code running quickly, and clean of any test artifacts.</p>
<h3>ember-truth-helpers</h3>
<p>ember-truth-helpers is a runtime addon adding a set of useful handlebars
template helpers for additional truth logic, useful in <code>if</code> statements:
<code>eq not-eq not and or xor gt gte lt lte is-array is-empty is-equal</code>.</p>
<h3>qunit-dom</h3>
<p>One of my favorites, qunit-dom is a quality assurance addon that makes for more
elegant test assertions against DOM elements. Given the following rendered Ember
component:</p>
<pre><code>&#x3C;div class="ember-view">
  &#x3C;p class="copy">This is great&#x3C;/p>
&#x3C;/div>
</code></pre>
<p>and some example test code, before and after:</p>
<pre><code>// before qunit-dom
assert.equal(this.element.querySelector('.copy').textContent.trim(), 'This is great');

// after qunit-dom
assert.dom('.copy').hasText('This is great');
</code></pre>
<p>Combining qunit-dom with ember-test-selectors makes for even more powerful test
assertions that are independent of the DOM, and all test artifacts are stripped
from production builds.</p>
<pre><code>&#x3C;div class="ember-view">
  &#x3C;p class="copy" data-test-copy>This is great&#x3C;/p>
&#x3C;/div>

// combining qunit-dom and ember-test-selectors
assert.dom('[data-test-copy]').hasText('This is great')
</code></pre>
<h3>eslint-plugin-ember</h3>
<p>eslint-plugin-ember adds Ember-specific ESLint rules to your ember app, and
comes with a
<a href="https://github.com/ember-cli/eslint-plugin-ember/blob/master/lib/recommended-rules.js">great set of recommended defaults</a>
that are updated as the community coalesces around best practices. This addon
will keep your app code looking clean and tidy, and nudges the code along a path
of best practices.</p>
<p>This addon was integrated into the core as a default addon in Ember 2.18.</p>
<h3>eslint-plugin-prettier</h3>
<p>Prettier is an opinionated code formatter, and eslint-plugin-prettier runs the
format rules as an ESLint rule; it reports differences as errors or warnings as
ESLint issues. This allows you to catch formatting discrepancies in your editor
as well as in CI builds. Prettier rules can be applied automatically in your
editor, or by ESLint using <code>eslint --fix</code>.</p>
<h3>prettier</h3>
<p>Prettier is not an Ember addon, but a package I use in all my Ember projects.
Prettier is a code formatter that can automatically format the code in your
editor (vim, VS Code, etc all have plugins) as well as detecting formatting
issues test time. Super useful for teams trying to maintain a consistent looking
codebase.</p>
<h2>Specific Usecase Addons</h2>
<p>The following addons may not be generally applicable to all applications. I may
not use them in all my projects but, when I need the capabilities they offer,
then I will reach for them. For example, if I need to authenticate users with an
OAuth provider like Facebook or Twitter, I use <code>ember-simple-auth</code>.</p>
<h3>ember-cli-addon-docs</h3>
<p><a href="https://ember-learn.github.io/ember-cli-addon-docs/">ember-cli-addon-docs</a> is a
build time addon that creates an interactive sandbox for versioned addon
documentation. This tools is wonderful for addon (and app developers!) who need
to maintain versioned documentation. This addon lets the developers write their
code and not have to think about how the documentation is presented, generated,
versioned. The addon has its own code syntax highlighting, interactive live
demos, and more.</p>
<h3>ember-cli-bundle-analyzer</h3>
<p>ember-cli-bundle-analyzer is a build-time tool that creates a visualization
chart allowing you to view the size and contents of an app's bundled output,
with their relative and overall sizes. This tool is essential for determining
which packages have the largest impact on the deployment size of your
application payload.</p>
<h3>ember-cli-deploy</h3>
<p>ember-cli-deploy is a build time addon that implements a deployment pipeline to
upload and activate your Ember app on a variety of hosting providers. It uses a
plugin architecture allowing you to find a plugin to deploy to AWS, GCP, and
many many more.</p>
<h3>ember-cli-mirage</h3>
<p>ember-cli-mirage is an addon for mocking backend API responses on the client. It
runs in both development mode and testing mode to help you write, test, and
prototype your app without forcing you to write the backend parts first. The
killer feature is how it unlocks your ability to do FDD (frontend driven
development)â€” you can build frontend features that don't depend on a backend by
mocking the backend in mirage. You can continue modifying mirage requests
alongside your frontend feature. Then when the frontend is feature complete, you
have established a set of clear patterns you can then implement on the backend
of your choice. Mirage is also used during testing, intercepting and mocking API
requests instantly so the tests can run more quickly, without making any
external network requests.</p>
<h3>ember-cli-page-object</h3>
<p>ember-cli-page-object is a test-time addon making it easy to follow the
page-object pattern by Martin Fowler. Page objects allow you to define the shape
of a DOM page in an Ember acceptance test or integration test. They tell your
code <em>what</em> to interact with, but do not make assertions about those objects.
Your tests then reuse this object. This reduces duplication of DOM selectors in
your tests, making your test code less fragile and much easier to refactor.</p>
<h3>ember-cli-release</h3>
<p>ember-cli-release provides a CLI for building your package, auto-incrementing
version numbers, and publishing the packages to a package repository. This is
more useful for Ember addons that typically conform to semver conventions, but
can be used for engines and applications equally.</p>
<h3>ember-cli-typescript</h3>
<p>ember-cli-typescript is a build time addon enabling you to write TypeScript in
your Ember apps. It hooks into the build pipeline and transpiles TypeScript to
JavaScript, and also supplies many of the type definitions for the Ember source
code.</p>
<h3>ember-cli-fastboot</h3>
<p>ember-cli-fastboot is an infrastructure addon. It enables server side rendering
of your Ember application. FastBoot runs your application in Node.js so when a
user visits your site, they are delivered a fully rendered static HTML page, and
only after the content has loaded do they start downloading JavaScript. Once
finished, your Ember app takes over, delivering a typical SPA experience. The
best of both worlds,
<a href="https://0xadada.pub/talk-using-ember-fastboot-in-weird-ways/#gotchas">but not without complexity</a>.</p>
<h3>ember-cli-fastboot-testing</h3>
<p>ember-cli-fastboot-testing is a quality assurance addon that allows you to write
tests against your Ember app running in the Node.js server context. Since
FastBoot runs Ember not in the browser but in a Node.js process, the standard
Ember testing tools don't apply. This addon lets you write acceptance tests that
can excersise code running on the FastBoot server.</p>
<h3>ember-concurrency</h3>
<p>ember-concurrency is a runtime addon that makes it easier to write asynchronus
code that support cancelation, restarting, expose their internal state, and much
more. This addon makes the difficulty of managing state transitions much easier.</p>
<h3>ember-css-modules</h3>
<p>ember-css-modules is a built time addon enabling you to write component-oriented
CSS. Your styles become private to a component, route, or controller, with
explicity features to allow style sharing and composition. It works by making
each CSS file its own isolated namespace by transforming class names to ensure
they're unique. Your <code>.css</code> files are now peers of your component <code>.hbs</code> and
<code>.js</code> files.</p>
<h3>ember-intl</h3>
<p>ember-intl is a runtime addon for building internationalized Ember apps, has
helpers for tranforming strings into multiple locales, formatting for messages,
date/time formats, number, and relative time manipulation. Provides translations
using the ICU Message Syntax standard with pluralization support.</p>
<h3>ember-intl-analyzer</h3>
<p>ember-intl-analyzer is a quality assurance addon providing tools to help you
analyze an internationalized app and will locate unused translations.</p>
<h3>ember-fetch</h3>
<p>ember-fetch is a runtime addon providing an alternative to AJAX requests. It
allows the app to make network requests. ember-fetch is useful for applications
needing to support network requests in both a browser and FastBoot context, and
do not need to depend on jQuery.</p>
<h3>ember-power-select</h3>
<p>ember-power-select is a runtime addon providing a powerful, and extensible
<code>&#x3C;select></code> dropdown component that is highly customizable.</p>
<h3>ember-simple-auth</h3>
<p>ember-simple-auth is a runtime addon for implementing authentication and
authorization. It maintains an authenticated client side session, authorizes
network requests, and provides helpers in authentication flows like OAuth.</p>
<h3>ember-svg-jar</h3>
<p>ember-svg-jar is both a build and runtime addon that improves the developer
ergonomics around working with SVG assets. It adds a build-time pipeline that
discovers SVG files in the project repo and packages them as Ember templates.
These are then inlined into your app with an Ember template helper
<code>&#x3C;SvgJar "[ASSET_NAME]"></code> that embeds the SVG directly into the markup of your
page, without an additional network request. It also has a beautiful visual
directory route displaying all the SVG assets in your app.</p>
<h2>Conclusion</h2>
<p>The above addons should cover most of your Ember needs. I have only listed
addons with good documentation, test coverage, and that continue to be
maintained. If you need anything more or want to take a general look at some of
the addons that have are available I recommend starting with
<a href="https://emberobserver.com/">emberobserver.com</a>.</p>
</div><footer class="license_copyright__KOT7N">This is licensed under a Creative Commons <!-- -->cc-by-nc-sa<!-- --> International License</footer></article></main><div class="layout_layout__Xf50c"><footer class="footer_footer__OT4Wn layout_layout__Xf50c"><p>Â© 2003-<!-- -->2022<!-- --> 0xADADA (unless otherwise noted.)<br/><a title="0xADADA" href="/">Home</a> <span class="h-card"><a class="c-Meta u-email" rel="me" title="0xADADA" href="mailto:0xadada.pub@protonmail.com">Email</a> </span><a rel="me nofollow external noopener" title="0xADADA on Twitter" href="https://twitter.com/0xadada">Twitter</a> <a rel="me nofollow external noopener" title="0xADADA on GitHub" href="https://github.com/0xadada">GitHub</a> <a rel="me nofollow external noopener" title="0xADADA on Goodreads" href="https://www.goodreads.com/review/list/60524683-0xadada?shelf=wanted">Goodreads</a> </p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slugs":{"year":"2019","month":"06","day":"17","slug":"essential-ember-addons"},"title":"Essential Ember Addons: The State of the Ember Addon Ecosystem in 2019","displayTitle":"Essential Ember Addons: The State of the Ember Addon Ecosystem in 2019","metaDescription":"A list of Ember addons that I use in most of my projects","metaKeywords":"ember, ember.js, addons, ember addons, web framework, web development, programming, software engineering","image":"/static/images/2019-06-17-essential-ember-addons.png","metaImage":"/static/images/2019-06-17-essential-ember-addons.png","date":1560810180000,"author":"0xADADA","content":"\u003cp\u003e2019 has been a great year for Ember so far, so while my peers are focused on\nsetting direction for the framework for the rest of 2019, I wanted to take stock\nof the existing addons ecosystem.\u003c/p\u003e\n\u003cp\u003eIn this article Iâ€™d like to present a list of Ember addons that I use in most of\nmy projects. I've been using Ember for the last few years as my goâ€“to framework\nfor developing web applications, and many of these addons make appearances in\nnearly all of them.\u003c/p\u003e\n\u003cp\u003eEmber addons generally fall into one (or more) category of functionality I'll be\nreferring to throughout this guide:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eBuild-time\u003c/strong\u003e Build-time addons provide command-line tools that help\ndevelopers during the creation of the application. An example is\n\u003ccode\u003eember-cli-eslint\u003c/code\u003e which provides code linting, or \u003ccode\u003eember-cli-typescript\u003c/code\u003e\nwhich adds a build pipeline for transforming TypeScript files into JavaScript\nfiles. These addons don't ship features to your deployed application. These\naddons typically start with the prefix \u003ccode\u003eember-cli-\u003c/code\u003e\u003cstrong\u003e.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRuntime\u003c/strong\u003e Runtime addons provide features that will be present in the final\napplication, these include Ember components like \u003ccode\u003eember-power-select\u003c/code\u003e and\n\u003ccode\u003eember-svg-jar\u003c/code\u003e these addons increase the payload of the deployed application.\nThese addons typically start with the prefix \u003ccode\u003eember-\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInfrastructure\u003c/strong\u003e Infrastructure addons provide features that aren't shipped\nwith the payload of your application, but provide functionality that improves\nthe development ergonomics or deployment of the project. For example\n\u003ccode\u003eember-cli-fastboot\u003c/code\u003e provides a backend Node.js server for rendering Ember\napps serverside.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eQuality Assurance\u003c/strong\u003e Quality assurance addons provide tools for improving\nquality of code over time, and improving the developer experience of writing\nand testing code. These addons typically provide functionality that is used at\nbuild and test time, but isn't shipped to your deployed application.\n\u003ccode\u003equnit-dom\u003c/code\u003e, \u003ccode\u003ecoveralls\u003c/code\u003e, and \u003ccode\u003eember-test-selectors\u003c/code\u003e are examples of quality\nassurance addons.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSome of these addons are included by default by \u003ccode\u003eember new \u0026#x3C;project-name\u003e\u003c/code\u003e but\nI'll elaborate on their use a bit more.\u003c/p\u003e\n\u003cp\u003eFinally, before diving into the addon list, I wonâ€™t be discussing many standard\nJavaScript packages. There are a bunch of JavaScript packages that I often use\n(\u003ccode\u003eramda\u003c/code\u003e, \u003ccode\u003elodash\u003c/code\u003e, etc) but these are outside of the scope of this article.\u003c/p\u003e\n\u003ch2\u003eContents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#general-purpose-addons\"\u003eGeneral Purpose Addons\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#ember-a11y-testing\"\u003eember-a11y-testing\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-auto-import\"\u003eember-auto-import\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-update\"\u003eember-cli-update\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-code-coverage\"\u003eember-cli-code-coverage\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-dependency-lint\"\u003eember-cli-dependency-lint\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-deprecation-workflow\"\u003eember-cli-deprecation-workflow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-document-title\"\u003eember-cli-document-title\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-dotenv\"\u003eember-cli-dotenv\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-template-lint\"\u003eember-cli-template-lint\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-test-selectors\"\u003eember-test-selectors\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-truth-helpers\"\u003eember-truth-helpers\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#eslint-plugin-ember\"\u003eeslint-plugin-ember\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#eslint-plugin-prettier\"\u003eeslint-plugin-prettier\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#prettier\"\u003eprettier\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#qunit-dom\"\u003equnit-dom\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#specific-usecase-addons\"\u003eSpecific Usecase Addons\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-addon-docs\"\u003eember-cli-addon-docs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-bundle-analyzer\"\u003eember-cli-bundle-analyzer\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-deploy\"\u003eember-cli-deploy\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-mirage\"\u003eember-cli-mirage\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-page-object\"\u003eember-cli-page-object\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-release\"\u003eember-cli-release\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-typescript\"\u003eember-cli-typescript\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-fastboot\"\u003eember-cli-fastboot\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-cli-fastboot-testing\"\u003eember-cli-fastboot-testing\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-concurrency\"\u003eember-concurrency\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-css-modules\"\u003eember-css-modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-intl\"\u003eember-intl\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-intl-analyzer\"\u003eember-intl-analyzer\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-fetch\"\u003eember-fetch\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-power-select\"\u003eember-power-select\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-simple-auth\"\u003eember-simple-auth\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ember-svg-jar\"\u003eember-svg-jar\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eGeneral Purpose Addons\u003c/h2\u003e\n\u003cp\u003eThese addons are used in nearly all my projects, I often install and configure\nthem right after I've created a new project.\u003c/p\u003e\n\u003ch3\u003eember-a11y-testing\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/ember-a11y/ember-a11y-testing\"\u003eember-a11y-testing\u003c/a\u003e is a\nquality assurance addon that integrates into the existing Ember test framework,\nadding tests that check for accessibility problems. The addon leverages the\nwonderful \u003ca href=\"https://github.com/dequelabs/axe-core\"\u003eaxe-core library\u003c/a\u003e to test for\nform labels, high contrast colors, ARIA attributes and much more.\u003c/p\u003e\n\u003ch3\u003eember-auto-import\u003c/h3\u003e\n\u003cp\u003eEmber apps can import standard NPM libraries, but it wasn't straightforward,\nuntil now.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/ef4/ember-auto-import\"\u003eember-auto-import\u003c/a\u003e is included with\nthe new Ember Octane edition. It is a build time addon with optional runtime\nlazy-loading that enables developers to use import statements from standard NPM\npackages without having to wrap it in an Ember addon or manually wire it into\nthe build by adding it to \u003ccode\u003eember-cli-build.js\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNow we can just:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ ember install ember-auto-import\n$ yarn add -D lodash-es\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand in your code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport { capitalize } from 'lodash-es';\nlet nameUpper = capitalize('edward faulkner');\n// Edward Faulkner\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eember-cli-update\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/ember-cli/ember-cli-update\"\u003eember-cli-update\u003c/a\u003e is a build\ntime addon that adds the \u003ccode\u003eupdate\u003c/code\u003e sub-command to the Ember CLI. This command\nincrementally updates your app or addon to the latest Ember CLI version. It does\nthis by fetching the latest version and comparing it to your project's Ember CLI\nversion. It then applies a diff of the changes from the latest version to your\nproject. It will only modify the files if there are changes between your\nproject's version and the latest version, and it will only change the section\nnecessary, not the entire file.\u003c/p\u003e\n\u003cp\u003eThis tool gets regular use over the lifecycle of all the Ember apps I maintain.\u003c/p\u003e\n\u003ch3\u003eember-cli-code-coverage\u003c/h3\u003e\n\u003cp\u003eember-cli-code-coverage is a quality assurance addon that runs at test time. The\naddon introspects the code running during tests and analyses which code branches\nwere run and how often. It generates a report showing your source code and which\nbranches are covered by tests. This allows you to write test code that covers\nall code branches. The report looks something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e3x  export function asset(param) {\n8x    const rootURL = config.rootURL ? config.rootURL : '';\n8x    return `${rootURL}${param}`;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCoveralls is a code-coverage-report-as-a-service provider that tracks your\nprojects code coverage over time. The tool auto-uploads your coverage report\nafter tests are run.\u003c/p\u003e\n\u003ch3\u003eember-cli-dependency-lint\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/salsify/ember-cli-dependency-lint\"\u003eember-cli-dependency-lint\u003c/a\u003e\nis a build time addon that will lint your app's addon dependencies, making sure\nyour app or addon has only one version of any dependency. If your app has\nmultiple versions, which is actually packaged in the final build? This situation\ncan lead to anything from hard exceptions to subtle behavioral bugs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emy-app\nâ”œâ”€â”¬ ember-modal-dialog\nâ”‚ â””â”€â”€ ember-wormhole@0.3.6\nâ””â”€â”¬ ember-power-select\n  â””â”€â”¬ ember-basic-dropdown\n    â””â”€â”€ ember-wormhole@0.5.1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis addon will throw a build error until the developer explicitly resolves the\ndependency either by pinning the dependency with a resolution, or updating the\naddon with the outdated dependency.\u003c/p\u003e\n\u003ch3\u003eember-cli-deprecation-workflow\u003c/h3\u003e\n\u003cp\u003eember-cli-deprecation-workflow is a runtime addon that comes in handy whenever\nyou are updating Ember.js or Ember Data, you'll eventually get deprecation\nwarnings that need to resolved. In the meantime the console is filled with\ndeprecation warning noise.\u003c/p\u003e\n\u003cp\u003eThe addon listens for deprecation warnings in the console, and adds each to a\nlist. It allows you to add each deprecation warning to a config file where you\ncan work through resolving the deprecations one-by-one.\u003c/p\u003e\n\u003ch3\u003eember-cli-document-title\u003c/h3\u003e\n\u003cp\u003eember-cli-document-title is a runtime addon that lets you update the document\n\u003ccode\u003e\u0026#x3C;title\u003e\u003c/code\u003e on a per-route basis. It lets you define the title directly on a\n\u003ccode\u003etitle\u003c/code\u003e field on any route:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// app/routes/post.js\nexport default Ember.Route.extend({\n  title: 'A fresh new post ðŸ¥–'\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis addon should probably be part of Ember core.\u003c/p\u003e\n\u003ch3\u003eember-cli-dotenv\u003c/h3\u003e\n\u003cp\u003eember-cli-dotenv is an addon that allows your app to consume environment\nvariables at build time, as defined in a \u003ccode\u003e.env\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAPI_HOST=https://api.webapp.dev\nAPI_TOKEN=CHANGEME\nAPI_SECRET=CHANGEME\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis addon reads these variables and exposes them through the built-in\n\u003ccode\u003econfig/environment.js\u003c/code\u003e that you can then import in your app wherever you need\nthem. You might want to make your API endpoint URL, port, or any secrets\nconfigured as environment variables.\u003c/p\u003e\n\u003ch3\u003eember-cli-template-lint\u003c/h3\u003e\n\u003cp\u003eember-cli-template-lint adds lint tooling for handlebars templates to the\nember-cli. The lint rules are also automatically added to the test runner so the\nrules are tested against during \u003ccode\u003eember test\u003c/code\u003e runs. This addon was recently\nintegrated into Ember core as a default addon.\u003c/p\u003e\n\u003ch3\u003eember-test-selectors\u003c/h3\u003e\n\u003cp\u003eember-test-selectors helps you write tests that look more semantic, and with\nless churn between refactors. This is because the pattern leads you do bind your\ntests to a test selector that shouldn't change during a refactor (instead of\ndirectly to an HTML tag).\u003c/p\u003e\n\u003cp\u003eIf your component produces HTML markup like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;!-- before ember-test-selectors --\u003e\n\u0026#x3C;h1\u003e{{post.title}}\u0026#x3C;/h1\u003e\n\n\u0026#x3C;!-- after ember-test-selectors --\u003e\n\u0026#x3C;h1 data-test-heading\u003e{{post.title}}\u0026#x3C;/h1\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou'd change your testing patters to something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// without ember-test-selectors\nassert.dom('h1').hasText('Example text'); /* you've explicitly tied the test harness\n                                           * to an HTML tag \u0026#x3C;h1\u003e.\n                                           */\n\n// with ember-test-selectors\nassert.dom('[data-test-heading]').hasText('Example text') /* Now you're free to change\n                                                           * the HTML tag under test to\n                                                           * anything, and the test\n                                                           * assertion is less context\n                                                           * dependent.\n                                                           */\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe test hooks, bindings, and data are removed from production builds leaving\nyour live code running quickly, and clean of any test artifacts.\u003c/p\u003e\n\u003ch3\u003eember-truth-helpers\u003c/h3\u003e\n\u003cp\u003eember-truth-helpers is a runtime addon adding a set of useful handlebars\ntemplate helpers for additional truth logic, useful in \u003ccode\u003eif\u003c/code\u003e statements:\n\u003ccode\u003eeq not-eq not and or xor gt gte lt lte is-array is-empty is-equal\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003equnit-dom\u003c/h3\u003e\n\u003cp\u003eOne of my favorites, qunit-dom is a quality assurance addon that makes for more\nelegant test assertions against DOM elements. Given the following rendered Ember\ncomponent:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;div class=\"ember-view\"\u003e\n  \u0026#x3C;p class=\"copy\"\u003eThis is great\u0026#x3C;/p\u003e\n\u0026#x3C;/div\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand some example test code, before and after:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// before qunit-dom\nassert.equal(this.element.querySelector('.copy').textContent.trim(), 'This is great');\n\n// after qunit-dom\nassert.dom('.copy').hasText('This is great');\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCombining qunit-dom with ember-test-selectors makes for even more powerful test\nassertions that are independent of the DOM, and all test artifacts are stripped\nfrom production builds.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;div class=\"ember-view\"\u003e\n  \u0026#x3C;p class=\"copy\" data-test-copy\u003eThis is great\u0026#x3C;/p\u003e\n\u0026#x3C;/div\u003e\n\n// combining qunit-dom and ember-test-selectors\nassert.dom('[data-test-copy]').hasText('This is great')\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eeslint-plugin-ember\u003c/h3\u003e\n\u003cp\u003eeslint-plugin-ember adds Ember-specific ESLint rules to your ember app, and\ncomes with a\n\u003ca href=\"https://github.com/ember-cli/eslint-plugin-ember/blob/master/lib/recommended-rules.js\"\u003egreat set of recommended defaults\u003c/a\u003e\nthat are updated as the community coalesces around best practices. This addon\nwill keep your app code looking clean and tidy, and nudges the code along a path\nof best practices.\u003c/p\u003e\n\u003cp\u003eThis addon was integrated into the core as a default addon in Ember 2.18.\u003c/p\u003e\n\u003ch3\u003eeslint-plugin-prettier\u003c/h3\u003e\n\u003cp\u003ePrettier is an opinionated code formatter, and eslint-plugin-prettier runs the\nformat rules as an ESLint rule; it reports differences as errors or warnings as\nESLint issues. This allows you to catch formatting discrepancies in your editor\nas well as in CI builds. Prettier rules can be applied automatically in your\neditor, or by ESLint using \u003ccode\u003eeslint --fix\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eprettier\u003c/h3\u003e\n\u003cp\u003ePrettier is not an Ember addon, but a package I use in all my Ember projects.\nPrettier is a code formatter that can automatically format the code in your\neditor (vim, VS Code, etc all have plugins) as well as detecting formatting\nissues test time. Super useful for teams trying to maintain a consistent looking\ncodebase.\u003c/p\u003e\n\u003ch2\u003eSpecific Usecase Addons\u003c/h2\u003e\n\u003cp\u003eThe following addons may not be generally applicable to all applications. I may\nnot use them in all my projects but, when I need the capabilities they offer,\nthen I will reach for them. For example, if I need to authenticate users with an\nOAuth provider like Facebook or Twitter, I use \u003ccode\u003eember-simple-auth\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eember-cli-addon-docs\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://ember-learn.github.io/ember-cli-addon-docs/\"\u003eember-cli-addon-docs\u003c/a\u003e is a\nbuild time addon that creates an interactive sandbox for versioned addon\ndocumentation. This tools is wonderful for addon (and app developers!) who need\nto maintain versioned documentation. This addon lets the developers write their\ncode and not have to think about how the documentation is presented, generated,\nversioned. The addon has its own code syntax highlighting, interactive live\ndemos, and more.\u003c/p\u003e\n\u003ch3\u003eember-cli-bundle-analyzer\u003c/h3\u003e\n\u003cp\u003eember-cli-bundle-analyzer is a build-time tool that creates a visualization\nchart allowing you to view the size and contents of an app's bundled output,\nwith their relative and overall sizes. This tool is essential for determining\nwhich packages have the largest impact on the deployment size of your\napplication payload.\u003c/p\u003e\n\u003ch3\u003eember-cli-deploy\u003c/h3\u003e\n\u003cp\u003eember-cli-deploy is a build time addon that implements a deployment pipeline to\nupload and activate your Ember app on a variety of hosting providers. It uses a\nplugin architecture allowing you to find a plugin to deploy to AWS, GCP, and\nmany many more.\u003c/p\u003e\n\u003ch3\u003eember-cli-mirage\u003c/h3\u003e\n\u003cp\u003eember-cli-mirage is an addon for mocking backend API responses on the client. It\nruns in both development mode and testing mode to help you write, test, and\nprototype your app without forcing you to write the backend parts first. The\nkiller feature is how it unlocks your ability to do FDD (frontend driven\ndevelopment)â€” you can build frontend features that don't depend on a backend by\nmocking the backend in mirage. You can continue modifying mirage requests\nalongside your frontend feature. Then when the frontend is feature complete, you\nhave established a set of clear patterns you can then implement on the backend\nof your choice. Mirage is also used during testing, intercepting and mocking API\nrequests instantly so the tests can run more quickly, without making any\nexternal network requests.\u003c/p\u003e\n\u003ch3\u003eember-cli-page-object\u003c/h3\u003e\n\u003cp\u003eember-cli-page-object is a test-time addon making it easy to follow the\npage-object pattern by Martin Fowler. Page objects allow you to define the shape\nof a DOM page in an Ember acceptance test or integration test. They tell your\ncode \u003cem\u003ewhat\u003c/em\u003e to interact with, but do not make assertions about those objects.\nYour tests then reuse this object. This reduces duplication of DOM selectors in\nyour tests, making your test code less fragile and much easier to refactor.\u003c/p\u003e\n\u003ch3\u003eember-cli-release\u003c/h3\u003e\n\u003cp\u003eember-cli-release provides a CLI for building your package, auto-incrementing\nversion numbers, and publishing the packages to a package repository. This is\nmore useful for Ember addons that typically conform to semver conventions, but\ncan be used for engines and applications equally.\u003c/p\u003e\n\u003ch3\u003eember-cli-typescript\u003c/h3\u003e\n\u003cp\u003eember-cli-typescript is a build time addon enabling you to write TypeScript in\nyour Ember apps. It hooks into the build pipeline and transpiles TypeScript to\nJavaScript, and also supplies many of the type definitions for the Ember source\ncode.\u003c/p\u003e\n\u003ch3\u003eember-cli-fastboot\u003c/h3\u003e\n\u003cp\u003eember-cli-fastboot is an infrastructure addon. It enables server side rendering\nof your Ember application. FastBoot runs your application in Node.js so when a\nuser visits your site, they are delivered a fully rendered static HTML page, and\nonly after the content has loaded do they start downloading JavaScript. Once\nfinished, your Ember app takes over, delivering a typical SPA experience. The\nbest of both worlds,\n\u003ca href=\"https://0xadada.pub/talk-using-ember-fastboot-in-weird-ways/#gotchas\"\u003ebut not without complexity\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eember-cli-fastboot-testing\u003c/h3\u003e\n\u003cp\u003eember-cli-fastboot-testing is a quality assurance addon that allows you to write\ntests against your Ember app running in the Node.js server context. Since\nFastBoot runs Ember not in the browser but in a Node.js process, the standard\nEmber testing tools don't apply. This addon lets you write acceptance tests that\ncan excersise code running on the FastBoot server.\u003c/p\u003e\n\u003ch3\u003eember-concurrency\u003c/h3\u003e\n\u003cp\u003eember-concurrency is a runtime addon that makes it easier to write asynchronus\ncode that support cancelation, restarting, expose their internal state, and much\nmore. This addon makes the difficulty of managing state transitions much easier.\u003c/p\u003e\n\u003ch3\u003eember-css-modules\u003c/h3\u003e\n\u003cp\u003eember-css-modules is a built time addon enabling you to write component-oriented\nCSS. Your styles become private to a component, route, or controller, with\nexplicity features to allow style sharing and composition. It works by making\neach CSS file its own isolated namespace by transforming class names to ensure\nthey're unique. Your \u003ccode\u003e.css\u003c/code\u003e files are now peers of your component \u003ccode\u003e.hbs\u003c/code\u003e and\n\u003ccode\u003e.js\u003c/code\u003e files.\u003c/p\u003e\n\u003ch3\u003eember-intl\u003c/h3\u003e\n\u003cp\u003eember-intl is a runtime addon for building internationalized Ember apps, has\nhelpers for tranforming strings into multiple locales, formatting for messages,\ndate/time formats, number, and relative time manipulation. Provides translations\nusing the ICU Message Syntax standard with pluralization support.\u003c/p\u003e\n\u003ch3\u003eember-intl-analyzer\u003c/h3\u003e\n\u003cp\u003eember-intl-analyzer is a quality assurance addon providing tools to help you\nanalyze an internationalized app and will locate unused translations.\u003c/p\u003e\n\u003ch3\u003eember-fetch\u003c/h3\u003e\n\u003cp\u003eember-fetch is a runtime addon providing an alternative to AJAX requests. It\nallows the app to make network requests. ember-fetch is useful for applications\nneeding to support network requests in both a browser and FastBoot context, and\ndo not need to depend on jQuery.\u003c/p\u003e\n\u003ch3\u003eember-power-select\u003c/h3\u003e\n\u003cp\u003eember-power-select is a runtime addon providing a powerful, and extensible\n\u003ccode\u003e\u0026#x3C;select\u003e\u003c/code\u003e dropdown component that is highly customizable.\u003c/p\u003e\n\u003ch3\u003eember-simple-auth\u003c/h3\u003e\n\u003cp\u003eember-simple-auth is a runtime addon for implementing authentication and\nauthorization. It maintains an authenticated client side session, authorizes\nnetwork requests, and provides helpers in authentication flows like OAuth.\u003c/p\u003e\n\u003ch3\u003eember-svg-jar\u003c/h3\u003e\n\u003cp\u003eember-svg-jar is both a build and runtime addon that improves the developer\nergonomics around working with SVG assets. It adds a build-time pipeline that\ndiscovers SVG files in the project repo and packages them as Ember templates.\nThese are then inlined into your app with an Ember template helper\n\u003ccode\u003e\u0026#x3C;SvgJar \"[ASSET_NAME]\"\u003e\u003c/code\u003e that embeds the SVG directly into the markup of your\npage, without an additional network request. It also has a beautiful visual\ndirectory route displaying all the SVG assets in your app.\u003c/p\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThe above addons should cover most of your Ember needs. I have only listed\naddons with good documentation, test coverage, and that continue to be\nmaintained. If you need anything more or want to take a general look at some of\nthe addons that have are available I recommend starting with\n\u003ca href=\"https://emberobserver.com/\"\u003eemberobserver.com\u003c/a\u003e.\u003c/p\u003e\n","slug":"2019-06-17-essential-ember-addons","license":"cc-by-nc-sa"}},"__N_SSG":true},"page":"/[year]/[month]/[day]/[slug]","query":{"year":"2019","month":"06","day":"17","slug":"essential-ember-addons"},"buildId":"9qo_q1KhDow3CWYkBlw8m","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>