<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Ember Templates: Classic vs Angle Bracket Syntaxes</title><meta property="og:site_name" content="0xADADA"/><meta property="og:title" content="Ember Templates: Classic vs Angle Bracket Syntaxes"/><meta name="twitter:title" content="Ember Templates: Classic vs Angle Bracket Syntaxes"/><link rel="canonical" href="https://0xadada.pub/2020/03/20/ember-emplates-classic-vs-angle-bracket-syntaxes/"/><link type="application/rss+xml" rel="alternate" href="/rss.xml" title="0xADADA"/><meta property="og:url" content="https://0xadada.pub/2020/03/20/ember-emplates-classic-vs-angle-bracket-syntaxes/"/><meta name="twitter:url" content="https://0xadada.pub/2020/03/20/ember-emplates-classic-vs-angle-bracket-syntaxes/"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@0xadada"/><meta name="author" content="0xADADA"/><meta property="og:type" content="article"/><meta name="description" content="Diving into the difference between Ember component invocation when using curlies, angle brackets, and s-expression in Ember templates."/><meta name="og:description" content="Diving into the difference between Ember component invocation when using curlies, angle brackets, and s-expression in Ember templates."/><meta name="twitter:description" content="Diving into the difference between Ember component invocation when using curlies, angle brackets, and s-expression in Ember templates."/><meta property="og:image" content="https://0xadada.pub//static/images/2020-03-20-ember-emplates-classic-vs-angle-bracket-syntaxes.png"/><meta property="og:image:height" content="180"/><meta property="og:image:width" content="180"/><meta name="twitter:image:height" content="512"/><meta name="twitter:image:width" content="512"/><meta property="twitter:image" content="https://0xadada.pub//static/images/2020-03-20-ember-emplates-classic-vs-angle-bracket-syntaxes.png"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="https://0xadada.pub/favicon.ico"/><link rel="home" href="https://0xadada.pub/"/><link rel="manifest" href="https://0xadada.pub/static/images/meta/0xadada.webmanifest"/><link rel="apple-touch-icon" href="https://0xadada.pub/static/images/meta/apple-touch-icon.png"/><link rel="icon" type="image/png" href="https://0xadada.pub/static/images/meta/favicon-32x32.png" sizes="32x32"/><link rel="icon" type="image/png" href="https://0xadada.pub/static/images/meta/favicon-16x16.png" sizes="16x16"/><link rel="mask-icon" href="https://0xadada.pub/static/images/meta/safari-pinned-tab.svg" color="#5bbad5"/><meta name="theme-color" content="#FDF9F0"/><meta name="pocket-site-verification" content="7431f135e23a84de547e5b79dab406"/><meta name="next-head-count" content="32"/><link rel="preload" href="/_next/static/css/49969f6af05533cc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/49969f6af05533cc.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e491c5ad83d0116a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e491c5ad83d0116a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-22b044904a3f81e0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-929aade252cc0f2b.js" defer=""></script><script src="/_next/static/chunks/392-e44e3e95fe0288b1.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-a818a8866f202bc1.js" defer=""></script><script src="/_next/static/YhuQQcfgfqkyD_Ns_aB2N/_buildManifest.js" defer=""></script><script src="/_next/static/YhuQQcfgfqkyD_Ns_aB2N/_ssgManifest.js" defer=""></script><script src="/_next/static/YhuQQcfgfqkyD_Ns_aB2N/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><main class="layout_layout__Xf50c"><article class="hentry h-entry" lang="en-US"><header><h1 class="entry-title p-name">Ember Templates: Classic vs Angle Bracket Syntaxes</h1><time class="byline_published__8ePA_ dt-published" dateTime="2020-03-20T16:14:00.000Z">Friday March 20, 2020</time><br/><span class="byline_byline__jNP6Q h-card">by: <span class="author fn p-author p-name">0xADADA</span></span></header><div class="entry-content e-content"><p>This articles describes the difference between how component invocation differs
when using curlies <code>{​{...}}</code>, angle brackets <code>&#x3C;...></code> or an <code>(...)</code> s-expression
in Ember templates.</p>
<p>Ember has three methods for invoking components and helpers in a template,
either of the three can be used to invoke both classic and modern glimmer
components.</p>
<p>The "classic" syntax in the form that uses curly braces <code>{​{...}}</code>, e.g.</p>
<pre><code class="language-html">{​{user-profile firstName="Dan" lastName="F."}}
</code></pre>
<p>The "angle bracket" syntax that uses a HTML-like form <code>&#x3C;... /></code>, e.g.:</p>
<pre><code class="language-html">&#x3C;UserProfile @firstName="Dan" @lastName="F." />
</code></pre>
<p>Finally the s-expression (for sub-expression) form used inside curly and angle
bracket syntax to invoke a sub component or helper. This takes the form
<code>(concat a " " b)</code>, thus:</p>
<pre><code class="language-html">{​{user-profile name=(concat firstName " " lastName)}}
</code></pre>
<p>and</p>
<pre><code class="language-html">&#x3C;UserProfile @classNames={​{concat "sticky " (if this.isActive "is-active")}} />
</code></pre>
<h2>Angle Brackets</h2>
<p>Similar to the vanilla DOM APIs that distinguish between
<a href="https://joji.me/en-us/blog/html-attribute-vs-dom-property/">JS properties from HTML attributes</a>,
angle bracket component invocations have two different namespaces you're
operating against.</p>
<p>You are probably most familiar with HTML attributes, which tell the browser how
to draw an HTML element. These attributes can do things like defining the <code>alt</code>
text on an image <code>&#x3C;img alt="A bird"></code> or the URL on an anchor tag
<code>&#x3C;a href="https://example.com"></code>. Angle bracket syntax implements attributes in
a similar way, allowing the developer to apply these attributes to a DOM node
somewhere in the component's template.</p>
<pre><code class="language-html">&#x3C;!-- parent.hbs -->
&#x3C;UserProfile class="abc" @tagName="figure" />
</code></pre>
<p>The <code>...attributes</code> syntax determines where the attributes passed into a
component from an angle bracket invocation should appear in the component's
template. Any number of attributes
<a href="https://github.com/emberjs/rfcs/blob/master/text/0435-modifier-splattributes.md">and element modifiers</a>
can be specified on the user profile component now, and they will all be applied
to the element that has <code>...attributes</code> on it.</p>
<pre><code class="language-html">&#x3C;!-- UserProfile.hbs -->
&#x3C;figure>
  &#x3C;img ...attributes src="default.jpg" />
&#x3C;/figure>
</code></pre>
<p>the resulting HTML output is:</p>
<pre><code class="language-html">&#x3C;figure>
  &#x3C;img class="abc" src="default.jpg" />
&#x3C;/figure>
</code></pre>
<p>Anything prefixed with <code>@</code> is an "argument", is passed to the component by its
caller, is accessible to the class backing the component, and can be any JS
runtime value. Unlike attributes, which tell the browser what to render,
arguments tell your custom Ember component tag what to do.</p>
<pre><code class="language-html">&#x3C;!-- parent.hbs -->
&#x3C;UserProfile @name="Dan F." />
</code></pre>
<p>This template invokes the <code>&#x3C;UserProfile></code> component, which expects one argument:
<code>@name</code>, the value we pass is the hardcoded string "Dan F.".</p>
<p>In the backing component class, arguments are namespaced on the <code>this.args</code>
object, which is immutable. You can access this argument as:</p>
<pre><code class="language-js">// user-profile.js
this.args.name; // "Dan F."
</code></pre>
<p>To illustrate the differences, here is an invocation of an angle bracket
component using both arguments and attributes:</p>
<pre><code class="language-html">&#x3C;Foo
  @bar={​{123}}
  @baz={​{hash a="1" b="hi"}}
  class="hello"
  data-fizz="ok"
/>
</code></pre>
<p>In the above, <code>bar</code> and <code>baz</code> would be arguments with the values <code>123</code> and
<code>{ a: 1, b: 'hi' }</code> respectively, while <code>class</code> and <code>data-fizz</code> would be
attributes that could be applied to a DOM node somewhere in the component's
template.</p>
<h2>Curly and s-expression Syntax</h2>
<p>Ember curly (also called "classic") component invocation only have one
namespace: the argument, everything is treated as an argument, as if you
implicitly included <code>@</code> in front of each one. Historically, this was compensated
for by automatically applying the value of the <code>class</code> argument to the <code>class</code>
<em>attribute</em> of a component's root element (if it had one), and this behavior
could be extended to other attributes using the Ember classic
<code>attributeBindings</code> API.</p>
<pre><code class="language-html">&#x3C;!-- parent.hbs -->
{​{user-profile bar={​{123}} baz=(hash a=1 b='hi') class="hello"
data-fizz="ok"}}
</code></pre>
<p>In the above, <code>bar</code>, <code>baz</code>, <code>class</code> and <code>data-fizz</code> would all be treated as
<strong>arguments</strong> to the receiving component, so any <code>...attributes</code> in its template
would be a no-op. In Ember classic components, all of these arguments can be
accessed in the backing component class using either the argument name alone,
<code>&#x3C;argument name></code>, or using <code>this.&#x3C;argument name></code>, thus:</p>
<pre><code class="language-js">// user-profile.js
bar; // 123
this.bar; // 123
baz; // { a: 1, b: 'hi' }
this.baz; // { a: 1, b: 'hi' }
this.class; // 'hello'
this["data-fizz"]; // 'ok'
</code></pre>
<p>Usage in the template is:</p>
<pre><code class="language-html">&#x3C;!-- user-profile.hbs -->
{​{bar}}&#x3C;br />
{​{this.bar}}&#x3C;br />
{​{baz}}&#x3C;br />
{​{this.baz}}&#x3C;br />
{​{this.class}}&#x3C;br />
{​{data-fizz}}&#x3C;br />
{​{this.data-fizz}}
</code></pre>
<p>results in the following output:</p>
<pre><code class="language-html">123&#x3C;br />
123&#x3C;br />
[Object]&#x3C;br />
[Object]&#x3C;br />
hello&#x3C;br />
ok&#x3C;br />
ok
</code></pre>
<p>It's important to note that both Ember classic and glimmer components can be
invoked by either syntax: classic curly or angle brackets—and what matters is
how the backing class is defined. Thus, if the above example was implemented as
a modern glimmer component, the backing class must access the argument <code>bar</code>
with <code>this.args.bar</code>. If the above example was implemented as a classic
component, the backing class must access the argument with either <code>bar</code> or
<code>this.bar</code>.</p>
<h2>So What's Missing?</h2>
<p>For those following closely, you may have noticed that this leaves us with some
kind of hole in the programming model, because there's no angle-bracket
equivalent for setting up a contextual component to pass in as an argument or
yield out as a block parameter. That's the topic under discussion at
<a href="https://github.com/emberjs/rfcs/issues/497">Ember RFC issue #497</a>.</p>
<p>In the meantime, <code>&#x3C;div class={​{@class}} local-class="whatever" ...attributes></code>
will ensure that a class applied to a component will pass through correctly
regardless of how it's being invoked.</p>
<aside>
  This article was adapted from a
  <a href="https://github.com/salsify/ui-localization/pull/44#pullrequestreview-340619675)" rel="external">PR comment</a>
  by <a href="https://dfreeman.io/" rel="external">Dan Freeman</a>.
  Thanks to
  <a href="https://twitter.com/jamscdavis" rel="external">James Davis</a>
  for proof reading this article.
</aside>
</div><footer class="license_copyright__KOT7N">This is licensed under a Creative Commons <!-- -->cc-by-nc-sa<!-- --> International License</footer></article></main><div class="layout_layout__Xf50c"><footer class="footer_footer__OT4Wn layout_layout__Xf50c"><p>© 2003-<!-- -->2023<!-- --> 0xADADA (unless otherwise noted.)<br/><a title="0xADADA" href="/">Home</a> <a href="/rss.xml">RSS</a> <span class="h-card"><a class="c-Meta u-email" rel="me" title="0xADADA" href="mailto:0xadada.pub@protonmail.com">Email</a> </span><a rel="me nofollow external noopener" title="0xADADA on Mastodon" href="https://freeradical.zone/@0xadada">Mastodon</a> <a rel="me nofollow external noopener" title="0xADADA on Twitter" href="https://twitter.com/0xadada">Twitter</a> <a rel="me nofollow external noopener" title="0xADADA on GitHub" href="https://github.com/0xadada">GitHub</a> <a rel="me nofollow external noopener" title="0xADADA on Goodreads" href="https://www.goodreads.com/review/list/60524683-0xadada?shelf=wanted">Goodreads</a> </p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slugs":{"year":"2020","month":"03","day":"20","slug":"ember-emplates-classic-vs-angle-bracket-syntaxes"},"title":"Ember Templates: Classic vs Angle Bracket Syntaxes","displayTitle":"Ember Templates: Classic vs Angle Bracket Syntaxes","metaDescription":"Diving into the difference between Ember component invocation when using curlies, angle brackets, and s-expression in Ember templates.","metaKeywords":"ember, web development","image":"/static/images/2020-03-20-ember-emplates-classic-vs-angle-bracket-syntaxes.png","metaImage":"/static/images/2020-03-20-ember-emplates-classic-vs-angle-bracket-syntaxes.png","date":1584720840000,"author":"0xADADA","content":"\u003cp\u003eThis articles describes the difference between how component invocation differs\nwhen using curlies \u003ccode\u003e{​{...}}\u003c/code\u003e, angle brackets \u003ccode\u003e\u0026#x3C;...\u003e\u003c/code\u003e or an \u003ccode\u003e(...)\u003c/code\u003e s-expression\nin Ember templates.\u003c/p\u003e\n\u003cp\u003eEmber has three methods for invoking components and helpers in a template,\neither of the three can be used to invoke both classic and modern glimmer\ncomponents.\u003c/p\u003e\n\u003cp\u003eThe \"classic\" syntax in the form that uses curly braces \u003ccode\u003e{​{...}}\u003c/code\u003e, e.g.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e{​{user-profile firstName=\"Dan\" lastName=\"F.\"}}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \"angle bracket\" syntax that uses a HTML-like form \u003ccode\u003e\u0026#x3C;... /\u003e\u003c/code\u003e, e.g.:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;UserProfile @firstName=\"Dan\" @lastName=\"F.\" /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFinally the s-expression (for sub-expression) form used inside curly and angle\nbracket syntax to invoke a sub component or helper. This takes the form\n\u003ccode\u003e(concat a \" \" b)\u003c/code\u003e, thus:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e{​{user-profile name=(concat firstName \" \" lastName)}}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;UserProfile @classNames={​{concat \"sticky \" (if this.isActive \"is-active\")}} /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eAngle Brackets\u003c/h2\u003e\n\u003cp\u003eSimilar to the vanilla DOM APIs that distinguish between\n\u003ca href=\"https://joji.me/en-us/blog/html-attribute-vs-dom-property/\"\u003eJS properties from HTML attributes\u003c/a\u003e,\nangle bracket component invocations have two different namespaces you're\noperating against.\u003c/p\u003e\n\u003cp\u003eYou are probably most familiar with HTML attributes, which tell the browser how\nto draw an HTML element. These attributes can do things like defining the \u003ccode\u003ealt\u003c/code\u003e\ntext on an image \u003ccode\u003e\u0026#x3C;img alt=\"A bird\"\u003e\u003c/code\u003e or the URL on an anchor tag\n\u003ccode\u003e\u0026#x3C;a href=\"https://example.com\"\u003e\u003c/code\u003e. Angle bracket syntax implements attributes in\na similar way, allowing the developer to apply these attributes to a DOM node\nsomewhere in the component's template.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;!-- parent.hbs --\u003e\n\u0026#x3C;UserProfile class=\"abc\" @tagName=\"figure\" /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e...attributes\u003c/code\u003e syntax determines where the attributes passed into a\ncomponent from an angle bracket invocation should appear in the component's\ntemplate. Any number of attributes\n\u003ca href=\"https://github.com/emberjs/rfcs/blob/master/text/0435-modifier-splattributes.md\"\u003eand element modifiers\u003c/a\u003e\ncan be specified on the user profile component now, and they will all be applied\nto the element that has \u003ccode\u003e...attributes\u003c/code\u003e on it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;!-- UserProfile.hbs --\u003e\n\u0026#x3C;figure\u003e\n  \u0026#x3C;img ...attributes src=\"default.jpg\" /\u003e\n\u0026#x3C;/figure\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethe resulting HTML output is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;figure\u003e\n  \u0026#x3C;img class=\"abc\" src=\"default.jpg\" /\u003e\n\u0026#x3C;/figure\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnything prefixed with \u003ccode\u003e@\u003c/code\u003e is an \"argument\", is passed to the component by its\ncaller, is accessible to the class backing the component, and can be any JS\nruntime value. Unlike attributes, which tell the browser what to render,\narguments tell your custom Ember component tag what to do.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;!-- parent.hbs --\u003e\n\u0026#x3C;UserProfile @name=\"Dan F.\" /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis template invokes the \u003ccode\u003e\u0026#x3C;UserProfile\u003e\u003c/code\u003e component, which expects one argument:\n\u003ccode\u003e@name\u003c/code\u003e, the value we pass is the hardcoded string \"Dan F.\".\u003c/p\u003e\n\u003cp\u003eIn the backing component class, arguments are namespaced on the \u003ccode\u003ethis.args\u003c/code\u003e\nobject, which is immutable. You can access this argument as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// user-profile.js\nthis.args.name; // \"Dan F.\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo illustrate the differences, here is an invocation of an angle bracket\ncomponent using both arguments and attributes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;Foo\n  @bar={​{123}}\n  @baz={​{hash a=\"1\" b=\"hi\"}}\n  class=\"hello\"\n  data-fizz=\"ok\"\n/\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the above, \u003ccode\u003ebar\u003c/code\u003e and \u003ccode\u003ebaz\u003c/code\u003e would be arguments with the values \u003ccode\u003e123\u003c/code\u003e and\n\u003ccode\u003e{ a: 1, b: 'hi' }\u003c/code\u003e respectively, while \u003ccode\u003eclass\u003c/code\u003e and \u003ccode\u003edata-fizz\u003c/code\u003e would be\nattributes that could be applied to a DOM node somewhere in the component's\ntemplate.\u003c/p\u003e\n\u003ch2\u003eCurly and s-expression Syntax\u003c/h2\u003e\n\u003cp\u003eEmber curly (also called \"classic\") component invocation only have one\nnamespace: the argument, everything is treated as an argument, as if you\nimplicitly included \u003ccode\u003e@\u003c/code\u003e in front of each one. Historically, this was compensated\nfor by automatically applying the value of the \u003ccode\u003eclass\u003c/code\u003e argument to the \u003ccode\u003eclass\u003c/code\u003e\n\u003cem\u003eattribute\u003c/em\u003e of a component's root element (if it had one), and this behavior\ncould be extended to other attributes using the Ember classic\n\u003ccode\u003eattributeBindings\u003c/code\u003e API.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;!-- parent.hbs --\u003e\n{​{user-profile bar={​{123}} baz=(hash a=1 b='hi') class=\"hello\"\ndata-fizz=\"ok\"}}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the above, \u003ccode\u003ebar\u003c/code\u003e, \u003ccode\u003ebaz\u003c/code\u003e, \u003ccode\u003eclass\u003c/code\u003e and \u003ccode\u003edata-fizz\u003c/code\u003e would all be treated as\n\u003cstrong\u003earguments\u003c/strong\u003e to the receiving component, so any \u003ccode\u003e...attributes\u003c/code\u003e in its template\nwould be a no-op. In Ember classic components, all of these arguments can be\naccessed in the backing component class using either the argument name alone,\n\u003ccode\u003e\u0026#x3C;argument name\u003e\u003c/code\u003e, or using \u003ccode\u003ethis.\u0026#x3C;argument name\u003e\u003c/code\u003e, thus:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// user-profile.js\nbar; // 123\nthis.bar; // 123\nbaz; // { a: 1, b: 'hi' }\nthis.baz; // { a: 1, b: 'hi' }\nthis.class; // 'hello'\nthis[\"data-fizz\"]; // 'ok'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsage in the template is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026#x3C;!-- user-profile.hbs --\u003e\n{​{bar}}\u0026#x3C;br /\u003e\n{​{this.bar}}\u0026#x3C;br /\u003e\n{​{baz}}\u0026#x3C;br /\u003e\n{​{this.baz}}\u0026#x3C;br /\u003e\n{​{this.class}}\u0026#x3C;br /\u003e\n{​{data-fizz}}\u0026#x3C;br /\u003e\n{​{this.data-fizz}}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eresults in the following output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-html\"\u003e123\u0026#x3C;br /\u003e\n123\u0026#x3C;br /\u003e\n[Object]\u0026#x3C;br /\u003e\n[Object]\u0026#x3C;br /\u003e\nhello\u0026#x3C;br /\u003e\nok\u0026#x3C;br /\u003e\nok\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt's important to note that both Ember classic and glimmer components can be\ninvoked by either syntax: classic curly or angle brackets—and what matters is\nhow the backing class is defined. Thus, if the above example was implemented as\na modern glimmer component, the backing class must access the argument \u003ccode\u003ebar\u003c/code\u003e\nwith \u003ccode\u003ethis.args.bar\u003c/code\u003e. If the above example was implemented as a classic\ncomponent, the backing class must access the argument with either \u003ccode\u003ebar\u003c/code\u003e or\n\u003ccode\u003ethis.bar\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eSo What's Missing?\u003c/h2\u003e\n\u003cp\u003eFor those following closely, you may have noticed that this leaves us with some\nkind of hole in the programming model, because there's no angle-bracket\nequivalent for setting up a contextual component to pass in as an argument or\nyield out as a block parameter. That's the topic under discussion at\n\u003ca href=\"https://github.com/emberjs/rfcs/issues/497\"\u003eEmber RFC issue #497\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIn the meantime, \u003ccode\u003e\u0026#x3C;div class={​{@class}} local-class=\"whatever\" ...attributes\u003e\u003c/code\u003e\nwill ensure that a class applied to a component will pass through correctly\nregardless of how it's being invoked.\u003c/p\u003e\n\u003caside\u003e\n  This article was adapted from a\n  \u003ca href=\"https://github.com/salsify/ui-localization/pull/44#pullrequestreview-340619675)\" rel=\"external\"\u003ePR comment\u003c/a\u003e\n  by \u003ca href=\"https://dfreeman.io/\" rel=\"external\"\u003eDan Freeman\u003c/a\u003e.\n  Thanks to\n  \u003ca href=\"https://twitter.com/jamscdavis\" rel=\"external\"\u003eJames Davis\u003c/a\u003e\n  for proof reading this article.\n\u003c/aside\u003e\n","slug":"2020-03-20-ember-emplates-classic-vs-angle-bracket-syntaxes","license":"cc-by-nc-sa"}},"__N_SSG":true},"page":"/[year]/[month]/[day]/[slug]","query":{"year":"2020","month":"03","day":"20","slug":"ember-emplates-classic-vs-angle-bracket-syntaxes"},"buildId":"YhuQQcfgfqkyD_Ns_aB2N","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>