<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>One (more) Year with Ember: Thoughts on Ember vs React, Eight Years Later</title><meta property="og:site_name" content="0xADADA"/><meta property="og:title" content="One (more) Year with Ember: Thoughts on Ember vs React, Eight Years Later"/><meta name="twitter:title" content="One (more) Year with Ember: Thoughts on Ember vs React, Eight Years Later"/><link rel="canonical" href="https://0xadada.pub/2023/12/20/one-year-with-ember-vs-react-eight-years-later/"/><meta property="og:url" content="https://0xadada.pub/2023/12/20/one-year-with-ember-vs-react-eight-years-later/"/><meta name="twitter:url" content="https://0xadada.pub/2023/12/20/one-year-with-ember-vs-react-eight-years-later/"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@0xadada"/><meta name="author" content="0xADADA"/><meta property="og:type" content="article"/><meta name="description" content="An examination of the similarities of Ember &amp; React, some thoughts, and a conclusion."/><meta name="og:description" content="An examination of the similarities of Ember &amp; React, some thoughts, and a conclusion."/><meta name="twitter:description" content="An examination of the similarities of Ember &amp; React, some thoughts, and a conclusion."/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="https://0xadada.pub/favicon.ico"/><link rel="home" href="https://0xadada.pub/"/><link rel="alternate" type="application/rss+xml" href="https://0xadada.pub//rss.xml" title="0xADADA"/><link rel="manifest" href="https://0xadada.pub/static/images/meta/0xadada.webmanifest"/><link rel="apple-touch-icon" href="https://0xadada.pub/static/images/meta/apple-touch-icon.png"/><link rel="icon" type="image/png" href="https://0xadada.pub/static/images/meta/favicon-32x32.png" sizes="32x32"/><link rel="icon" type="image/png" href="https://0xadada.pub/static/images/meta/favicon-16x16.png" sizes="16x16"/><link rel="mask-icon" href="https://0xadada.pub/static/images/meta/safari-pinned-tab.svg" color="#5bbad5"/><meta name="theme-color" content="#FDF9F0"/><meta name="pocket-site-verification" content="7431f135e23a84de547e5b79dab406"/><meta name="next-head-count" content="26"/><link rel="preload" href="/_next/static/css/e943ecbdef35b944.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e943ecbdef35b944.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e491c5ad83d0116a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e491c5ad83d0116a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-22b044904a3f81e0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-929aade252cc0f2b.js" defer=""></script><script src="/_next/static/chunks/392-e44e3e95fe0288b1.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-0a1229f9e6020688.js" defer=""></script><script src="/_next/static/LbRWTZv19fB34iAyoJzM4/_buildManifest.js" defer=""></script><script src="/_next/static/LbRWTZv19fB34iAyoJzM4/_ssgManifest.js" defer=""></script><script src="/_next/static/LbRWTZv19fB34iAyoJzM4/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><main class="layout_layout__Xf50c"><article class="hentry h-entry" lang="en-US"><header><h1 class="entry-title p-name">One (more) Year with Ember: Thoughts on Ember vs React, Eight Years Later</h1><time class="byline_published__8ePA_ dt-published" dateTime="2023-12-20T15:04:00.000Z">Wednesday December 20, 2023</time><br/><span class="byline_byline__jNP6Q h-card">by: <span class="author fn p-author p-name">0xADADA</span></span></header><div class="entry-content e-content"><p>Six years ago, I <a href="https://0xadada.pub/2017/10/09/one-year-with-ember/">wrote a summary of my experience working with Ember for a year</a>.
I had been with Cinch Financial for a year, building their web &#x26; mobile apps with
Ember and Elixir/Phoenix. After Cinch I joined Salsify, a leader in the Ember
ecosystem, and shipped some great products built with Ember during my
five-year tenure. I built their Catalog Sites product using an Ember admin app
and a React/Next.js frontend. Building a single product with both frameworks was
enlightening as it provided a day-to-day experience with both.</p>
<blockquote>
<p>Almost a year of working in Ember, I'd like to summarize my thoughts about what
makes it a great framework. There are a million articles comparing the big JS
frameworks; this isn't one of those.</p>
</blockquote>
<p>Almost eight years of working in Ember, I'd like to revisit some of the things
I said about Ember. There are a million articles comparing the big JS
frameworks, this one is mine.</p>
<h2>Ember vs React</h2>
<p>React allows us to create <em>very declarative</em> code, but to do it idiomatically,
the way <em>React wants</em> takes quite a bit of experience and refinement to
<em>do it the right way</em>.
When examining purely declarative code, especially to the uninitiated, it can
be hard to comprehend when states are responding to events, and what their
downstream effects are. React code can be very composable, and their <code>useEffect</code>,
<code>useCallback</code>, <code>useState</code> primitives can be combined to create a wide variety
of functionality from these granular affordances.</p>
<p>With the composability of hooks, however, comes a level of complexity. We spend
a lot of time thinking through how different code is going to run, when it was
going to run, and how it could potentially interact with other hooks and code
around it. It all makes sense in the end, and it’s also declarative, but it’s
a bit harder to follow the intent all the way through.</p>
<p>React (for most of us) is usually only legible in motion, not at rest. This is
to say that the only way to figure out how a given piece of React code works is
by prodding it through use, it's not enough to just read it.</p>
<p><strong>Differences in developer feeling of focus</strong> Reacts dogmatic re-running of a
component when its state changes forces developers to consider <em>all</em> starting
and possible states, and their dependencies. It requires juggling a lot of
context on the part of the developer, and that is why <em>reducing state to the
minimum</em> is considered a best practice.
By contrast, Embers autotracking makes component development <em>feel</em> a lot
less complicated, and <strong>an Ember developer can focus more on intent while React
developer <em>feels</em> they must focus more on exactitude</strong>.
These are just feelings, but they’re there.</p>
<p><strong>Ember is more baroque</strong> with its <code>@action</code> and <code>@tracked</code> decorators,
its template control logic with <code>{{#if}} {{#each list of |item|}}</code> and
its native classes. With this baroque-ness however, comes an additional level
of legibility one gets from reading Ember code. Ember code feels familiar
everywhere, and separating arguments(props) from attributes really helped to
clarify intent.</p>
<p><em>Ember suffers from a small and shrinking ecosystem</em>. This could be due to
early technical decisions that required all 3rd-party Ember npm packages
to specifically adhere to Ember addon requirements. This meant that regular
npm packages couldn’t be used in Ember apps until <code>ember-auto-import</code> arrived,
and later, Embroider. Unfortunately this means most Ember addons aren’t
compatible with the wider javascript ecosystem, and many Ember packages
languish or are abandoned once maintainers move away from Ember. This means
the Ember core-team is burdened with adopting these orphaned packages or risk
losing them to the shifting sands of time.</p>
<h3>Direct Comparison</h3>
<p>When speaking to Ember devs about React, or React devs about Ember, I frequently
use this chart to map concepts in one to the other:</p>
<table>
<thead>
<tr>
<th align="left"><strong>Concept</strong></th>
<th align="left"><strong>Ember</strong></th>
<th align="left"><strong>React</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><strong>File structure</strong></td>
<td align="left">Convention<br /><code>app/components/component.js</code>, <code>app/components/template.hbs</code></td>
<td align="left">Configuration<br />use <code>import</code> to bring files from wherever, file may contain both logic and template.</td>
</tr>
<tr>
<td align="left"><strong>Component primative</strong></td>
<td align="left">JavaScript classes</td>
<td align="left">JavaScript functions</td>
</tr>
<tr>
<td align="left"><strong>Rendering</strong></td>
<td align="left">Glimmer VM</td>
<td align="left">React DOM</td>
</tr>
<tr>
<td align="left"><strong>State transition detection</strong></td>
<td align="left"><code>@tracked</code> decorator with autotracking provided by the framework</td>
<td align="left"><code>React.useState()</code> function with dependency keys and memoization</td>
</tr>
<tr>
<td align="left"><strong>Component lifecycle</strong></td>
<td align="left">Use the classes <code>constructor()</code> to initialize the component for first-render and reuses that instance for the life of the component.</td>
<td align="left">Components are pure functions, relies on memoization or <code>useEffect</code> to run code conditionally after initial render.</td>
</tr>
<tr>
<td align="left"><strong>Event handling</strong></td>
<td align="left"><code>@action</code> decorator to bind context to event callback functions that respond to user inputs, event handler must be referred to in templates using Ember modifiers e.g. <code>{{on 'click' (fn this.handleEvent value)}}</code> and use the <code>fn()</code> helper to bind arguments to the callback.</td>
<td align="left">Pure function callbacks that are lexically in-scope and bound using standard closure <code>onClick={() => handleEvent(value)}</code> style invocations.</td>
</tr>
<tr>
<td align="left"><strong>Template lexical scope</strong></td>
<td align="left">Double curly <code>{{this.value}}</code> which requires <code>this</code> to reference lexically scoped variables available in the class.</td>
<td align="left">Single curly interpolation <code>value={value}</code> which is directly bound to the functions lexical scope.</td>
</tr>
<tr>
<td align="left"><strong>Template interpolation</strong></td>
<td align="left">Sigils <code>@value={{this.value}}</code> to distinguish component arguments from standard HTML attributes. Ember requires using <code>...attributes</code> to spread HTML attributes to HTML tags. Use <code>{{yield}}</code> to render child components.</td>
<td align="left">No difference between component props and HTML attributes.</td>
</tr>
<tr>
<td align="left"><strong>Template Control Logic</strong></td>
<td align="left">handlebars/HTMLbars<br />iteration<br /><code>{{#each @list as item}}&#x3C;Item />{{/each}}</code><br />conditionals<br /><code>{{#if true}}its true{{else}}not true{{/if}}</code></td>
<td align="left">pure javascript<br />iteration<br /><code>lilst.map(item => &#x3C;Item />)</code><br />conditionals<br /><code>{item.isTrue ? &#x3C;TrueItem /> : &#x3C;FalseItem />}</code></td>
</tr>
<tr>
<td align="left"><strong>Global State Management</strong></td>
<td align="left">Ember Services</td>
<td align="left">React Context API</td>
</tr>
<tr>
<td align="left"><strong>Application Routing</strong></td>
<td align="left">Ember Router</td>
<td align="left">React-Router (not built-in)</td>
</tr>
</tbody>
</table>
<h2>Eight Years On</h2>
<p>Revisiting <a href="https://0xadada.pub/2017/10/09/one-year-with-ember/">my original post</a>,
I'd like to provide some updates to that thinking:</p>
<blockquote>
<p>Ember feels familiar…</p>
</blockquote>
<p>Ember still feels familiar, <em>especially</em> for teams that work across many Ember
repos. <strong>Ember teams are very productive because of Embers
convention-over-configuration approach</strong>.
An Ember app is an Ember app is an Ember app. <strong>This familiarity isn’t always
typical with React apps</strong>. React apps are to-each-their-own, and teams need to
spend time to make their apps feel familiar enough to be seamless when moving
between repos.</p>
<blockquote>
<p>There is a single "Ember way" of doing things…</p>
</blockquote>
<p>This isn’t as true as it used to be. Ember is wonderfully backwards compatible,
but that also puts it into an awkward position when it comes to writing
idiomatic Ember applications: It has become very difficult to discern
<em>what is idiomatic Ember</em>, especially in real-world app ecosystems where you
may have apps using Ember (classic) or Ember Octane, or an in-between state.
Ongoing projects like template imports will make Ember apps even more difficult
to determine what is "idiomatic".</p>
<p>At Salsify, there are a handful of Ember-gurus who shepherd the engineering org
towards idiomatic Ember, but the average engineer doesn't necessarily know when:</p>
<ul>
<li><code>Ember.get/set</code> vs. native getters/setters</li>
<li><code>Component.extend({})</code> vs <code>class Component extends Component {}</code></li>
<li>invoke component with <code>{{my-component}}</code> or <code>&#x3C;MyComponent /></code></li>
<li>render a value with <code>{{value}}</code> or <code>{{this.value}}</code> or <code>{{@value}}</code></li>
<li>when to use <code>@tracked</code> or <code>@action</code></li>
</ul>
<p>The <a href="https://ember-learn.github.io/ember-octane-vs-classic-cheat-sheet/">Ember cheat sheet</a>
is a great resource, but its there because people aren’t confidant. Tools like
<code>eslint</code>, <code>prettier</code>, <code>stylelint</code> and others help migrating to idiomatic
conventions.</p>
<h2>Concluding</h2>
<p>Ember and React are both great. There are tradeoffs on both sides. The answer
is always <em>it depends</em>. Ember is an amazing upleveler for bigger teams with
novice and expert developers working across multiple codebases building
ambitious applications. React is elegant in its simplicity, can be pure and
precise. React has an amazing ecosystem, and is used to create enterprise
applications. Ember has a larger API surface area, and while it seems to
have a higher learning curve, I’d argue that it takes longer for an engineer
to become an expert at React: <em>one having the ability to see the forest
for the trees.</em></p>
</div><footer class="license_copyright__KOT7N">This is licensed under a Creative Commons <!-- -->cc-by-nc-sa<!-- --> International License</footer></article></main><div class="layout_layout__Xf50c"><footer class="footer_footer__OT4Wn layout_layout__Xf50c"><p>© 2003-<!-- -->2023<!-- --> 0xADADA (unless otherwise noted.)<br/><a title="0xADADA" href="/">Home</a> <a href="/rss.xml">RSS</a> <span class="h-card"><a class="c-Meta u-email" rel="me" title="0xADADA" href="mailto:0xadada.pub@protonmail.com">Email</a> </span><a rel="me nofollow external noopener" title="0xADADA on Mastodon" href="https://freeradical.zone/@0xadada">Mastodon</a> <a rel="me nofollow external noopener" title="0xADADA on Twitter" href="https://twitter.com/0xadada">Twitter</a> <a rel="me nofollow external noopener" title="0xADADA on GitHub" href="https://github.com/0xadada">GitHub</a> <a rel="me nofollow external noopener" title="0xADADA on Goodreads" href="https://www.goodreads.com/review/list/60524683-0xadada?shelf=wanted">Goodreads</a> </p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slugs":{"year":"2023","month":"12","day":"20","slug":"one-year-with-ember-vs-react-eight-years-later"},"title":"One (more) Year with Ember: Thoughts on Ember vs React, Eight Years Later","displayTitle":"One (more) Year with Ember: Thoughts on Ember vs React, Eight Years Later","metaDescription":"An examination of the similarities of Ember \u0026 React, some thoughts, and a conclusion.","metaKeywords":"ember, react, web development, javascript, frameworks","date":1703084640000,"author":"0xADADA","content":"\u003cp\u003eSix years ago, I \u003ca href=\"https://0xadada.pub/2017/10/09/one-year-with-ember/\"\u003ewrote a summary of my experience working with Ember for a year\u003c/a\u003e.\nI had been with Cinch Financial for a year, building their web \u0026#x26; mobile apps with\nEmber and Elixir/Phoenix. After Cinch I joined Salsify, a leader in the Ember\necosystem, and shipped some great products built with Ember during my\nfive-year tenure. I built their Catalog Sites product using an Ember admin app\nand a React/Next.js frontend. Building a single product with both frameworks was\nenlightening as it provided a day-to-day experience with both.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAlmost a year of working in Ember, I'd like to summarize my thoughts about what\nmakes it a great framework. There are a million articles comparing the big JS\nframeworks; this isn't one of those.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAlmost eight years of working in Ember, I'd like to revisit some of the things\nI said about Ember. There are a million articles comparing the big JS\nframeworks, this one is mine.\u003c/p\u003e\n\u003ch2\u003eEmber vs React\u003c/h2\u003e\n\u003cp\u003eReact allows us to create \u003cem\u003every declarative\u003c/em\u003e code, but to do it idiomatically,\nthe way \u003cem\u003eReact wants\u003c/em\u003e takes quite a bit of experience and refinement to\n\u003cem\u003edo it the right way\u003c/em\u003e.\nWhen examining purely declarative code, especially to the uninitiated, it can\nbe hard to comprehend when states are responding to events, and what their\ndownstream effects are. React code can be very composable, and their \u003ccode\u003euseEffect\u003c/code\u003e,\n\u003ccode\u003euseCallback\u003c/code\u003e, \u003ccode\u003euseState\u003c/code\u003e primitives can be combined to create a wide variety\nof functionality from these granular affordances.\u003c/p\u003e\n\u003cp\u003eWith the composability of hooks, however, comes a level of complexity. We spend\na lot of time thinking through how different code is going to run, when it was\ngoing to run, and how it could potentially interact with other hooks and code\naround it. It all makes sense in the end, and it’s also declarative, but it’s\na bit harder to follow the intent all the way through.\u003c/p\u003e\n\u003cp\u003eReact (for most of us) is usually only legible in motion, not at rest. This is\nto say that the only way to figure out how a given piece of React code works is\nby prodding it through use, it's not enough to just read it.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDifferences in developer feeling of focus\u003c/strong\u003e Reacts dogmatic re-running of a\ncomponent when its state changes forces developers to consider \u003cem\u003eall\u003c/em\u003e starting\nand possible states, and their dependencies. It requires juggling a lot of\ncontext on the part of the developer, and that is why \u003cem\u003ereducing state to the\nminimum\u003c/em\u003e is considered a best practice.\nBy contrast, Embers autotracking makes component development \u003cem\u003efeel\u003c/em\u003e a lot\nless complicated, and \u003cstrong\u003ean Ember developer can focus more on intent while React\ndeveloper \u003cem\u003efeels\u003c/em\u003e they must focus more on exactitude\u003c/strong\u003e.\nThese are just feelings, but they’re there.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eEmber is more baroque\u003c/strong\u003e with its \u003ccode\u003e@action\u003c/code\u003e and \u003ccode\u003e@tracked\u003c/code\u003e decorators,\nits template control logic with \u003ccode\u003e{{#if}} {{#each list of |item|}}\u003c/code\u003e and\nits native classes. With this baroque-ness however, comes an additional level\nof legibility one gets from reading Ember code. Ember code feels familiar\neverywhere, and separating arguments(props) from attributes really helped to\nclarify intent.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eEmber suffers from a small and shrinking ecosystem\u003c/em\u003e. This could be due to\nearly technical decisions that required all 3rd-party Ember npm packages\nto specifically adhere to Ember addon requirements. This meant that regular\nnpm packages couldn’t be used in Ember apps until \u003ccode\u003eember-auto-import\u003c/code\u003e arrived,\nand later, Embroider. Unfortunately this means most Ember addons aren’t\ncompatible with the wider javascript ecosystem, and many Ember packages\nlanguish or are abandoned once maintainers move away from Ember. This means\nthe Ember core-team is burdened with adopting these orphaned packages or risk\nlosing them to the shifting sands of time.\u003c/p\u003e\n\u003ch3\u003eDirect Comparison\u003c/h3\u003e\n\u003cp\u003eWhen speaking to Ember devs about React, or React devs about Ember, I frequently\nuse this chart to map concepts in one to the other:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"left\"\u003e\u003cstrong\u003eConcept\u003c/strong\u003e\u003c/th\u003e\n\u003cth align=\"left\"\u003e\u003cstrong\u003eEmber\u003c/strong\u003e\u003c/th\u003e\n\u003cth align=\"left\"\u003e\u003cstrong\u003eReact\u003c/strong\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eFile structure\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eConvention\u003cbr /\u003e\u003ccode\u003eapp/components/component.js\u003c/code\u003e, \u003ccode\u003eapp/components/template.hbs\u003c/code\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eConfiguration\u003cbr /\u003euse \u003ccode\u003eimport\u003c/code\u003e to bring files from wherever, file may contain both logic and template.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eComponent primative\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eJavaScript classes\u003c/td\u003e\n\u003ctd align=\"left\"\u003eJavaScript functions\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eRendering\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eGlimmer VM\u003c/td\u003e\n\u003ctd align=\"left\"\u003eReact DOM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eState transition detection\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e\u003ccode\u003e@tracked\u003c/code\u003e decorator with autotracking provided by the framework\u003c/td\u003e\n\u003ctd align=\"left\"\u003e\u003ccode\u003eReact.useState()\u003c/code\u003e function with dependency keys and memoization\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eComponent lifecycle\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eUse the classes \u003ccode\u003econstructor()\u003c/code\u003e to initialize the component for first-render and reuses that instance for the life of the component.\u003c/td\u003e\n\u003ctd align=\"left\"\u003eComponents are pure functions, relies on memoization or \u003ccode\u003euseEffect\u003c/code\u003e to run code conditionally after initial render.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eEvent handling\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e\u003ccode\u003e@action\u003c/code\u003e decorator to bind context to event callback functions that respond to user inputs, event handler must be referred to in templates using Ember modifiers e.g. \u003ccode\u003e{{on 'click' (fn this.handleEvent value)}}\u003c/code\u003e and use the \u003ccode\u003efn()\u003c/code\u003e helper to bind arguments to the callback.\u003c/td\u003e\n\u003ctd align=\"left\"\u003ePure function callbacks that are lexically in-scope and bound using standard closure \u003ccode\u003eonClick={() =\u003e handleEvent(value)}\u003c/code\u003e style invocations.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eTemplate lexical scope\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eDouble curly \u003ccode\u003e{{this.value}}\u003c/code\u003e which requires \u003ccode\u003ethis\u003c/code\u003e to reference lexically scoped variables available in the class.\u003c/td\u003e\n\u003ctd align=\"left\"\u003eSingle curly interpolation \u003ccode\u003evalue={value}\u003c/code\u003e which is directly bound to the functions lexical scope.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eTemplate interpolation\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eSigils \u003ccode\u003e@value={{this.value}}\u003c/code\u003e to distinguish component arguments from standard HTML attributes. Ember requires using \u003ccode\u003e...attributes\u003c/code\u003e to spread HTML attributes to HTML tags. Use \u003ccode\u003e{{yield}}\u003c/code\u003e to render child components.\u003c/td\u003e\n\u003ctd align=\"left\"\u003eNo difference between component props and HTML attributes.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eTemplate Control Logic\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003ehandlebars/HTMLbars\u003cbr /\u003eiteration\u003cbr /\u003e\u003ccode\u003e{{#each @list as item}}\u0026#x3C;Item /\u003e{{/each}}\u003c/code\u003e\u003cbr /\u003econditionals\u003cbr /\u003e\u003ccode\u003e{{#if true}}its true{{else}}not true{{/if}}\u003c/code\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003epure javascript\u003cbr /\u003eiteration\u003cbr /\u003e\u003ccode\u003elilst.map(item =\u003e \u0026#x3C;Item /\u003e)\u003c/code\u003e\u003cbr /\u003econditionals\u003cbr /\u003e\u003ccode\u003e{item.isTrue ? \u0026#x3C;TrueItem /\u003e : \u0026#x3C;FalseItem /\u003e}\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eGlobal State Management\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eEmber Services\u003c/td\u003e\n\u003ctd align=\"left\"\u003eReact Context API\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eApplication Routing\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eEmber Router\u003c/td\u003e\n\u003ctd align=\"left\"\u003eReact-Router (not built-in)\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2\u003eEight Years On\u003c/h2\u003e\n\u003cp\u003eRevisiting \u003ca href=\"https://0xadada.pub/2017/10/09/one-year-with-ember/\"\u003emy original post\u003c/a\u003e,\nI'd like to provide some updates to that thinking:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eEmber feels familiar…\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eEmber still feels familiar, \u003cem\u003eespecially\u003c/em\u003e for teams that work across many Ember\nrepos. \u003cstrong\u003eEmber teams are very productive because of Embers\nconvention-over-configuration approach\u003c/strong\u003e.\nAn Ember app is an Ember app is an Ember app. \u003cstrong\u003eThis familiarity isn’t always\ntypical with React apps\u003c/strong\u003e. React apps are to-each-their-own, and teams need to\nspend time to make their apps feel familiar enough to be seamless when moving\nbetween repos.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThere is a single \"Ember way\" of doing things…\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis isn’t as true as it used to be. Ember is wonderfully backwards compatible,\nbut that also puts it into an awkward position when it comes to writing\nidiomatic Ember applications: It has become very difficult to discern\n\u003cem\u003ewhat is idiomatic Ember\u003c/em\u003e, especially in real-world app ecosystems where you\nmay have apps using Ember (classic) or Ember Octane, or an in-between state.\nOngoing projects like template imports will make Ember apps even more difficult\nto determine what is \"idiomatic\".\u003c/p\u003e\n\u003cp\u003eAt Salsify, there are a handful of Ember-gurus who shepherd the engineering org\ntowards idiomatic Ember, but the average engineer doesn't necessarily know when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eEmber.get/set\u003c/code\u003e vs. native getters/setters\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eComponent.extend({})\u003c/code\u003e vs \u003ccode\u003eclass Component extends Component {}\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003einvoke component with \u003ccode\u003e{{my-component}}\u003c/code\u003e or \u003ccode\u003e\u0026#x3C;MyComponent /\u003e\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003erender a value with \u003ccode\u003e{{value}}\u003c/code\u003e or \u003ccode\u003e{{this.value}}\u003c/code\u003e or \u003ccode\u003e{{@value}}\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ewhen to use \u003ccode\u003e@tracked\u003c/code\u003e or \u003ccode\u003e@action\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe \u003ca href=\"https://ember-learn.github.io/ember-octane-vs-classic-cheat-sheet/\"\u003eEmber cheat sheet\u003c/a\u003e\nis a great resource, but its there because people aren’t confidant. Tools like\n\u003ccode\u003eeslint\u003c/code\u003e, \u003ccode\u003eprettier\u003c/code\u003e, \u003ccode\u003estylelint\u003c/code\u003e and others help migrating to idiomatic\nconventions.\u003c/p\u003e\n\u003ch2\u003eConcluding\u003c/h2\u003e\n\u003cp\u003eEmber and React are both great. There are tradeoffs on both sides. The answer\nis always \u003cem\u003eit depends\u003c/em\u003e. Ember is an amazing upleveler for bigger teams with\nnovice and expert developers working across multiple codebases building\nambitious applications. React is elegant in its simplicity, can be pure and\nprecise. React has an amazing ecosystem, and is used to create enterprise\napplications. Ember has a larger API surface area, and while it seems to\nhave a higher learning curve, I’d argue that it takes longer for an engineer\nto become an expert at React: \u003cem\u003eone having the ability to see the forest\nfor the trees.\u003c/em\u003e\u003c/p\u003e\n","slug":"2023-12-20-one-year-with-ember-vs-react-eight-years-later","license":"cc-by-nc-sa"}},"__N_SSG":true},"page":"/[year]/[month]/[day]/[slug]","query":{"year":"2023","month":"12","day":"20","slug":"one-year-with-ember-vs-react-eight-years-later"},"buildId":"LbRWTZv19fB34iAyoJzM4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>