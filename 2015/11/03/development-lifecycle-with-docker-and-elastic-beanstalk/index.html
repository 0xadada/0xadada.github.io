<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Development Lifecycle with Docker and Elastic Beanstalk</title><meta property="og:site_name" content="0xADADA"/><meta property="og:title" content="Development Lifecycle with Docker and Elastic Beanstalk"/><meta name="twitter:title" content="Development Lifecycle with Docker and Elastic Beanstalk"/><link rel="canonical" href="https://0xadada.pub/2015/11/03/development-lifecycle-with-docker-and-elastic-beanstalk/"/><meta property="og:url" content="https://0xadada.pub/2015/11/03/development-lifecycle-with-docker-and-elastic-beanstalk/"/><meta name="twitter:url" content="https://0xadada.pub/2015/11/03/development-lifecycle-with-docker-and-elastic-beanstalk/"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@0xadada"/><meta name="author" content="0xADADA"/><meta property="og:type" content="article"/><meta name="description" content="This article explains the advantages of using Docker over automated configuration management tools, and describes a workflow from development through QA and into production deployment using Amazons&#x27; Elastic Beanstalk."/><meta name="twitter:description" content="This article explains the advantages of using Docker over automated configuration management tools, and describes a workflow from development through QA and into production deployment using Amazons&#x27; Elastic Beanstalk."/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="shortcut icon" href="https://0xadada.pub/favicon.ico"/><link rel="home" href="https://0xadada.pub/"/><link rel="manifest" href="https://0xadada.pub/static/images/meta/0xadada.webmanifest"/><link rel="apple-touch-icon" href="https://0xadada.pub/static/images/meta/apple-touch-icon.png"/><link rel="icon" type="image/png" href="https://0xadada.pub/static/images/meta/favicon-32x32.png" sizes="32x32"/><link rel="icon" type="image/png" href="https://0xadada.pub/static/images/meta/favicon-16x16.png" sizes="16x16"/><link rel="mask-icon" href="https://0xadada.pub/static/images/meta/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-config" content="https://0xadada.pub/static/images/meta/browserconfig.xml"/><meta name="theme-color" content="#FDF9F0"/><meta name="pocket-site-verification" content="7431f135e23a84de547e5b79dab406"/><meta name="next-head-count" content="25"/><link rel="preload" href="/_next/static/css/1a73e1553db871e1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1a73e1553db871e1.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e491c5ad83d0116a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e491c5ad83d0116a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-22b044904a3f81e0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-929aade252cc0f2b.js" defer=""></script><script src="/_next/static/chunks/929-712c4c3eb0b6b9a9.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-3e33ba64b77a13fe.js" defer=""></script><script src="/_next/static/U8wg1OrnAOssRMsMczpXl/_buildManifest.js" defer=""></script><script src="/_next/static/U8wg1OrnAOssRMsMczpXl/_ssgManifest.js" defer=""></script><script src="/_next/static/U8wg1OrnAOssRMsMczpXl/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><main class="layout_layout__Xf50c"><article class="hentry h-entry" lang="en-US"><header><h1 class="entry-title p-name">Development Lifecycle with Docker and Elastic Beanstalk</h1><time class="byline_published__8ePA_ dt-published" dateTime="2015-11-03T07:55:00.000Z">Tuesday November 3, 2015</time><br/><span class="byline_byline__jNP6Q h-card">by: <span class="author fn p-author p-name">0xADADA</span></span></header><div class="entry-content e-content"><p>Docker is getting a lot of hype these days, for good reason. There are plenty of
articles touting the merits of Docker but most are written without context and
are limited to examining the the benefits of Docker independently of its'
practical everyday use in a software development project lifecycle.</p>
<p>This article aims to examine the benefits of Docker within the context of a
software company with multiple developers working on multiple projects, having
to manage these projects deployed in a cloud production environment. In this
context the benefits of Docker become more readily apparent.</p>
<p>With the rise of cloud computing, the number of systems that need to be
maintained has exploded. Manual <em><a href="#provisioning">provisioning</a></em> of an
increasingly large number of systems becomes impossible for a small team, given
platforms like Amazon EC2 provide <em><a href="#autoscaling">auto-scaling</a></em> when additional
load is detected.</p>
<p>Tools like Ansible, Chef, Puppet and Salt are great solutions towards achieving
automated provisioning of virtual machines. The industry has responded by
quickly adopting these tools, but even more agility and performance can be
achieved by using <em><a href="#docker-container">Docker containers</a></em>.</p>
<p>Combining Docker with a deployment tool like AWS Elastic Beanstalk can provide
even greater efficiencies for developing and deploying cloud applications.</p>
<h2>Dockdj</h2>
<p><img src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a2.png" alt="Dockdj"></p>
<p>This article will be using <a href="https://github.com/0xadada/dockdj">Dockdj</a> to
illustrate using Docker and Elastic Beanstalk in the context of a real-world web
project. Dockdj is a recipe for building 12-factor Python / Django web apps with
multi-container Docker and deploying to Amazon AWS using Elastic Beanstalk.
<a href="https://github.com/0xadada/dockdj">Dockdj is available on GitHub</a>.</p>
<h3>Manual Provisioning</h3>
<p>The naive approach is <em>manual provisioning</em>: the developer installs Apache and
associated system libraries directly on the local development machine, configure
it according to the WordPress documentation.</p>
<p>These manual steps will need to be repeated for every additional member of the
development team, and again for the production web server. When provisioned
software is updated or configurations change. All members of the development
team and the production systems need to be updated accordingly. Larger teams
inevitably begin experiencing the <em>"works on my machine"</em> problems between
developers when some developers haven't updated their configurations to match
coworkers who have.</p>
<p>Manual provisioning quickly becomes a frequent and resource-intensive process,
with the side-effect of prolonging the deployment of important vendor bug fixes
and security patches across both development and productions systems.</p>
<p>Additionally, when increased traffic hits productions systems, new systems need
to be allocated and scaled horizontally to support the new traffic. All the
provisioning needs to repeated. This system doesn't scale as more production
servers are added to serve additional traffic load.</p>
<p>Even worse is when differences between developer-systems and production-systems
result in hard-to-reproduce bugs once the app is deployed from development into
production.</p>
<h3>Automated Provisioning</h3>
<p>An improvement over manual provisioning is <em>automated provisioning</em> using a
<em><a href="#confg-mgmt">configuration management</a></em> tool like Ansible, Chef, Puppet, Salt,
etc. These tools have been developed to address the problems of provisioning at
large scale.</p>
<p>The aim of these tools are:</p>
<ol>
<li>Initialize and start virtual machines</li>
<li>Automate the provisioning process in a repeatable way</li>
<li>Manage changes to provisioning in a version control system</li>
<li>Establishing and maintaining consistency of system dependencies and
configuration throughout an applications life</li>
</ol>
<p>Configuration management tools are wonderful for automated provisioning, but <em>in
practice</em><sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref aria-describedby="footnote-label">1</a></sup> they tend to
split management of the stack-app into two parts:</p>
<ol>
<li>the software Stack</li>
</ol>
<ul>
<li>Operating system</li>
<li>System libraries</li>
<li>Provisioned software</li>
<li>Configuration</li>
</ul>
<ol>
<li>the Application</li>
</ol>
<ul>
<li>Source code &#x26; binaries</li>
<li>Dependencies</li>
<li>Runtime environment</li>
</ul>
<p>The result is that the stack (#1) is initially allocated and provisioned using
one of the configuration management tools. The application (#2) is then deployed
on the stack— resulting in a running application. When subsequent
application versions (#2) are released and deployed, they are deployed onto the
(unchanged) stack. <strong>The problem with this model is that the stack and the
application are managed independently.</strong> Changes to the stack are managed as a
unit separate from changes to the application. No data is recorded that
describes the compatibility of the integrated whole.</p>
<p>This results in increased complexity during rollbacks or simultaneous updates to
both stack and application. More importantly <strong>version numbers of the
application are not tied to versions of the stack.</strong></p>
<p>Under this model, the stack version and application version aren't
coupled— which increases the likelihood of integration failures.</p>
<p>An example will illustrate where this model will fail:</p>
<blockquote>
<p>Our production web server is provisioned with Apache 3.3.0 and the application
(WordPress) was at version 0.7.0 last week, and have just released version
0.8.0 this past week.</p>
<p>Apache announces a security vulnerability fix at version 3.3.1. Under the
(typical) automated provisioning model, the configuration management tool
would be updated to provision the new version of Apache. The tool runs against
all production server systems. Here the application doesn't change, it simply
rides on top of the Apache stack without change. No problems occur with the
rollout of the new Apache release.</p>
<p>Next the application updates and releases a new version for deployment- 0.9.0.
The deploy process runs, and for some reason the application fails, it isn't
compatible with version 3.3.1 of Apache.</p>
<p>The decision is made to rollback the application to 0.8.0, which runs
successfully with Apache 3.3.1. The system is working again.</p>
<p>A critical security vulnerability is discovered in application 0.8.0 and the
decision is made to roll application back to version 0.7.0. (Keep in mind the
previous app version 0.7.0 was running Apache 3.3.0, and the stack is
currently 3.3.1).</p>
<p>The application fails— because 0.7.0 was never integration tested
against Apache 3.3.1. What do you do?</p>
</blockquote>
<p>In this example the devops team <strong>failed to remember</strong> to rollback Apache,
simply because the integrated dependencies were not internally coupled. The
compatible coupling existed <strong>only as institutional knowledge</strong> outside the
scope of the configuration management system, as Stack and Application were
managed separately.</p>
<h2>Docker for Configuration Management</h2>
<p>One major advantage of Docker is that it does not necessitate running a unique
VM<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref aria-describedby="footnote-label">2</a></sup> for every project a team works on.
If developers work on multiple projects, each with its own customized VM,
switching between projects becomes a time-consuming context shift for
developers.</p>
<p>Docker containers run directly on the Linux operating system and yet each
container is isolated. This eliminates the slowness of booting and the overhead
of a VM. Docker containers start up as quickly as running a normal process, and
eliminate VM "booting" for every Docker project the developer works on.
Deploying changes to the environment for every developer working on the project
is as easy as publishing a new <em><a href="#docker-image">Docker image</a></em>. Next time a
developer starts the container, he/she will get the new image.</p>
<p>Another advantage of Docker over an automated configuration management tool is
that it <strong>does not</strong> bifurcate the stack and the application into independent
segments.</p>
<p>A stack using Docker containers has the same benefit of configuration
management, but can couple the stack and the application into a single managed
component. The application is deployed along with its stack— and the
complete stack-app component is deployed together as a single Docker image or a
bundle of Docker images that have already been integration tested at least on a
developers machine.</p>
<p>As opposed the the "automated provisioning" model, the Docker model of the
stack-app looks more like this:</p>
<ol>
<li>Set of Docker images</li>
</ol>
<ul>
<li>Operating system (the software Stack)</li>
<li>Provisioned software (the software Stack)</li>
<li>Configuration (the software Stack)</li>
<li>System libraries (the software Stack)</li>
<li>Source code &#x26; binaries (Application)</li>
<li>Dependencies (Application)</li>
<li>Runtime environment (Application)</li>
</ul>
<p>With every deployment, the entire stack-app (1) will be deployed. Docker uses
hashes (like Git) to minimize the amount of data that will be downloaded for any
update. This means only the differences are downloaded rather than the entire
stack.</p>
<p><strong>The greatest advantage of using Docker is that developers can run the
application in the very same environment as production</strong>. According to
<a href="http://12factor.net/dev-prod-parity">Twelve-Factor Methodology</a> this is called
achieving "Dev/Prod Parity". This is a huge benefit in that it eliminates an
entire class of bugs that result from differences between
developers-and-developers as well as bugs that result from differences between
developers-and-production.</p>
<h2>Elastic Beanstalk for Deployment</h2>
<p>If you know <a href="https://www.heroku.com/">Heroku</a>, than Amazons' Elastic Beanstalk
will be extremely familiar. EB borrows many ideas from Heroku, but the killer
feature is its' ability to dynamically run, deploy and scale Docker containers
on a cluster of servers. It handles hardware allocation, network configuration,
load balancing, auto-scaling, health monitoring and rolling deployments.</p>
<p>EB doesn't do everything, but it's good enough to adopt early and use until your
team understands its deployment use-cases more clearly and understands
limitations of EB and its trade-offs.</p>
<h2>Django specific structure</h2>
<p>The core structure of the Docker / Elastic Beanstalk app can be explained by
describing the directory structure.</p>
<p>These comments describe the application-specific file structure:</p>
<pre><code>.dockerignore
.ebextensions/
  01_envvars.config
.ebignore
.elasticbeanstalk/
Dockerrun.aws.json
.gitignore               # Describes which files git ignores
.bowerrc                 # Configures where web frontend dependencies live
.csslintrc.json          # Describes CSS syntax rules
.jshintrc                # Describes JavaScript syntax rules
bower.json               # Describes web frontend dependencies
gulpfile.js              # Describes app build and dev tasks
package.json             # Describes NPM dependencies
app/                     # Our python app
  apps/*                 # python app modules
  project/*              # App-specific settings
  dist/*                 # App static assets (served via Nginx)
bin/*
docker/
  django/
    dev/
      docker-compose.yml
      Dockerfile
    prod/
      docker-compose.yml
      Dockerfile
      gunicorn.conf.py   # Settings for production app-server
    start.sh             # Script to start app-server
  nginx/*                # Nginx config files
environments/            # Environment-specific settings
  dev/                   # Development-only environment settings
    .env                 # Actual environment vars (Excluded from git)
    .env.example         # Example environment vars
    Procfile             # Configures how Honcho starts app-servers
    requirements.txt     # Describes dev Python dependencies
  prod/                  # Development-only environment settings
    .env                 # Actual environment vars (Excluded from git)
    .env.example         # Example environment vars
    Procfile             # Configures how Honcho starts app-servers
    requirements.txt     # Describes prod Python dependencies
</code></pre>
<p>Some of these directories and files are described in more depth below:</p>
<h3>.gitignore</h3>
<pre><code>environments/*/.env
node_modules
.elasticbeanstalk/*
!.elasticbeanstalk/*.cfg.yml
!.elasticbeanstalk/*.global.yml
# Built testing and static asset artifacts
app/dist
</code></pre>
<p>Files matching the name <code>environments/*/.env</code> contain sensitive information
(usernames, passwords, etc) about per-deployment environments that shouldn't be
included in version control.</p>
<p>The <code>node_modules</code> directory and will be created when the developer installs NPM
packages. These are dependencies and should not be committed into the source
code repository.</p>
<p>The <code>.elasticbeanstalk/*</code> directory is excluded from Git because it contains
files that are generated by EB command-line during environment creation and
version deployment that shouldn't be written to the repository. It also contains
temporary configuration files (written by the EB cli).</p>
<p>Both <code>!.elasticbeanstalk/*.cfg.yml</code> and <code>!.elasticbeanstalk/*.global.yml</code>
entries use the "NOT" operator to re- include themselves into the repo. These
files can be useful to have in version control, as they contain useful
environment configuration settings.</p>
<h3>bower.json</h3>
<p>Bower is a web frontend package management system. The application declares its
frontend dependencies in this file.</p>
<p>During docker image creation, these dependencies are installed.</p>
<h3>gulpfile.js</h3>
<p>Gulp.js is a task runner for Node.js. <code>gulpfile.js</code> defines common tasks and
utilities related to this application:</p>
<ul>
<li>Running code Syntax checking &#x26; automated testing</li>
<li>SASS and CSS compilation and minification</li>
<li>Frontend asset building</li>
</ul>
<h3>package.json</h3>
<p>NPM is a package management system for Node.js applications. <code>package.json</code> The
application declares its Node.js dependencies in this file.</p>
<h3>app/</h3>
<p>The <code>app/</code> directory contains all source code related to the Django python web
application.</p>
<h3>docker/django/prod/gunicorn.conf.py</h3>
<p>This project uses two application servers, <code>runserver_plus</code> during development
and <code>gunicorn</code> in production.</p>
<p>These are settings related to the Gunicorn application server. In production, a
more performant application is used, requiring this configuration file.</p>
<h3>docker/nginx/sites-enabled.conf</h3>
<p>On production systems, where nginx acts as a reverse-proxy for the Gunicorn web
application, we use Docker links to connect the two containers together. This
configuration is best for reducing latency. Inside our nginx config file, we can
use a named entry for the <code>proxy_pass</code> value to reference our Django application
server running in another container on port 8080.</p>
<pre><code># ...
location / {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect   off;
    proxy_pass       http://django:8080;
    # ...
</code></pre>
<h3>docker/django/start.sh</h3>
<pre><code>cd /var/app
# ...
honcho --procfile "environments/$ENV_NAME/Procfile" \
       --env "environments/$ENV_NAME/.env" start
</code></pre>
<p><code>start.sh</code> is used during both development and production as a single task to
bootstrap the application server. It uses the <code>honcho</code> task runner to start the
server according to a set of tasks in a <code>Procfile</code> for development and another
for production.</p>
<p>The <code>--env</code> parameter is used to pass environment variables sourced from the
environments subdirectory. At runtime, the <code>$ENV_NAME</code> variable will be set:
<code>dev</code> for development and <code>prod</code> for production. This way a separate Procfile
and separate set of environment variables are available to configure the modes
independently.</p>
<h3>environments/dev/Procfile</h3>
<pre><code># The webserver: Python
webserver: cd app &#x26;&#x26; ./manage.py runserver_plus 0.0.0.0:8080
# The CDN assets emulation server
cdnserver: cd /var/app/app/dist &#x26;&#x26; python -m http.server 8010
</code></pre>
<p>During development, the Django <code>runserver_plus</code> application server interprets
Python, while a simple HTTP server serves assets (images, CSS, etc).</p>
<h3>environments/prod/Procfile</h3>
<pre><code class="language-bash">webserver: cd app &#x26;&#x26; gunicorn \
  -c /etc/gunicorn/gunicorn.conf.py project.wsgi:application
</code></pre>
<p>In production, we use Gunicorn to serve the python application, so the only task
run is the gunicorn app server. Static assets aren't handled here because Nginx
will be reverse-proxying the application and also serving static assets.</p>
<p>This decision was made because Nginx is optimized to serve static assets and it
will reduce load on the application server.</p>
<h3>environments/[dev | prod]/.env.example</h3>
<p>Both <code>environments/dev/.env.example</code> and <code>environments/prod/.env.example</code> are
committed into git to provide hints to developers that they should create a
<code>.env</code> file in the same directory as a place to store environment variables that
are passed into the application.</p>
<p>The <code>.env</code> file is excluded from the git repository as it contains sensitive
usernames passwords and cryptographic information.</p>
<h3>environments/[dev | prod]/requirements.txt</h3>
<p>The python utility <code>pip</code> is a package management utility. It uses a file named
<code>requirements.txt</code> to install all package dependencies. The development
environment adds some useful debugging utilities that shouldn't be included on
production systems, so production has its own file.</p>
<p>During docker image creation, these dependencies are installed.</p>
<h2>Docker specific structure</h2>
<pre><code>.dockerignore            # Describes which files Docker ignores
.ebextensions/
  01_envvars.config
.ebignore
.elasticbeanstalk/
Dockerrun.aws.json
.gitignore
.bowerrc
.csslintrc.json
.jshintrc
bower.json
gulpfile.js
package.json
app/
  apps/*
  project/*
  dist/*
bin/*                    # Scripts for Docker, build and deployment
docker/                  # Configuration files required by docker
  django/                # Django related settings
    dev/                 # Development-only settings
      docker-compose.yml # Orchestrates dev containers
      Dockerfile         # Builds dev Docker image
    prod/                # Production-only settings
      docker-compose.yml # Orchestrates prod containers
      Dockerfile         # Builds prod Docker image
      gunicorn.conf.py
    start.sh
  nginx/*
environments/
  dev/
    .env
    .env.example
    Procfile
    requirements.txt
  prod/
    .env
    .env.example
    Procfile
    requirements.txt
</code></pre>
<h3>.dockerignore</h3>
<p>The <code>.dockerignore</code> file specifies a list of patterns to exclude from the build
context during creation of the Docker image. These files are not required by the
execution of the container, and should be removed to reduce the size of the
final image.</p>
<pre><code>.coverage
.ebextensions/*
.elasticbeanstalk/*
.ebignore
.dockerignore
.git
.gitignore
.DS_Store
node_modules
app/dist
docs
htmlcov
README.md
ghostdriver.log
</code></pre>
<p>Some notable entries are described below:</p>
<p>The <code>node_modules</code> directory and will be created when the developer installs NPM
packages. If the developer is using on OS X, packages compiled on OS X will not
work when the container is running in the Linux VM, so this entry ensures that
node modules are installed on the host OS independently from the container OS.</p>
<p><code>.ebextensions/*</code>, <code>.elasticbeanstalk/*</code> and <code>.ebignore</code> are required by the
Elastic Beanstalk deploy process, and are outside the scope of execution of the
Docker container, and are not required.</p>
<p>The <code>app/dist</code> directory contains frontend assets served by both Django and
Nginx, and are required by both Django and Nginx containers. Because Amazon ECS
cannot (currently) directly mount a single volume from one container into
another container, we need these files to be deployed directly on the host OS.
Docker can mount the directory on both Django and Nginx containers as a shared
volume. This directory will be deployed by EB, and is thus excluded from Docker.</p>
<h3>bin/image</h3>
<p><code>bin/image</code> is a shell script that wraps common Docker commands used to create
Docker images. There are three major subcommands: <code>build</code>, <code>destroy</code> and
<code>update</code> all take a single argument, the name of the environment subdirectory of
the <code>environments/</code> directory. This will spawn Docker and build, delete or
rebuild the image as specified by the <code>Dockerfile</code> in the directory
corresponding to the final argument.</p>
<h3>bin/stevedore</h3>
<p><code>bin/stevedore</code> is a shell script that wraps common Docker commands used to
start and stop Docker containers. There are many subcommands, but the most
useful are: <code>start</code>, <code>stop</code> and either of the two <code>build</code> commands. All
subcommands take take a single argument, the name of the environment
subdirectory of the <code>environments/</code> directory. This will spawn Docker and start,
stop or run the corresponding build process.</p>
<h3>docker/django/dev/docker-compose.yml</h3>
<p>This file provides configuration for Docker to orchestrate the management of the
development Docker container for the local dev environment.</p>
<pre><code>django:
  build: ../../..
  dockerfile: docker/django/dev/Dockerfile
  env_file: ../../../environments/dev/.env
  volumes:
    - "../../../app/apps:/var/app/app/apps"
    - "../../../app/dist:/var/app/app/dist"
    - "../../../app/project:/var/app/app/project"
    - "../../../app/manage.py:/var/app/app/manage.py"
    - "../../../environments:/var/app/environments"
    - "../../../gulpfile.js:/var/app/gulpfile.js"
  ports:
    - "80:8080"
    - "8010:8010"
</code></pre>
<p>It defines one container "django", specifying a path to the <code>build</code>-context as
well as a path to load the <code>Dockerfile</code>. <code>env_file</code> specifies the path the a
file containing all environment variables. A set of volumes to share from the
host OS to the container are listed in <code>volumes</code>. Finally <code>ports</code> tells Docker
which ports on the host to map to the container.</p>
<h3>docker/django/dev/Dockerfile</h3>
<p>The <code>Dockerfile</code> is a set of instructions for Docker to execute in order to
produce a Docker image— a file used to create a Docker container running
your application code.</p>
<pre><code class="language-bash"># ...
# Install apt, Python then NodeJS dependencies.
RUN             apt-get update &#x26;&#x26; \
                curl -sL https://deb.nodesource.com/setup_0.12 | bash - &#x26;&#x26; \
                apt-get install -y nodejs &#x26;&#x26; \
                pip install --upgrade pip &#x26;&#x26; \
                pip install -r \
                    environments/dev/requirements.txt &#x26;&#x26; \
                npm update &#x26;&#x26; \
                npm install -g gulp &#x26;&#x26; \
                npm install &#x26;&#x26; \
                gulp
# Add our initialization script to the image and run it upon startup.
ADD             docker/django/start.sh /
CMD             ["/start.sh"]
</code></pre>
<p>In the development Dockerfile, <code>pip</code> and <code>npm</code> commands install the necessary
dependencies from the <code>environments/dev</code> folder. Finally <code>start.sh</code> is called to
start the Django application server.</p>
<h3>docker/django/prod/docker-compose.yml</h3>
<p>This file provides configuration for Docker to orchestrate the management of the
production Docker containers. This configuration can be used for testing locally
prior to deployment to Amazon AWS.</p>
<pre><code class="language-yml">django:
  build: ../../..
  dockerfile: docker/django/prod/Dockerfile
  env_file: ../../../environments/prod/.env
  volumes:
    - "../../../docker/django/prod/gunicorn.conf.py:/etc/gunicorn/gunicorn.conf.py:ro"
    - "/var/app/app/dist"

nginx:
  image: nginx
  links:
    - django
  volumes:
    - "../../../docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro"
    - "../../../docker/nginx/sites-enabled.conf:/etc/nginx/conf.d/default.conf:ro"
  volumes_from:
    - django
  ports:
    - "80:80"
</code></pre>
<p>It defines two containers "django" and "nginx". "Django" is configured quite
similar to the development setup, but doesn't map as many volumes from the host
OS to the container. In this configuration "django" doesn't need to expose a
port externally, as the "nginx" container will expose port 80 externally.</p>
<p>Importantly, the "nginx" container uses <code>links</code> to connect the "django"
container to "nginx". This way nginx config files can refer to "django" as-if it
was another host on the same network with the name "nginx".</p>
<p>Finally, the "nginx" container will mount all volumes from the "django"
container with the <code>volumes_from</code> directive, and expose port 80 to the host OS.</p>
<h3>docker/django/prod/Dockerfile</h3>
<p>The major difference between the development <code>Dockerfile</code> and the production
version is:</p>
<ul>
<li>It exposes port 8080 for other containers</li>
<li>It runs <code>gulp build</code> during image creation</li>
</ul>
<p>This Dockerfile also installs production-only Python pip dependencies in
requirements.txt.</p>
<pre><code class="language-bash"># Install apt, Python then NodeJS dependencies.
RUN             apt-get update &#x26;&#x26; \
                curl -sL https://deb.nodesource.com/setup_0.12 | bash - &#x26;&#x26; \
                apt-get install -y nodejs &#x26;&#x26; \
                pip install --upgrade pip &#x26;&#x26; \
                pip install -r \
                    environments/prod/requirements.txt &#x26;&#x26; \
                npm update &#x26;&#x26; \
                npm install -g gulp &#x26;&#x26; \
                npm install &#x26;&#x26; \
                gulp build
# Exposes port 8080
EXPOSE          8080
</code></pre>
<p>When Docker runs the image build, it runs <code>gulp build</code>, which runs code-quality,
unit tests and produces production-ready web frontend assets. This allows for
testing prior to deployment, and gives the team an opportunity to fix errors
before they go into the wild.</p>
<h2>Elastic Beanstalk specific structure</h2>
<p>Finally, these comments describe files related to Amazons' Elastic Beanstalk:</p>
<pre><code>.dockerignore
.ebextensions/           # Describes how EB builds environments
  01_envvars.config      # Describes env vars for AWS Docker containers
.ebignore                # Describes how Amazon EB ignores some files
.elasticbeanstalk/       # Location Amazon EB stores its cli settings
Dockerrun.aws.json       # Describes how to run our containers in AWS
.gitignore
.bowerrc
.csslintrc.json
.jshintrc
bower.json
gulpfile.js
package.json
app/
  apps/*
  project/*
  dist/*
bin/*
docker/
  django/
    dev/
      docker-compose.yml
      Dockerfile
    prod/
      docker-compose.yml
      Dockerfile
      gunicorn.conf.py
    start.sh
  nginx/*
environments/
  dev/
    .env
    .env.example
    Procfile
    requirements.txt
  prod/
    .env
    .env.example
    Procfile
    requirements.txt
</code></pre>
<h3>.ebextensions/01_envvars.config</h3>
<p>This file is used by the Elastic Beanstalk command line utilities to pass
key-value parameters to Amazon EC2 and ECS. This file is used to store all
production environment variables that are provided to running containers. This
variables often vary between deployments.</p>
<h3>.ebignore</h3>
<p>When Elastic Beanstalk does a deployment, it creates a zip file of the current
directory, uploads it to Amazon S3, and deploys the files to running EC2
instances. Since this project is using Docker images to package the app, we can
ignore most files; with the exception of the <code>app/dist</code> directory— which
both "Django" and "Nginx" containers will need access too.</p>
<p>The <code>.ebignore</code> file is used to ignore certain files in a project directory.
This file works like a <code>.gitignore</code> file.</p>
<pre><code># Ignore everything!
*
# Except for these exclusion patterns required by Amazon ECS
!Dockerrun.aws.json
!.ebextensions/*.config
!.elasticbeanstalk/*.cfg.yml
!.elasticbeanstalk/*.global.yml
!app/dist/**
!docker/**
</code></pre>
<p>The only files our EB package should contain are those required by Docker,
Elastic Beanstalk itself, or any files shared between both containers (such as
the <code>app/dist</code> directory).</p>
<p>When you deploy your project directory to Elastic Beanstalk and create a new
application version, the EB CLI will not include files specified by the
<code>.ebignore</code> in the source bundle that it creates. This is useful for creating
smaller packages by excluding files that aren't required for running
production-only code.</p>
<h3>.elasticbeanstalk/</h3>
<p>Elastic Beanstalk uses this directory to store temp files and configuration
information about the current AWS account, EB Application name and IAM
credentials to utilize.</p>
<h3>Dockerrun.aws.json</h3>
<p><code>Dockerrun.aws.json</code> is a proprietary Amazon-specific JSON format called a
"<a href="#task-def">Task Definition</a>" used to configure how to manage Docker containers
running on Amazon EC2 Container Service (ECS) platform.</p>
<pre><code class="language-json">"containerDefinitions": [
{
    "name": "django",
    "image": "0xadada/dockdj:latest",
    "essential": true,
    "memory": 512,
    "mountPoints": [
        {
            "sourceVolume": "gunicorn-conf",
            "containerPath": "/etc/gunicorn/gunicorn.conf.py",
            "readOnly": true
        }
    ]
}
</code></pre>
<p>The JSON format is very similar to the docker-compose Yaml format, having a
nearly 1-to-1 mapping of <code>image</code>, <code>mountPoints</code> to volumes and ports all
defined.</p>
<p>This file is functionally identical to <code>docker/prod/docker-compose.yml</code> in that
it runs, configures and connects the "Django" and "Nginx" Docker containers. As
such, changes to the <code>docker-compose.yml</code> file should be mirrored in the
<code>Dockerrun.aws.json</code> file.</p>
<h2>Lifecycle</h2>
<p>New developers to this project simply clone the project from GitHub, install
Docker (and boot2docker/docker-machine on OS X) and can begin running the app.
There is no need to setup a developer environment or create (yet) another VM.</p>
<h3>Development</h3>
<p>When the developer starts working on the project from scratch, the only
requirement is Docker and a machine capable of running Docker containers (Linux
3+ or boot2docker/docker-machine).</p>
<p>Once an organization or developer has adopted Docker for a single project,
startup time for other docker projects is drastically reduced as this core
requirement has already been met. From that point forward, the projects
themselves can define and provision their own dependencies.</p>
<p>For this project, the next steps required of the developer are as follows:</p>
<pre><code class="language-bash">git clone &#x3C;PROJECT>
&#x3C;create .env file>
.bin/stevedore dev start
</code></pre>
<p>The developer is now running the app. Any internal OS configuration, system
libraries, software dependencies and provisioning are all handled by the project
and Docker— transparently to the developer.</p>
<p>Subsequent context-switches between other projects and this project have been
reduced to a single command:</p>
<pre><code class="language-bash">.bin/stevedore dev start
</code></pre>
<p>The developer doesn't need to boot up a VM, nor does she/he need to understand
or start any internal processes or run any commands internal to the VM.</p>
<p><strong>In development, Docker can be used to lower cognitive load on developers
switching between multiple projects.</strong></p>
<h3>QA</h3>
<p>In this particular project, QA tests are run during build of the the production
Docker image via the <code>gulp build</code> task. See
<a href="#dockerdjangoproddockerfile">the production Dockerfile</a> to view how it calls
the gulp task.</p>
<p>In effect, this will prevent developers or continuous Integration systems from
publishing a production Docker image to Docker Hub, as the build will trigger a
Docker image build failure.</p>
<p>More generally, development teams could create different tags for "production"
releases and "development" Docker image releases. Lets say "prod" vs "dev".</p>
<p>Development teams could publish images tagged with "dev", to Docker Hub. Other
developers on the team or members of the QA team could <code>docker pull</code> that tagged
image and run their suite of tests on it.</p>
<p>Using Docker in this manner, dev and QA teams no longer have to keep VM
configurations synchronized, as the OS and other dependencies have been pushed
down from VM directly into dependencies within the scope of the project. <strong>This
has the effect of reducing manual synchronization and de-necessitating
out-of-channel communication between development and QA teams about the state of
the runtime environment.</strong> This allows for faster, less-error-prone iteration of
the runtime environment.</p>
<h3>Production</h3>
<p>Developers have iterated on functionality, QA has run tests against the code,
and the projects is ready for deployment to production.</p>
<p>At this point, a working Docker image has been run on developers local machines,
and QA has passed. These three phases could've gone through multiple iterations
while bugs were identified and fixed. The end result is a working Docker image
exists that has been deemed "ready" for production.</p>
<p>Either manually or as part of a continuous integration tool, the
production-ready Docker image can now be tagged with a release version and
published to Docker Hub (or other compatible Docker image repository). Finally,
the deploy process needs to update the production servers running our working
application stack and run the latest application code.</p>
<p>These tasks are handled by our <code>bin/deploy</code> script, a wrapper for Docker, Git
and Elastic Beanstalk. It will tag the latest Docker image, publish the tag to
Docker Hub, tag the publish the tags to GitHub and use Elastic Beanstalk to
deploy both the latest stack and application code:</p>
<p>(Lets use 1.2.3 as an arbitrary version number for this example)</p>
<pre><code class="language-bash">bin/deploy release 1.2.3 # Create a release branch and tag the image
bin/deploy publish 1.2.3 # Publish the Docker image and git branch
                         # to Docker Hub and GitHub
bin/deploy deploy 1.2.3  # Use EB to deploy the latest release
</code></pre>
<p>The deploy script is a light bash wrapper that automates Git, Docker and Elastic
Beanstalk commands in an easy-to-reproduce set of short commands.</p>
<p>Once complete, the Amazon environment will be running your latest application
code, as well as any new changes to the container OS, system libraries and
dependencies. Most importantly, <strong>any changes in provisioning to the stack have
been deployed along with the Docker image</strong>, thus enabling seamless roll-backs.
<strong>Rolling back the application version will also rollback the stack version</strong>.
The application and stack are deployed together.</p>
<p>Happy cloud computing!</p>
<h2>Terms</h2>
<ul>
<li>
<p><a name="autoscaling"><em>Auto-scaling</em></a> A method of setting a threshold that
detects when the load on a server cluster necessitates adding or removing
servers in order to optimize the number of servers servicing that load.
Auto-scaling allows an organization to decrease operating costs by running the
minimum number of servers required to service its load, and eliminating the
need to accurately predict future traffic patterns.</p>
</li>
<li>
<p><a name="config-mgmt"><em>Configuration Management</em></a> Software tools that are
designed to automatically start, provision and configure software on virtual
machines rather than have engineers run these steps manually on each server.
These tools can be used both locally to create development VMs (virtual
machines) as well as in the cloud to create staging and production VMs.</p>
</li>
<li>
<p><a name="docker-image"><em>Docker image</em></a> A docker image is like an executable
program binary. It takes source files and other assets and bundles them
together, and the resulting bundle can be run/executed as a single process on
a Linux machine.</p>
</li>
<li>
<p><a name="docker-container"><em>Docker container</em></a> A docker container is like a
running executable program. It is a running instance of a docker image. Like a
running program, it has a PID, and it is appropriate to call it a process. It
can be started and stopped. One docker image can be run many times on one or
more machines.</p>
</li>
<li>
<p><a name="provisioning"><em>Provisioning</em></a> The installation and configuration
of software needed to run an application. E.g. Installing and configuring
Apache and its system libraries in order to run WordPress.</p>
</li>
<li>
<p><a name="task-def"><em>Task definition</em></a> A proprietary JSON format for
describing how Docker containers are run within the Amazon EC2 Cloud Service.
Read more about
<a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html">Amazon ECS Task Definitions</a>.
Docker uses the <a href="https://docs.docker.com/compose/yml/">docker-compose Yaml</a>
file to do the same thing.</p>
</li>
</ul>
<section data-footnotes class="footnotes"><h2 id="footnote-label" class="sr-only">Footnotes</h2>
<ol>
<li id="user-content-fn-1">
<p>Configuration management tools can be used to couple both Stack and
Application, but experience has has shown that over time, these tools
are not strongly opinionated, and therefore Stack-App decoupling occurs
organically over the lifetime of a project. <a href="#user-content-fnref-1" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-2">
<p>Docker runs on  Linux version 3. In the case where the developer is
using OS X, Windows or another non-Linux OS, they'll need to run a Linux
VM in order to use Docker. However, this single VM will be able to run
all Docker containers for all Docker projects they use. Tools like
Docker Machine make working with the Docker VM much simpler. <a href="#user-content-fnref-2" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
</ol>
</section>
</div><footer class="license_copyright__KOT7N">This is licensed under a Creative Commons <!-- -->cc-by-nc-sa<!-- --> International License</footer></article></main><div class="layout_layout__Xf50c"><footer class="footer_footer__OT4Wn layout_layout__Xf50c"><p>© 2003-<!-- -->2022<!-- --> 0xADADA (unless otherwise noted.)<br/><a title="0xADADA" href="/">Home</a> <span class="h-card"><a class="c-Meta u-email" rel="me" title="0xADADA" href="mailto:0xadada.pub@protonmail.com">Email</a> </span><a rel="me nofollow external noopener" title="0xADADA on Twitter" href="https://twitter.com/0xadada">Twitter</a> <a rel="me nofollow external noopener" title="0xADADA on GitHub" href="https://github.com/0xadada">GitHub</a> <a rel="me nofollow external noopener" title="0xADADA on Goodreads" href="https://www.goodreads.com/review/list/60524683-0xadada?shelf=wanted">Goodreads</a> </p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slugs":{"year":"2015","month":"11","day":"03","slug":"development-lifecycle-with-docker-and-elastic-beanstalk"},"title":"Development Lifecycle with Docker and Elastic Beanstalk","displayTitle":"Development Lifecycle with Docker and Elastic Beanstalk","metaDescription":"This article explains the advantages of using Docker over automated configuration management tools, and describes a workflow from development through QA and into production deployment using Amazons' Elastic Beanstalk.","metaKeywords":"docker, elastic beanstalk, amazon aws, python, django, development, lifecycle, engineering, workflow","date":1446537300000,"author":"0xADADA","content":"\u003cp\u003eDocker is getting a lot of hype these days, for good reason. There are plenty of\narticles touting the merits of Docker but most are written without context and\nare limited to examining the the benefits of Docker independently of its'\npractical everyday use in a software development project lifecycle.\u003c/p\u003e\n\u003cp\u003eThis article aims to examine the benefits of Docker within the context of a\nsoftware company with multiple developers working on multiple projects, having\nto manage these projects deployed in a cloud production environment. In this\ncontext the benefits of Docker become more readily apparent.\u003c/p\u003e\n\u003cp\u003eWith the rise of cloud computing, the number of systems that need to be\nmaintained has exploded. Manual \u003cem\u003e\u003ca href=\"#provisioning\"\u003eprovisioning\u003c/a\u003e\u003c/em\u003e of an\nincreasingly large number of systems becomes impossible for a small team, given\nplatforms like Amazon EC2 provide \u003cem\u003e\u003ca href=\"#autoscaling\"\u003eauto-scaling\u003c/a\u003e\u003c/em\u003e when additional\nload is detected.\u003c/p\u003e\n\u003cp\u003eTools like Ansible, Chef, Puppet and Salt are great solutions towards achieving\nautomated provisioning of virtual machines. The industry has responded by\nquickly adopting these tools, but even more agility and performance can be\nachieved by using \u003cem\u003e\u003ca href=\"#docker-container\"\u003eDocker containers\u003c/a\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eCombining Docker with a deployment tool like AWS Elastic Beanstalk can provide\neven greater efficiencies for developing and deploying cloud applications.\u003c/p\u003e\n\u003ch2\u003eDockdj\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a2.png\" alt=\"Dockdj\"\u003e\u003c/p\u003e\n\u003cp\u003eThis article will be using \u003ca href=\"https://github.com/0xadada/dockdj\"\u003eDockdj\u003c/a\u003e to\nillustrate using Docker and Elastic Beanstalk in the context of a real-world web\nproject. Dockdj is a recipe for building 12-factor Python / Django web apps with\nmulti-container Docker and deploying to Amazon AWS using Elastic Beanstalk.\n\u003ca href=\"https://github.com/0xadada/dockdj\"\u003eDockdj is available on GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eManual Provisioning\u003c/h3\u003e\n\u003cp\u003eThe naive approach is \u003cem\u003emanual provisioning\u003c/em\u003e: the developer installs Apache and\nassociated system libraries directly on the local development machine, configure\nit according to the WordPress documentation.\u003c/p\u003e\n\u003cp\u003eThese manual steps will need to be repeated for every additional member of the\ndevelopment team, and again for the production web server. When provisioned\nsoftware is updated or configurations change. All members of the development\nteam and the production systems need to be updated accordingly. Larger teams\ninevitably begin experiencing the \u003cem\u003e\"works on my machine\"\u003c/em\u003e problems between\ndevelopers when some developers haven't updated their configurations to match\ncoworkers who have.\u003c/p\u003e\n\u003cp\u003eManual provisioning quickly becomes a frequent and resource-intensive process,\nwith the side-effect of prolonging the deployment of important vendor bug fixes\nand security patches across both development and productions systems.\u003c/p\u003e\n\u003cp\u003eAdditionally, when increased traffic hits productions systems, new systems need\nto be allocated and scaled horizontally to support the new traffic. All the\nprovisioning needs to repeated. This system doesn't scale as more production\nservers are added to serve additional traffic load.\u003c/p\u003e\n\u003cp\u003eEven worse is when differences between developer-systems and production-systems\nresult in hard-to-reproduce bugs once the app is deployed from development into\nproduction.\u003c/p\u003e\n\u003ch3\u003eAutomated Provisioning\u003c/h3\u003e\n\u003cp\u003eAn improvement over manual provisioning is \u003cem\u003eautomated provisioning\u003c/em\u003e using a\n\u003cem\u003e\u003ca href=\"#confg-mgmt\"\u003econfiguration management\u003c/a\u003e\u003c/em\u003e tool like Ansible, Chef, Puppet, Salt,\netc. These tools have been developed to address the problems of provisioning at\nlarge scale.\u003c/p\u003e\n\u003cp\u003eThe aim of these tools are:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eInitialize and start virtual machines\u003c/li\u003e\n\u003cli\u003eAutomate the provisioning process in a repeatable way\u003c/li\u003e\n\u003cli\u003eManage changes to provisioning in a version control system\u003c/li\u003e\n\u003cli\u003eEstablishing and maintaining consistency of system dependencies and\nconfiguration throughout an applications life\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eConfiguration management tools are wonderful for automated provisioning, but \u003cem\u003ein\npractice\u003c/em\u003e\u003csup\u003e\u003ca href=\"#user-content-fn-1\" id=\"user-content-fnref-1\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e1\u003c/a\u003e\u003c/sup\u003e they tend to\nsplit management of the stack-app into two parts:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ethe software Stack\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eOperating system\u003c/li\u003e\n\u003cli\u003eSystem libraries\u003c/li\u003e\n\u003cli\u003eProvisioned software\u003c/li\u003e\n\u003cli\u003eConfiguration\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003ethe Application\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eSource code \u0026#x26; binaries\u003c/li\u003e\n\u003cli\u003eDependencies\u003c/li\u003e\n\u003cli\u003eRuntime environment\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe result is that the stack (#1) is initially allocated and provisioned using\none of the configuration management tools. The application (#2) is then deployed\non the stack— resulting in a running application. When subsequent\napplication versions (#2) are released and deployed, they are deployed onto the\n(unchanged) stack. \u003cstrong\u003eThe problem with this model is that the stack and the\napplication are managed independently.\u003c/strong\u003e Changes to the stack are managed as a\nunit separate from changes to the application. No data is recorded that\ndescribes the compatibility of the integrated whole.\u003c/p\u003e\n\u003cp\u003eThis results in increased complexity during rollbacks or simultaneous updates to\nboth stack and application. More importantly \u003cstrong\u003eversion numbers of the\napplication are not tied to versions of the stack.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eUnder this model, the stack version and application version aren't\ncoupled— which increases the likelihood of integration failures.\u003c/p\u003e\n\u003cp\u003eAn example will illustrate where this model will fail:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eOur production web server is provisioned with Apache 3.3.0 and the application\n(WordPress) was at version 0.7.0 last week, and have just released version\n0.8.0 this past week.\u003c/p\u003e\n\u003cp\u003eApache announces a security vulnerability fix at version 3.3.1. Under the\n(typical) automated provisioning model, the configuration management tool\nwould be updated to provision the new version of Apache. The tool runs against\nall production server systems. Here the application doesn't change, it simply\nrides on top of the Apache stack without change. No problems occur with the\nrollout of the new Apache release.\u003c/p\u003e\n\u003cp\u003eNext the application updates and releases a new version for deployment- 0.9.0.\nThe deploy process runs, and for some reason the application fails, it isn't\ncompatible with version 3.3.1 of Apache.\u003c/p\u003e\n\u003cp\u003eThe decision is made to rollback the application to 0.8.0, which runs\nsuccessfully with Apache 3.3.1. The system is working again.\u003c/p\u003e\n\u003cp\u003eA critical security vulnerability is discovered in application 0.8.0 and the\ndecision is made to roll application back to version 0.7.0. (Keep in mind the\nprevious app version 0.7.0 was running Apache 3.3.0, and the stack is\ncurrently 3.3.1).\u003c/p\u003e\n\u003cp\u003eThe application fails— because 0.7.0 was never integration tested\nagainst Apache 3.3.1. What do you do?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn this example the devops team \u003cstrong\u003efailed to remember\u003c/strong\u003e to rollback Apache,\nsimply because the integrated dependencies were not internally coupled. The\ncompatible coupling existed \u003cstrong\u003eonly as institutional knowledge\u003c/strong\u003e outside the\nscope of the configuration management system, as Stack and Application were\nmanaged separately.\u003c/p\u003e\n\u003ch2\u003eDocker for Configuration Management\u003c/h2\u003e\n\u003cp\u003eOne major advantage of Docker is that it does not necessitate running a unique\nVM\u003csup\u003e\u003ca href=\"#user-content-fn-2\" id=\"user-content-fnref-2\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e2\u003c/a\u003e\u003c/sup\u003e for every project a team works on.\nIf developers work on multiple projects, each with its own customized VM,\nswitching between projects becomes a time-consuming context shift for\ndevelopers.\u003c/p\u003e\n\u003cp\u003eDocker containers run directly on the Linux operating system and yet each\ncontainer is isolated. This eliminates the slowness of booting and the overhead\nof a VM. Docker containers start up as quickly as running a normal process, and\neliminate VM \"booting\" for every Docker project the developer works on.\nDeploying changes to the environment for every developer working on the project\nis as easy as publishing a new \u003cem\u003e\u003ca href=\"#docker-image\"\u003eDocker image\u003c/a\u003e\u003c/em\u003e. Next time a\ndeveloper starts the container, he/she will get the new image.\u003c/p\u003e\n\u003cp\u003eAnother advantage of Docker over an automated configuration management tool is\nthat it \u003cstrong\u003edoes not\u003c/strong\u003e bifurcate the stack and the application into independent\nsegments.\u003c/p\u003e\n\u003cp\u003eA stack using Docker containers has the same benefit of configuration\nmanagement, but can couple the stack and the application into a single managed\ncomponent. The application is deployed along with its stack— and the\ncomplete stack-app component is deployed together as a single Docker image or a\nbundle of Docker images that have already been integration tested at least on a\ndevelopers machine.\u003c/p\u003e\n\u003cp\u003eAs opposed the the \"automated provisioning\" model, the Docker model of the\nstack-app looks more like this:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eSet of Docker images\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eOperating system (the software Stack)\u003c/li\u003e\n\u003cli\u003eProvisioned software (the software Stack)\u003c/li\u003e\n\u003cli\u003eConfiguration (the software Stack)\u003c/li\u003e\n\u003cli\u003eSystem libraries (the software Stack)\u003c/li\u003e\n\u003cli\u003eSource code \u0026#x26; binaries (Application)\u003c/li\u003e\n\u003cli\u003eDependencies (Application)\u003c/li\u003e\n\u003cli\u003eRuntime environment (Application)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWith every deployment, the entire stack-app (1) will be deployed. Docker uses\nhashes (like Git) to minimize the amount of data that will be downloaded for any\nupdate. This means only the differences are downloaded rather than the entire\nstack.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThe greatest advantage of using Docker is that developers can run the\napplication in the very same environment as production\u003c/strong\u003e. According to\n\u003ca href=\"http://12factor.net/dev-prod-parity\"\u003eTwelve-Factor Methodology\u003c/a\u003e this is called\nachieving \"Dev/Prod Parity\". This is a huge benefit in that it eliminates an\nentire class of bugs that result from differences between\ndevelopers-and-developers as well as bugs that result from differences between\ndevelopers-and-production.\u003c/p\u003e\n\u003ch2\u003eElastic Beanstalk for Deployment\u003c/h2\u003e\n\u003cp\u003eIf you know \u003ca href=\"https://www.heroku.com/\"\u003eHeroku\u003c/a\u003e, than Amazons' Elastic Beanstalk\nwill be extremely familiar. EB borrows many ideas from Heroku, but the killer\nfeature is its' ability to dynamically run, deploy and scale Docker containers\non a cluster of servers. It handles hardware allocation, network configuration,\nload balancing, auto-scaling, health monitoring and rolling deployments.\u003c/p\u003e\n\u003cp\u003eEB doesn't do everything, but it's good enough to adopt early and use until your\nteam understands its deployment use-cases more clearly and understands\nlimitations of EB and its trade-offs.\u003c/p\u003e\n\u003ch2\u003eDjango specific structure\u003c/h2\u003e\n\u003cp\u003eThe core structure of the Docker / Elastic Beanstalk app can be explained by\ndescribing the directory structure.\u003c/p\u003e\n\u003cp\u003eThese comments describe the application-specific file structure:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.dockerignore\n.ebextensions/\n  01_envvars.config\n.ebignore\n.elasticbeanstalk/\nDockerrun.aws.json\n.gitignore               # Describes which files git ignores\n.bowerrc                 # Configures where web frontend dependencies live\n.csslintrc.json          # Describes CSS syntax rules\n.jshintrc                # Describes JavaScript syntax rules\nbower.json               # Describes web frontend dependencies\ngulpfile.js              # Describes app build and dev tasks\npackage.json             # Describes NPM dependencies\napp/                     # Our python app\n  apps/*                 # python app modules\n  project/*              # App-specific settings\n  dist/*                 # App static assets (served via Nginx)\nbin/*\ndocker/\n  django/\n    dev/\n      docker-compose.yml\n      Dockerfile\n    prod/\n      docker-compose.yml\n      Dockerfile\n      gunicorn.conf.py   # Settings for production app-server\n    start.sh             # Script to start app-server\n  nginx/*                # Nginx config files\nenvironments/            # Environment-specific settings\n  dev/                   # Development-only environment settings\n    .env                 # Actual environment vars (Excluded from git)\n    .env.example         # Example environment vars\n    Procfile             # Configures how Honcho starts app-servers\n    requirements.txt     # Describes dev Python dependencies\n  prod/                  # Development-only environment settings\n    .env                 # Actual environment vars (Excluded from git)\n    .env.example         # Example environment vars\n    Procfile             # Configures how Honcho starts app-servers\n    requirements.txt     # Describes prod Python dependencies\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSome of these directories and files are described in more depth below:\u003c/p\u003e\n\u003ch3\u003e.gitignore\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eenvironments/*/.env\nnode_modules\n.elasticbeanstalk/*\n!.elasticbeanstalk/*.cfg.yml\n!.elasticbeanstalk/*.global.yml\n# Built testing and static asset artifacts\napp/dist\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFiles matching the name \u003ccode\u003eenvironments/*/.env\u003c/code\u003e contain sensitive information\n(usernames, passwords, etc) about per-deployment environments that shouldn't be\nincluded in version control.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003enode_modules\u003c/code\u003e directory and will be created when the developer installs NPM\npackages. These are dependencies and should not be committed into the source\ncode repository.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e.elasticbeanstalk/*\u003c/code\u003e directory is excluded from Git because it contains\nfiles that are generated by EB command-line during environment creation and\nversion deployment that shouldn't be written to the repository. It also contains\ntemporary configuration files (written by the EB cli).\u003c/p\u003e\n\u003cp\u003eBoth \u003ccode\u003e!.elasticbeanstalk/*.cfg.yml\u003c/code\u003e and \u003ccode\u003e!.elasticbeanstalk/*.global.yml\u003c/code\u003e\nentries use the \"NOT\" operator to re- include themselves into the repo. These\nfiles can be useful to have in version control, as they contain useful\nenvironment configuration settings.\u003c/p\u003e\n\u003ch3\u003ebower.json\u003c/h3\u003e\n\u003cp\u003eBower is a web frontend package management system. The application declares its\nfrontend dependencies in this file.\u003c/p\u003e\n\u003cp\u003eDuring docker image creation, these dependencies are installed.\u003c/p\u003e\n\u003ch3\u003egulpfile.js\u003c/h3\u003e\n\u003cp\u003eGulp.js is a task runner for Node.js. \u003ccode\u003egulpfile.js\u003c/code\u003e defines common tasks and\nutilities related to this application:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRunning code Syntax checking \u0026#x26; automated testing\u003c/li\u003e\n\u003cli\u003eSASS and CSS compilation and minification\u003c/li\u003e\n\u003cli\u003eFrontend asset building\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003epackage.json\u003c/h3\u003e\n\u003cp\u003eNPM is a package management system for Node.js applications. \u003ccode\u003epackage.json\u003c/code\u003e The\napplication declares its Node.js dependencies in this file.\u003c/p\u003e\n\u003ch3\u003eapp/\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eapp/\u003c/code\u003e directory contains all source code related to the Django python web\napplication.\u003c/p\u003e\n\u003ch3\u003edocker/django/prod/gunicorn.conf.py\u003c/h3\u003e\n\u003cp\u003eThis project uses two application servers, \u003ccode\u003erunserver_plus\u003c/code\u003e during development\nand \u003ccode\u003egunicorn\u003c/code\u003e in production.\u003c/p\u003e\n\u003cp\u003eThese are settings related to the Gunicorn application server. In production, a\nmore performant application is used, requiring this configuration file.\u003c/p\u003e\n\u003ch3\u003edocker/nginx/sites-enabled.conf\u003c/h3\u003e\n\u003cp\u003eOn production systems, where nginx acts as a reverse-proxy for the Gunicorn web\napplication, we use Docker links to connect the two containers together. This\nconfiguration is best for reducing latency. Inside our nginx config file, we can\nuse a named entry for the \u003ccode\u003eproxy_pass\u003c/code\u003e value to reference our Django application\nserver running in another container on port 8080.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# ...\nlocation / {\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header Host $http_host;\n    proxy_redirect   off;\n    proxy_pass       http://django:8080;\n    # ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003edocker/django/start.sh\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003ecd /var/app\n# ...\nhoncho --procfile \"environments/$ENV_NAME/Procfile\" \\\n       --env \"environments/$ENV_NAME/.env\" start\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003estart.sh\u003c/code\u003e is used during both development and production as a single task to\nbootstrap the application server. It uses the \u003ccode\u003ehoncho\u003c/code\u003e task runner to start the\nserver according to a set of tasks in a \u003ccode\u003eProcfile\u003c/code\u003e for development and another\nfor production.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e--env\u003c/code\u003e parameter is used to pass environment variables sourced from the\nenvironments subdirectory. At runtime, the \u003ccode\u003e$ENV_NAME\u003c/code\u003e variable will be set:\n\u003ccode\u003edev\u003c/code\u003e for development and \u003ccode\u003eprod\u003c/code\u003e for production. This way a separate Procfile\nand separate set of environment variables are available to configure the modes\nindependently.\u003c/p\u003e\n\u003ch3\u003eenvironments/dev/Procfile\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e# The webserver: Python\nwebserver: cd app \u0026#x26;\u0026#x26; ./manage.py runserver_plus 0.0.0.0:8080\n# The CDN assets emulation server\ncdnserver: cd /var/app/app/dist \u0026#x26;\u0026#x26; python -m http.server 8010\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDuring development, the Django \u003ccode\u003erunserver_plus\u003c/code\u003e application server interprets\nPython, while a simple HTTP server serves assets (images, CSS, etc).\u003c/p\u003e\n\u003ch3\u003eenvironments/prod/Procfile\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ewebserver: cd app \u0026#x26;\u0026#x26; gunicorn \\\n  -c /etc/gunicorn/gunicorn.conf.py project.wsgi:application\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn production, we use Gunicorn to serve the python application, so the only task\nrun is the gunicorn app server. Static assets aren't handled here because Nginx\nwill be reverse-proxying the application and also serving static assets.\u003c/p\u003e\n\u003cp\u003eThis decision was made because Nginx is optimized to serve static assets and it\nwill reduce load on the application server.\u003c/p\u003e\n\u003ch3\u003eenvironments/[dev | prod]/.env.example\u003c/h3\u003e\n\u003cp\u003eBoth \u003ccode\u003eenvironments/dev/.env.example\u003c/code\u003e and \u003ccode\u003eenvironments/prod/.env.example\u003c/code\u003e are\ncommitted into git to provide hints to developers that they should create a\n\u003ccode\u003e.env\u003c/code\u003e file in the same directory as a place to store environment variables that\nare passed into the application.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e.env\u003c/code\u003e file is excluded from the git repository as it contains sensitive\nusernames passwords and cryptographic information.\u003c/p\u003e\n\u003ch3\u003eenvironments/[dev | prod]/requirements.txt\u003c/h3\u003e\n\u003cp\u003eThe python utility \u003ccode\u003epip\u003c/code\u003e is a package management utility. It uses a file named\n\u003ccode\u003erequirements.txt\u003c/code\u003e to install all package dependencies. The development\nenvironment adds some useful debugging utilities that shouldn't be included on\nproduction systems, so production has its own file.\u003c/p\u003e\n\u003cp\u003eDuring docker image creation, these dependencies are installed.\u003c/p\u003e\n\u003ch2\u003eDocker specific structure\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e.dockerignore            # Describes which files Docker ignores\n.ebextensions/\n  01_envvars.config\n.ebignore\n.elasticbeanstalk/\nDockerrun.aws.json\n.gitignore\n.bowerrc\n.csslintrc.json\n.jshintrc\nbower.json\ngulpfile.js\npackage.json\napp/\n  apps/*\n  project/*\n  dist/*\nbin/*                    # Scripts for Docker, build and deployment\ndocker/                  # Configuration files required by docker\n  django/                # Django related settings\n    dev/                 # Development-only settings\n      docker-compose.yml # Orchestrates dev containers\n      Dockerfile         # Builds dev Docker image\n    prod/                # Production-only settings\n      docker-compose.yml # Orchestrates prod containers\n      Dockerfile         # Builds prod Docker image\n      gunicorn.conf.py\n    start.sh\n  nginx/*\nenvironments/\n  dev/\n    .env\n    .env.example\n    Procfile\n    requirements.txt\n  prod/\n    .env\n    .env.example\n    Procfile\n    requirements.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e.dockerignore\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003e.dockerignore\u003c/code\u003e file specifies a list of patterns to exclude from the build\ncontext during creation of the Docker image. These files are not required by the\nexecution of the container, and should be removed to reduce the size of the\nfinal image.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.coverage\n.ebextensions/*\n.elasticbeanstalk/*\n.ebignore\n.dockerignore\n.git\n.gitignore\n.DS_Store\nnode_modules\napp/dist\ndocs\nhtmlcov\nREADME.md\nghostdriver.log\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSome notable entries are described below:\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003enode_modules\u003c/code\u003e directory and will be created when the developer installs NPM\npackages. If the developer is using on OS X, packages compiled on OS X will not\nwork when the container is running in the Linux VM, so this entry ensures that\nnode modules are installed on the host OS independently from the container OS.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e.ebextensions/*\u003c/code\u003e, \u003ccode\u003e.elasticbeanstalk/*\u003c/code\u003e and \u003ccode\u003e.ebignore\u003c/code\u003e are required by the\nElastic Beanstalk deploy process, and are outside the scope of execution of the\nDocker container, and are not required.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eapp/dist\u003c/code\u003e directory contains frontend assets served by both Django and\nNginx, and are required by both Django and Nginx containers. Because Amazon ECS\ncannot (currently) directly mount a single volume from one container into\nanother container, we need these files to be deployed directly on the host OS.\nDocker can mount the directory on both Django and Nginx containers as a shared\nvolume. This directory will be deployed by EB, and is thus excluded from Docker.\u003c/p\u003e\n\u003ch3\u003ebin/image\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ebin/image\u003c/code\u003e is a shell script that wraps common Docker commands used to create\nDocker images. There are three major subcommands: \u003ccode\u003ebuild\u003c/code\u003e, \u003ccode\u003edestroy\u003c/code\u003e and\n\u003ccode\u003eupdate\u003c/code\u003e all take a single argument, the name of the environment subdirectory of\nthe \u003ccode\u003eenvironments/\u003c/code\u003e directory. This will spawn Docker and build, delete or\nrebuild the image as specified by the \u003ccode\u003eDockerfile\u003c/code\u003e in the directory\ncorresponding to the final argument.\u003c/p\u003e\n\u003ch3\u003ebin/stevedore\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ebin/stevedore\u003c/code\u003e is a shell script that wraps common Docker commands used to\nstart and stop Docker containers. There are many subcommands, but the most\nuseful are: \u003ccode\u003estart\u003c/code\u003e, \u003ccode\u003estop\u003c/code\u003e and either of the two \u003ccode\u003ebuild\u003c/code\u003e commands. All\nsubcommands take take a single argument, the name of the environment\nsubdirectory of the \u003ccode\u003eenvironments/\u003c/code\u003e directory. This will spawn Docker and start,\nstop or run the corresponding build process.\u003c/p\u003e\n\u003ch3\u003edocker/django/dev/docker-compose.yml\u003c/h3\u003e\n\u003cp\u003eThis file provides configuration for Docker to orchestrate the management of the\ndevelopment Docker container for the local dev environment.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edjango:\n  build: ../../..\n  dockerfile: docker/django/dev/Dockerfile\n  env_file: ../../../environments/dev/.env\n  volumes:\n    - \"../../../app/apps:/var/app/app/apps\"\n    - \"../../../app/dist:/var/app/app/dist\"\n    - \"../../../app/project:/var/app/app/project\"\n    - \"../../../app/manage.py:/var/app/app/manage.py\"\n    - \"../../../environments:/var/app/environments\"\n    - \"../../../gulpfile.js:/var/app/gulpfile.js\"\n  ports:\n    - \"80:8080\"\n    - \"8010:8010\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt defines one container \"django\", specifying a path to the \u003ccode\u003ebuild\u003c/code\u003e-context as\nwell as a path to load the \u003ccode\u003eDockerfile\u003c/code\u003e. \u003ccode\u003eenv_file\u003c/code\u003e specifies the path the a\nfile containing all environment variables. A set of volumes to share from the\nhost OS to the container are listed in \u003ccode\u003evolumes\u003c/code\u003e. Finally \u003ccode\u003eports\u003c/code\u003e tells Docker\nwhich ports on the host to map to the container.\u003c/p\u003e\n\u003ch3\u003edocker/django/dev/Dockerfile\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eDockerfile\u003c/code\u003e is a set of instructions for Docker to execute in order to\nproduce a Docker image— a file used to create a Docker container running\nyour application code.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# ...\n# Install apt, Python then NodeJS dependencies.\nRUN             apt-get update \u0026#x26;\u0026#x26; \\\n                curl -sL https://deb.nodesource.com/setup_0.12 | bash - \u0026#x26;\u0026#x26; \\\n                apt-get install -y nodejs \u0026#x26;\u0026#x26; \\\n                pip install --upgrade pip \u0026#x26;\u0026#x26; \\\n                pip install -r \\\n                    environments/dev/requirements.txt \u0026#x26;\u0026#x26; \\\n                npm update \u0026#x26;\u0026#x26; \\\n                npm install -g gulp \u0026#x26;\u0026#x26; \\\n                npm install \u0026#x26;\u0026#x26; \\\n                gulp\n# Add our initialization script to the image and run it upon startup.\nADD             docker/django/start.sh /\nCMD             [\"/start.sh\"]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the development Dockerfile, \u003ccode\u003epip\u003c/code\u003e and \u003ccode\u003enpm\u003c/code\u003e commands install the necessary\ndependencies from the \u003ccode\u003eenvironments/dev\u003c/code\u003e folder. Finally \u003ccode\u003estart.sh\u003c/code\u003e is called to\nstart the Django application server.\u003c/p\u003e\n\u003ch3\u003edocker/django/prod/docker-compose.yml\u003c/h3\u003e\n\u003cp\u003eThis file provides configuration for Docker to orchestrate the management of the\nproduction Docker containers. This configuration can be used for testing locally\nprior to deployment to Amazon AWS.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yml\"\u003edjango:\n  build: ../../..\n  dockerfile: docker/django/prod/Dockerfile\n  env_file: ../../../environments/prod/.env\n  volumes:\n    - \"../../../docker/django/prod/gunicorn.conf.py:/etc/gunicorn/gunicorn.conf.py:ro\"\n    - \"/var/app/app/dist\"\n\nnginx:\n  image: nginx\n  links:\n    - django\n  volumes:\n    - \"../../../docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro\"\n    - \"../../../docker/nginx/sites-enabled.conf:/etc/nginx/conf.d/default.conf:ro\"\n  volumes_from:\n    - django\n  ports:\n    - \"80:80\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt defines two containers \"django\" and \"nginx\". \"Django\" is configured quite\nsimilar to the development setup, but doesn't map as many volumes from the host\nOS to the container. In this configuration \"django\" doesn't need to expose a\nport externally, as the \"nginx\" container will expose port 80 externally.\u003c/p\u003e\n\u003cp\u003eImportantly, the \"nginx\" container uses \u003ccode\u003elinks\u003c/code\u003e to connect the \"django\"\ncontainer to \"nginx\". This way nginx config files can refer to \"django\" as-if it\nwas another host on the same network with the name \"nginx\".\u003c/p\u003e\n\u003cp\u003eFinally, the \"nginx\" container will mount all volumes from the \"django\"\ncontainer with the \u003ccode\u003evolumes_from\u003c/code\u003e directive, and expose port 80 to the host OS.\u003c/p\u003e\n\u003ch3\u003edocker/django/prod/Dockerfile\u003c/h3\u003e\n\u003cp\u003eThe major difference between the development \u003ccode\u003eDockerfile\u003c/code\u003e and the production\nversion is:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIt exposes port 8080 for other containers\u003c/li\u003e\n\u003cli\u003eIt runs \u003ccode\u003egulp build\u003c/code\u003e during image creation\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis Dockerfile also installs production-only Python pip dependencies in\nrequirements.txt.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# Install apt, Python then NodeJS dependencies.\nRUN             apt-get update \u0026#x26;\u0026#x26; \\\n                curl -sL https://deb.nodesource.com/setup_0.12 | bash - \u0026#x26;\u0026#x26; \\\n                apt-get install -y nodejs \u0026#x26;\u0026#x26; \\\n                pip install --upgrade pip \u0026#x26;\u0026#x26; \\\n                pip install -r \\\n                    environments/prod/requirements.txt \u0026#x26;\u0026#x26; \\\n                npm update \u0026#x26;\u0026#x26; \\\n                npm install -g gulp \u0026#x26;\u0026#x26; \\\n                npm install \u0026#x26;\u0026#x26; \\\n                gulp build\n# Exposes port 8080\nEXPOSE          8080\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen Docker runs the image build, it runs \u003ccode\u003egulp build\u003c/code\u003e, which runs code-quality,\nunit tests and produces production-ready web frontend assets. This allows for\ntesting prior to deployment, and gives the team an opportunity to fix errors\nbefore they go into the wild.\u003c/p\u003e\n\u003ch2\u003eElastic Beanstalk specific structure\u003c/h2\u003e\n\u003cp\u003eFinally, these comments describe files related to Amazons' Elastic Beanstalk:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.dockerignore\n.ebextensions/           # Describes how EB builds environments\n  01_envvars.config      # Describes env vars for AWS Docker containers\n.ebignore                # Describes how Amazon EB ignores some files\n.elasticbeanstalk/       # Location Amazon EB stores its cli settings\nDockerrun.aws.json       # Describes how to run our containers in AWS\n.gitignore\n.bowerrc\n.csslintrc.json\n.jshintrc\nbower.json\ngulpfile.js\npackage.json\napp/\n  apps/*\n  project/*\n  dist/*\nbin/*\ndocker/\n  django/\n    dev/\n      docker-compose.yml\n      Dockerfile\n    prod/\n      docker-compose.yml\n      Dockerfile\n      gunicorn.conf.py\n    start.sh\n  nginx/*\nenvironments/\n  dev/\n    .env\n    .env.example\n    Procfile\n    requirements.txt\n  prod/\n    .env\n    .env.example\n    Procfile\n    requirements.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e.ebextensions/01_envvars.config\u003c/h3\u003e\n\u003cp\u003eThis file is used by the Elastic Beanstalk command line utilities to pass\nkey-value parameters to Amazon EC2 and ECS. This file is used to store all\nproduction environment variables that are provided to running containers. This\nvariables often vary between deployments.\u003c/p\u003e\n\u003ch3\u003e.ebignore\u003c/h3\u003e\n\u003cp\u003eWhen Elastic Beanstalk does a deployment, it creates a zip file of the current\ndirectory, uploads it to Amazon S3, and deploys the files to running EC2\ninstances. Since this project is using Docker images to package the app, we can\nignore most files; with the exception of the \u003ccode\u003eapp/dist\u003c/code\u003e directory— which\nboth \"Django\" and \"Nginx\" containers will need access too.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e.ebignore\u003c/code\u003e file is used to ignore certain files in a project directory.\nThis file works like a \u003ccode\u003e.gitignore\u003c/code\u003e file.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Ignore everything!\n*\n# Except for these exclusion patterns required by Amazon ECS\n!Dockerrun.aws.json\n!.ebextensions/*.config\n!.elasticbeanstalk/*.cfg.yml\n!.elasticbeanstalk/*.global.yml\n!app/dist/**\n!docker/**\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe only files our EB package should contain are those required by Docker,\nElastic Beanstalk itself, or any files shared between both containers (such as\nthe \u003ccode\u003eapp/dist\u003c/code\u003e directory).\u003c/p\u003e\n\u003cp\u003eWhen you deploy your project directory to Elastic Beanstalk and create a new\napplication version, the EB CLI will not include files specified by the\n\u003ccode\u003e.ebignore\u003c/code\u003e in the source bundle that it creates. This is useful for creating\nsmaller packages by excluding files that aren't required for running\nproduction-only code.\u003c/p\u003e\n\u003ch3\u003e.elasticbeanstalk/\u003c/h3\u003e\n\u003cp\u003eElastic Beanstalk uses this directory to store temp files and configuration\ninformation about the current AWS account, EB Application name and IAM\ncredentials to utilize.\u003c/p\u003e\n\u003ch3\u003eDockerrun.aws.json\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eDockerrun.aws.json\u003c/code\u003e is a proprietary Amazon-specific JSON format called a\n\"\u003ca href=\"#task-def\"\u003eTask Definition\u003c/a\u003e\" used to configure how to manage Docker containers\nrunning on Amazon EC2 Container Service (ECS) platform.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e\"containerDefinitions\": [\n{\n    \"name\": \"django\",\n    \"image\": \"0xadada/dockdj:latest\",\n    \"essential\": true,\n    \"memory\": 512,\n    \"mountPoints\": [\n        {\n            \"sourceVolume\": \"gunicorn-conf\",\n            \"containerPath\": \"/etc/gunicorn/gunicorn.conf.py\",\n            \"readOnly\": true\n        }\n    ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe JSON format is very similar to the docker-compose Yaml format, having a\nnearly 1-to-1 mapping of \u003ccode\u003eimage\u003c/code\u003e, \u003ccode\u003emountPoints\u003c/code\u003e to volumes and ports all\ndefined.\u003c/p\u003e\n\u003cp\u003eThis file is functionally identical to \u003ccode\u003edocker/prod/docker-compose.yml\u003c/code\u003e in that\nit runs, configures and connects the \"Django\" and \"Nginx\" Docker containers. As\nsuch, changes to the \u003ccode\u003edocker-compose.yml\u003c/code\u003e file should be mirrored in the\n\u003ccode\u003eDockerrun.aws.json\u003c/code\u003e file.\u003c/p\u003e\n\u003ch2\u003eLifecycle\u003c/h2\u003e\n\u003cp\u003eNew developers to this project simply clone the project from GitHub, install\nDocker (and boot2docker/docker-machine on OS X) and can begin running the app.\nThere is no need to setup a developer environment or create (yet) another VM.\u003c/p\u003e\n\u003ch3\u003eDevelopment\u003c/h3\u003e\n\u003cp\u003eWhen the developer starts working on the project from scratch, the only\nrequirement is Docker and a machine capable of running Docker containers (Linux\n3+ or boot2docker/docker-machine).\u003c/p\u003e\n\u003cp\u003eOnce an organization or developer has adopted Docker for a single project,\nstartup time for other docker projects is drastically reduced as this core\nrequirement has already been met. From that point forward, the projects\nthemselves can define and provision their own dependencies.\u003c/p\u003e\n\u003cp\u003eFor this project, the next steps required of the developer are as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone \u0026#x3C;PROJECT\u003e\n\u0026#x3C;create .env file\u003e\n.bin/stevedore dev start\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe developer is now running the app. Any internal OS configuration, system\nlibraries, software dependencies and provisioning are all handled by the project\nand Docker— transparently to the developer.\u003c/p\u003e\n\u003cp\u003eSubsequent context-switches between other projects and this project have been\nreduced to a single command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e.bin/stevedore dev start\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe developer doesn't need to boot up a VM, nor does she/he need to understand\nor start any internal processes or run any commands internal to the VM.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIn development, Docker can be used to lower cognitive load on developers\nswitching between multiple projects.\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003eQA\u003c/h3\u003e\n\u003cp\u003eIn this particular project, QA tests are run during build of the the production\nDocker image via the \u003ccode\u003egulp build\u003c/code\u003e task. See\n\u003ca href=\"#dockerdjangoproddockerfile\"\u003ethe production Dockerfile\u003c/a\u003e to view how it calls\nthe gulp task.\u003c/p\u003e\n\u003cp\u003eIn effect, this will prevent developers or continuous Integration systems from\npublishing a production Docker image to Docker Hub, as the build will trigger a\nDocker image build failure.\u003c/p\u003e\n\u003cp\u003eMore generally, development teams could create different tags for \"production\"\nreleases and \"development\" Docker image releases. Lets say \"prod\" vs \"dev\".\u003c/p\u003e\n\u003cp\u003eDevelopment teams could publish images tagged with \"dev\", to Docker Hub. Other\ndevelopers on the team or members of the QA team could \u003ccode\u003edocker pull\u003c/code\u003e that tagged\nimage and run their suite of tests on it.\u003c/p\u003e\n\u003cp\u003eUsing Docker in this manner, dev and QA teams no longer have to keep VM\nconfigurations synchronized, as the OS and other dependencies have been pushed\ndown from VM directly into dependencies within the scope of the project. \u003cstrong\u003eThis\nhas the effect of reducing manual synchronization and de-necessitating\nout-of-channel communication between development and QA teams about the state of\nthe runtime environment.\u003c/strong\u003e This allows for faster, less-error-prone iteration of\nthe runtime environment.\u003c/p\u003e\n\u003ch3\u003eProduction\u003c/h3\u003e\n\u003cp\u003eDevelopers have iterated on functionality, QA has run tests against the code,\nand the projects is ready for deployment to production.\u003c/p\u003e\n\u003cp\u003eAt this point, a working Docker image has been run on developers local machines,\nand QA has passed. These three phases could've gone through multiple iterations\nwhile bugs were identified and fixed. The end result is a working Docker image\nexists that has been deemed \"ready\" for production.\u003c/p\u003e\n\u003cp\u003eEither manually or as part of a continuous integration tool, the\nproduction-ready Docker image can now be tagged with a release version and\npublished to Docker Hub (or other compatible Docker image repository). Finally,\nthe deploy process needs to update the production servers running our working\napplication stack and run the latest application code.\u003c/p\u003e\n\u003cp\u003eThese tasks are handled by our \u003ccode\u003ebin/deploy\u003c/code\u003e script, a wrapper for Docker, Git\nand Elastic Beanstalk. It will tag the latest Docker image, publish the tag to\nDocker Hub, tag the publish the tags to GitHub and use Elastic Beanstalk to\ndeploy both the latest stack and application code:\u003c/p\u003e\n\u003cp\u003e(Lets use 1.2.3 as an arbitrary version number for this example)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ebin/deploy release 1.2.3 # Create a release branch and tag the image\nbin/deploy publish 1.2.3 # Publish the Docker image and git branch\n                         # to Docker Hub and GitHub\nbin/deploy deploy 1.2.3  # Use EB to deploy the latest release\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe deploy script is a light bash wrapper that automates Git, Docker and Elastic\nBeanstalk commands in an easy-to-reproduce set of short commands.\u003c/p\u003e\n\u003cp\u003eOnce complete, the Amazon environment will be running your latest application\ncode, as well as any new changes to the container OS, system libraries and\ndependencies. Most importantly, \u003cstrong\u003eany changes in provisioning to the stack have\nbeen deployed along with the Docker image\u003c/strong\u003e, thus enabling seamless roll-backs.\n\u003cstrong\u003eRolling back the application version will also rollback the stack version\u003c/strong\u003e.\nThe application and stack are deployed together.\u003c/p\u003e\n\u003cp\u003eHappy cloud computing!\u003c/p\u003e\n\u003ch2\u003eTerms\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca name=\"autoscaling\"\u003e\u003cem\u003eAuto-scaling\u003c/em\u003e\u003c/a\u003e A method of setting a threshold that\ndetects when the load on a server cluster necessitates adding or removing\nservers in order to optimize the number of servers servicing that load.\nAuto-scaling allows an organization to decrease operating costs by running the\nminimum number of servers required to service its load, and eliminating the\nneed to accurately predict future traffic patterns.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca name=\"config-mgmt\"\u003e\u003cem\u003eConfiguration Management\u003c/em\u003e\u003c/a\u003e Software tools that are\ndesigned to automatically start, provision and configure software on virtual\nmachines rather than have engineers run these steps manually on each server.\nThese tools can be used both locally to create development VMs (virtual\nmachines) as well as in the cloud to create staging and production VMs.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca name=\"docker-image\"\u003e\u003cem\u003eDocker image\u003c/em\u003e\u003c/a\u003e A docker image is like an executable\nprogram binary. It takes source files and other assets and bundles them\ntogether, and the resulting bundle can be run/executed as a single process on\na Linux machine.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca name=\"docker-container\"\u003e\u003cem\u003eDocker container\u003c/em\u003e\u003c/a\u003e A docker container is like a\nrunning executable program. It is a running instance of a docker image. Like a\nrunning program, it has a PID, and it is appropriate to call it a process. It\ncan be started and stopped. One docker image can be run many times on one or\nmore machines.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca name=\"provisioning\"\u003e\u003cem\u003eProvisioning\u003c/em\u003e\u003c/a\u003e The installation and configuration\nof software needed to run an application. E.g. Installing and configuring\nApache and its system libraries in order to run WordPress.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca name=\"task-def\"\u003e\u003cem\u003eTask definition\u003c/em\u003e\u003c/a\u003e A proprietary JSON format for\ndescribing how Docker containers are run within the Amazon EC2 Cloud Service.\nRead more about\n\u003ca href=\"http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html\"\u003eAmazon ECS Task Definitions\u003c/a\u003e.\nDocker uses the \u003ca href=\"https://docs.docker.com/compose/yml/\"\u003edocker-compose Yaml\u003c/a\u003e\nfile to do the same thing.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003csection data-footnotes class=\"footnotes\"\u003e\u003ch2 id=\"footnote-label\" class=\"sr-only\"\u003eFootnotes\u003c/h2\u003e\n\u003col\u003e\n\u003cli id=\"user-content-fn-1\"\u003e\n\u003cp\u003eConfiguration management tools can be used to couple both Stack and\nApplication, but experience has has shown that over time, these tools\nare not strongly opinionated, and therefore Stack-App decoupling occurs\norganically over the lifetime of a project. \u003ca href=\"#user-content-fnref-1\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"user-content-fn-2\"\u003e\n\u003cp\u003eDocker runs on  Linux version 3. In the case where the developer is\nusing OS X, Windows or another non-Linux OS, they'll need to run a Linux\nVM in order to use Docker. However, this single VM will be able to run\nall Docker containers for all Docker projects they use. Tools like\nDocker Machine make working with the Docker VM much simpler. \u003ca href=\"#user-content-fnref-2\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n","slug":"2015-11-03-development-lifecycle-with-docker-and-elastic-beanstalk","license":"cc-by-nc-sa"}},"__N_SSG":true},"page":"/[year]/[month]/[day]/[slug]","query":{"year":"2015","month":"11","day":"03","slug":"development-lifecycle-with-docker-and-elastic-beanstalk"},"buildId":"U8wg1OrnAOssRMsMczpXl","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>