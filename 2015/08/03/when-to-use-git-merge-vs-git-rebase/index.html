<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>When to Use Git Merge vs Git Rebase</title><meta property="og:site_name" content="0xADADA"/><meta property="og:title" content="When to Use Git Merge vs Git Rebase"/><meta name="twitter:title" content="When to Use Git Merge vs Git Rebase"/><link rel="canonical" href="https://0xadada.pub/2015/08/03/when-to-use-git-merge-vs-git-rebase/"/><meta property="og:url" content="https://0xadada.pub/2015/08/03/when-to-use-git-merge-vs-git-rebase/"/><meta name="twitter:url" content="https://0xadada.pub/2015/08/03/when-to-use-git-merge-vs-git-rebase/"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@0xadada"/><meta name="author" content="0xADADA"/><meta property="og:type" content="article"/><meta name="description" content="This article will attempt to provide an overview to the different workflows, and explain when merge and rebase are the more appropriate workflow to use."/><meta name="twitter:description" content="This article will attempt to provide an overview to the different workflows, and explain when merge and rebase are the more appropriate workflow to use."/><meta property="og:image" content="https://0xadada.pub//static/images/2015-08-03-git-merge-vs-rebase-07.png"/><meta property="og:image:height" content="180"/><meta property="og:image:width" content="180"/><meta name="twitter:image:height" content="512"/><meta name="twitter:image:width" content="512"/><meta property="twitter:image" content="https://0xadada.pub//static/images/2015-08-03-git-merge-vs-rebase-07.png"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="https://0xadada.pub/favicon.ico"/><link rel="home" href="https://0xadada.pub/"/><link rel="manifest" href="https://0xadada.pub/static/images/meta/0xadada.webmanifest"/><link rel="apple-touch-icon" href="https://0xadada.pub/static/images/meta/apple-touch-icon.png"/><link rel="icon" type="image/png" href="https://0xadada.pub/static/images/meta/favicon-32x32.png" sizes="32x32"/><link rel="icon" type="image/png" href="https://0xadada.pub/static/images/meta/favicon-16x16.png" sizes="16x16"/><link rel="mask-icon" href="https://0xadada.pub/static/images/meta/safari-pinned-tab.svg" color="#5bbad5"/><meta name="msapplication-config" content="https://0xadada.pub/static/images/meta/browserconfig.xml"/><meta name="theme-color" content="#FDF9F0"/><meta name="pocket-site-verification" content="7431f135e23a84de547e5b79dab406"/><meta name="next-head-count" content="31"/><link rel="preload" href="/_next/static/css/e1b9489c484826a3.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e1b9489c484826a3.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e491c5ad83d0116a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e491c5ad83d0116a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-22b044904a3f81e0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-929aade252cc0f2b.js" defer=""></script><script src="/_next/static/chunks/392-e44e3e95fe0288b1.js" defer=""></script><script src="/_next/static/chunks/pages/%5Byear%5D/%5Bmonth%5D/%5Bday%5D/%5Bslug%5D-6950cfe1d86de54a.js" defer=""></script><script src="/_next/static/jDSJqHsQyJoddBl0I99ub/_buildManifest.js" defer=""></script><script src="/_next/static/jDSJqHsQyJoddBl0I99ub/_ssgManifest.js" defer=""></script><script src="/_next/static/jDSJqHsQyJoddBl0I99ub/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><main class="layout_layout__Xf50c"><article class="hentry h-entry" lang="en-US"><header><h1 class="entry-title p-name">When to Use Git Merge vs Git Rebase</h1><time class="byline_published__8ePA_ dt-published" dateTime="2015-08-03T07:31:00.000Z">Monday August 3, 2015</time><br/><span class="byline_byline__jNP6Q h-card">by: <span class="author fn p-author p-name">0xADADA</span></span></header><div class="entry-content e-content"><p>I’ve seen many articles and discussions online discussing the merits of merge
and rebase when integrating parallel branches into the main branch. It seems
there are two camps arguing “which is better” when in reality, both have their
own use cases.</p>
<p>The task we need to accomplish is to determine which workflow is right for your
project. This article will attempt to provide an overview to the different
workflows, and explain when merge and rebase are the more appropriate workflow
to use.</p>
<h2>The Simplistic Branch Workflow</h2>
<h3>aka the GitFlow / Branch-Merge-Merge Workflow</h3>
<p>Software development teams have a typical way of doing things, but all have a
main integration branch (I’ll call it “Master” for the remainder of this
article) that receives feature branches.</p>
<p>Feature branches originate from Master, active development is performed along
the feature branch, and when the feature is complete, it’s combined back into
Master.</p>
<p>I call this workflow the
“<a href="http://nvie.com/posts/a-successful-git-branching-model/">GitFlow</a> /
Branch-Merge-Merge” workflow. The history of events for this simplistic workflow
are as follows:</p>
<p>on Master:</p>
<ul>
<li>commit #1</li>
<li>commit #2</li>
</ul>
<p>on Feature:</p>
<ul>
<li>commit #a</li>
<li>commit #b</li>
</ul>
<p>on Master:</p>
<ul>
<li>merge feature <code>--no-ff</code></li>
</ul>
<p>This produces the following graph:</p>
<figure>
    <img src="/static/images/2015-08-03-git-merge-vs-rebase-01.png"
      alt="Graph of a typical git workflow. Numbered commits occur along Master.
        Alphabetized commits occur along Feature." title="Graph of a typical git
        workflow. Numbered commits occur along Master.  Alphabetized commits occur
        along Feature.">
  <figcaption>Graph of a typical git workflow. Numbered commits occur
  along Master. Alphabetized commits occur along Feature.</figcaption>
</figure>
<p>This workflow performs well for a single developer because while the feature
development occurred on the feature branch, the sequence of events occurred
linearly. Importantly, no changes occurred on Master while Feature branch was
changed.</p>
<p>When development occurs in parallel on the upstream branch (ie. Master), either
by the developer, or a co-developer, the history gets more complicated.</p>
<p>For this example, we’ll pretend to be a single developer working on both
branches in parallel, we use the following sequence:</p>
<p>on Master:</p>
<ul>
<li>commit #1</li>
<li>commit #2</li>
</ul>
<p>on Feature:</p>
<ul>
<li>commit #a</li>
<li>commit #b</li>
</ul>
<p>on Master:</p>
<ul>
<li>commit #3</li>
<li>commit #4</li>
</ul>
<p>on Master:</p>
<ul>
<li>git merge feature <code>--no-ff</code></li>
</ul>
<p>This produces the following graph:</p>
<figure>
  <img src="/static/images/2015-08-03-git-merge-vs-rebase-02.png"
      alt="Typical workflow diagram" title="Typical workflow diagram">
  <figcaption>
    Graph of a typical git workflow. Numbered commits occur along Master.
    Alphabetized commits occur along Feature.
  </figcaption>
</figure>
<p>In the above scenario the developer runs into the problem where Feature commits
#a and #b were done independently of Master commits #3, #4 and #5. This merge
will fail.</p>
<p>To solve this problem, the developer must first merge the upstream changes in
Master into feature branch Feature. To accomplish this, the developer must
switch into the feature branch and merge in the changes from Master. The
developer must then switch back to Master and merge the changes from Feature
into Master. Use the following sequence:</p>
<p>on Feature:</p>
<ul>
<li>merge master</li>
</ul>
<p>on Master:</p>
<ul>
<li>merge feature</li>
</ul>
<p>This produces the following graph:</p>
<figure>
  <img src="/static/images/2015-08-03-git-merge-vs-rebase-03.png"
      alt="Typical workflow diagram" title="Typical workflow diagram">
  <figcaption>
    Note how the final git log interleaves the commits on
    Feature between commits on Master.
  </figcaption>
</figure>
<p>I call this workflow the “Branch-Merge-Merge” workflow because in the most
general case — the workflow begins with a branch, requires an upstream merge
into the feature branch prior to merging the feature branch back into the master
branch.</p>
<p>Looking at the above graph, feature branch Feature has been merged successfully
into Master, but the git log shows an interleaved sequence of commits between
Master and Feature that make debugging complex.</p>
<p>In the case where branch Feature introduced a bug into the Master branch, a
rollback will be difficult because of how the commits are interleaved. In the
case where the bug was introduced in Feature branch commit #b, the maintainer of
Master branch would need to roll-back commits #6, #c, #5, #4 and #b. This is a
difficult roll-back because Master branch features #5 and #4 were rolled back in
the effort to roll back to Feature branch feature #b. We’ve thrown some of the
baby out with the bathwater.</p>
<p>One way to address the problems with this particular scenario is to merge in the
Feature branch as a single commit appended to the Master branch, rather than as
a set of interleaved commits within the Master branch. This brings us to the
next workflow.</p>
<h2>Branch-Merge-MergeSquash Workflow</h2>
<p>This workflow attempts to address the shortcomings of the workflow above by
appending feature branches as a single commit at the end of the integration
branch.</p>
<p>For this example, lets pretend to be a single developer working on both branches
in parallel (as I did above), we use the following sequence:</p>
<p>on Master:</p>
<ul>
<li>commit #1</li>
<li>commit #2</li>
</ul>
<p>on Feature:</p>
<ul>
<li>commit #a</li>
<li>commit #b</li>
</ul>
<p>on Master:</p>
<ul>
<li>commit #3</li>
<li>commit #4</li>
</ul>
<p>on Feature:</p>
<ul>
<li>merge master</li>
</ul>
<p>on Master:</p>
<ul>
<li>git merge feature <code>--squash</code></li>
</ul>
<p>This produces the following graph:</p>
<figure>
  <img src="/static/images/2015-08-03-git-merge-vs-rebase-04.png"
      alt="Typical workflow diagram" title="Typical workflow diagram">
  <figcaption>
    The git log sequence of events shows a linear series of
    feature integrations.
  </figcaption>
</figure>
<p>Looking at the above graph, feature branch Feature has been merged successfully
into Master (although the graph doesn’t show a merge line) at commit #5.
Importantly, the git log shows a linear sequence of commits, each indicating a
complete feature integration. The squash flag has collapsed Feature branch
commit #a, #b and #c into single commit #5.</p>
<p>In the case where branch Feature introduced a bug into the Master branch, a
rollback will be as simple as running <code>git reset --hard HEAD^</code> because of how
the Feature branch was a single commit appended onto Master. In this scenario,
the Master branch maintainer would tell the Feature branch maintainer to fix the
problem, and they could attempt the merge once the issue was fixed.</p>
<p><strong>I recommend this workflow</strong> as a best-practice in cases where the feature
branch will be shared (eg. pushed to GitHub, shared with other developers.)</p>
<p>A potential downside of this workflow is the potential confusion caused by the
origin commit of the Feature branch. Feature branch origin is located at commit
#2, and merged at commit #5. This is additional cognitive load on the Master
branch maintainer when it comes time to merge the feature branch into Master. A
simplified workflow could solve this by having the Feature branch simulate its
origin commit at commit #4 prior to merging into Master. This would reduce
cognitive load on the Master branch maintainer.</p>
<h2>Branch-Rebase-MergeSquash Workflow</h2>
<p>This workflow is popular with
<a href="https://nodejs.org/documentation/contributing/">open source projects</a> where the
job for the Master branch maintainer involves multiple feature branch
integrations on a daily basis.</p>
<p>This workflow is designed to make feature branch merges much simpler and easier
to roll back. The main idea is that each feature branch is a simple append to
the end of the Master branch. No merge is simpler than and append-merge.</p>
<p>For this example, lets pretend to be the same single developer working on both
branches in parallel (again, as I did above), we use the following sequence:</p>
<p>on Master:</p>
<ul>
<li>commit #1</li>
<li>commit #2</li>
</ul>
<p>on Feature:</p>
<ul>
<li>commit #a</li>
<li>commit #b</li>
</ul>
<p>on Master:</p>
<ul>
<li>commit #3</li>
<li>commit #4</li>
</ul>
<p>on Feature:</p>
<figure>
  <img src="/static/images/2015-08-03-git-merge-vs-rebase-05.png"
      alt="Feature with upstream changes before rebase"
      title="Feature with upstream changes before rebase">
  <figcaption>
    On the Feature branch, the graph appears after
    commit #2 prior to rebase.
  </figcaption>
</figure>
<ul>
<li>rebase master</li>
</ul>
<figure>
  <img src="/static/images/2015-08-03-git-merge-vs-rebase-06.png"
      alt="Feature with upstream changes after rebase"
      title="Feature with upstream changes after rebase">
  <figcaption>
    After rebase, Feature branch commits #a and #b originate
    from parent commit #4
  </figcaption>
</figure>
<p>We have now changed the origin commit of branch Feature to commit #4. This sets
up future merges of the Feature branch to append directly to the end of Master
branch.</p>
<p>on Master:</p>
<ul>
<li>merge feature <code>--squash</code></li>
</ul>
<p>We’ve now switched to the Master branch, and merged in the rebased Feature
branch, appending a single commit #5 to the end of the Master branch containing
all of the Feature branch.</p>
<p>This produces the final graph:</p>
<figure>
  <img src="/static/images/2015-08-03-git-merge-vs-rebase-07.png"
      alt="Feature with upstream changes after rebase"
      title="Feature with upstream changes after rebase">
  <figcaption>
    After merging the Feature into Master, commit #5 containing
    the final result of all Feature branch commits #a and #b.
  </figcaption>
</figure>
<p>The final sequence of events on the Master branch read cleanly, showcasing only
past feature branch integrations. Each feature branch originated directly from
the latest commit, making it seem like the feature is a simple fast-forward
append onto the latest commit.</p>
<p>It’s worth pointing out the Branch-Merge-MergeSquash and
Branch-Rebase-MergeSquash workflows both result in the same final sequence of
commits. The major benefit of the Branch-Rebase-MergeSquash workflow is that
its’ branch origin appears much later in the history, reducing cognitive load on
Master branch integrations.</p>
<p><strong>I recommend this workflow</strong> as a
<a href="http://blog.izs.me/post/37650663670/git-rebase">best-practice</a> when the
developer is working alone on a feature branch, as well as just-prior to merging
the feature branch into the master branch.</p>
<p>The
<a href="http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/">downside of this workflow is when sharing a feature branch after a rebase</a>.
Pushing to GitHub will require the <code>--force</code> flag, and anyone else working on
the feature branch will see changes to the branch history when they pull an
update. This is why I don’t recommend this workflow for shared feature branches.</p>
<h2>Conclusion</h2>
<p>I see huge benefits in collapsing feature branch commits into the master branch
with — — squash, both for simplicity sake, clarity, and reduces cognitive load
when the master branch maintainer needs to merge in big features. Additionally
it makes the use of git bisect much easier.</p>
<p>I love the advantages to using git rebase to merge in upstream changes while
working on a feature branch, but it seems people need to use the workflow in
practice before they can understand its benefits. Give it a shot, you might like
it.</p>
<p>All three workflows have been published to GitHub</p>
<ul>
<li><a href="https://github.com/0xadada/git-exp-branch-merge-merge/network">Branch-Merge-Merge</a></li>
<li><a href="https://github.com/0xadada/git-exp-branch-merge-mergesquash/network">Branch-Merge-MergeSquash</a></li>
<li><a href="https://github.com/0xadada/git-exp-branch-rebase-merge/network">Branch-Rebase-MergeSquash</a></li>
</ul>
<hr>
<p>This article was originally published on
<a href="https://medium.com/@0xadada/when-to-use-git-merge-vs-git-rebase-264daeec77bd">Medium.com</a></p>
</div><footer class="license_copyright__KOT7N">This is licensed under a Creative Commons <!-- -->cc-by<!-- --> International License</footer></article></main><div class="layout_layout__Xf50c"><footer class="footer_footer__OT4Wn layout_layout__Xf50c"><p>© 2003-<!-- -->2022<!-- --> 0xADADA (unless otherwise noted.)<br/><a title="0xADADA" href="/">Home</a> <span class="h-card"><a class="c-Meta u-email" rel="me" title="0xADADA" href="mailto:0xadada.pub@protonmail.com">Email</a> </span><a rel="me nofollow external noopener" title="0xADADA on Twitter" href="https://twitter.com/0xadada">Twitter</a> <a rel="me nofollow external noopener" title="0xADADA on GitHub" href="https://github.com/0xadada">GitHub</a> <a rel="me nofollow external noopener" title="0xADADA on Goodreads" href="https://www.goodreads.com/review/list/60524683-0xadada?shelf=wanted">Goodreads</a> </p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slugs":{"year":"2015","month":"08","day":"03","slug":"when-to-use-git-merge-vs-git-rebase"},"title":"When to Use Git Merge vs Git Rebase","displayTitle":"When to Use Git Merge vs Git Rebase","metaDescription":"This article will attempt to provide an overview to the different workflows, and explain when merge and rebase are the more appropriate workflow to use.","metaImage":"/static/images/2015-08-03-git-merge-vs-rebase-07.png","date":1438587060000,"author":"0xADADA","content":"\u003cp\u003eI’ve seen many articles and discussions online discussing the merits of merge\nand rebase when integrating parallel branches into the main branch. It seems\nthere are two camps arguing “which is better” when in reality, both have their\nown use cases.\u003c/p\u003e\n\u003cp\u003eThe task we need to accomplish is to determine which workflow is right for your\nproject. This article will attempt to provide an overview to the different\nworkflows, and explain when merge and rebase are the more appropriate workflow\nto use.\u003c/p\u003e\n\u003ch2\u003eThe Simplistic Branch Workflow\u003c/h2\u003e\n\u003ch3\u003eaka the GitFlow / Branch-Merge-Merge Workflow\u003c/h3\u003e\n\u003cp\u003eSoftware development teams have a typical way of doing things, but all have a\nmain integration branch (I’ll call it “Master” for the remainder of this\narticle) that receives feature branches.\u003c/p\u003e\n\u003cp\u003eFeature branches originate from Master, active development is performed along\nthe feature branch, and when the feature is complete, it’s combined back into\nMaster.\u003c/p\u003e\n\u003cp\u003eI call this workflow the\n“\u003ca href=\"http://nvie.com/posts/a-successful-git-branching-model/\"\u003eGitFlow\u003c/a\u003e /\nBranch-Merge-Merge” workflow. The history of events for this simplistic workflow\nare as follows:\u003c/p\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit #1\u003c/li\u003e\n\u003cli\u003ecommit #2\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Feature:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit #a\u003c/li\u003e\n\u003cli\u003ecommit #b\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emerge feature \u003ccode\u003e--no-ff\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis produces the following graph:\u003c/p\u003e\n\u003cfigure\u003e\n    \u003cimg src=\"/static/images/2015-08-03-git-merge-vs-rebase-01.png\"\n      alt=\"Graph of a typical git workflow. Numbered commits occur along Master.\n        Alphabetized commits occur along Feature.\" title=\"Graph of a typical git\n        workflow. Numbered commits occur along Master.  Alphabetized commits occur\n        along Feature.\"\u003e\n  \u003cfigcaption\u003eGraph of a typical git workflow. Numbered commits occur\n  along Master. Alphabetized commits occur along Feature.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eThis workflow performs well for a single developer because while the feature\ndevelopment occurred on the feature branch, the sequence of events occurred\nlinearly. Importantly, no changes occurred on Master while Feature branch was\nchanged.\u003c/p\u003e\n\u003cp\u003eWhen development occurs in parallel on the upstream branch (ie. Master), either\nby the developer, or a co-developer, the history gets more complicated.\u003c/p\u003e\n\u003cp\u003eFor this example, we’ll pretend to be a single developer working on both\nbranches in parallel, we use the following sequence:\u003c/p\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit #1\u003c/li\u003e\n\u003cli\u003ecommit #2\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Feature:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit #a\u003c/li\u003e\n\u003cli\u003ecommit #b\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit #3\u003c/li\u003e\n\u003cli\u003ecommit #4\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egit merge feature \u003ccode\u003e--no-ff\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis produces the following graph:\u003c/p\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"/static/images/2015-08-03-git-merge-vs-rebase-02.png\"\n      alt=\"Typical workflow diagram\" title=\"Typical workflow diagram\"\u003e\n  \u003cfigcaption\u003e\n    Graph of a typical git workflow. Numbered commits occur along Master.\n    Alphabetized commits occur along Feature.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eIn the above scenario the developer runs into the problem where Feature commits\n#a and #b were done independently of Master commits #3, #4 and #5. This merge\nwill fail.\u003c/p\u003e\n\u003cp\u003eTo solve this problem, the developer must first merge the upstream changes in\nMaster into feature branch Feature. To accomplish this, the developer must\nswitch into the feature branch and merge in the changes from Master. The\ndeveloper must then switch back to Master and merge the changes from Feature\ninto Master. Use the following sequence:\u003c/p\u003e\n\u003cp\u003eon Feature:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emerge master\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emerge feature\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis produces the following graph:\u003c/p\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"/static/images/2015-08-03-git-merge-vs-rebase-03.png\"\n      alt=\"Typical workflow diagram\" title=\"Typical workflow diagram\"\u003e\n  \u003cfigcaption\u003e\n    Note how the final git log interleaves the commits on\n    Feature between commits on Master.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eI call this workflow the “Branch-Merge-Merge” workflow because in the most\ngeneral case — the workflow begins with a branch, requires an upstream merge\ninto the feature branch prior to merging the feature branch back into the master\nbranch.\u003c/p\u003e\n\u003cp\u003eLooking at the above graph, feature branch Feature has been merged successfully\ninto Master, but the git log shows an interleaved sequence of commits between\nMaster and Feature that make debugging complex.\u003c/p\u003e\n\u003cp\u003eIn the case where branch Feature introduced a bug into the Master branch, a\nrollback will be difficult because of how the commits are interleaved. In the\ncase where the bug was introduced in Feature branch commit #b, the maintainer of\nMaster branch would need to roll-back commits #6, #c, #5, #4 and #b. This is a\ndifficult roll-back because Master branch features #5 and #4 were rolled back in\nthe effort to roll back to Feature branch feature #b. We’ve thrown some of the\nbaby out with the bathwater.\u003c/p\u003e\n\u003cp\u003eOne way to address the problems with this particular scenario is to merge in the\nFeature branch as a single commit appended to the Master branch, rather than as\na set of interleaved commits within the Master branch. This brings us to the\nnext workflow.\u003c/p\u003e\n\u003ch2\u003eBranch-Merge-MergeSquash Workflow\u003c/h2\u003e\n\u003cp\u003eThis workflow attempts to address the shortcomings of the workflow above by\nappending feature branches as a single commit at the end of the integration\nbranch.\u003c/p\u003e\n\u003cp\u003eFor this example, lets pretend to be a single developer working on both branches\nin parallel (as I did above), we use the following sequence:\u003c/p\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit #1\u003c/li\u003e\n\u003cli\u003ecommit #2\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Feature:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit #a\u003c/li\u003e\n\u003cli\u003ecommit #b\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit #3\u003c/li\u003e\n\u003cli\u003ecommit #4\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Feature:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emerge master\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egit merge feature \u003ccode\u003e--squash\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis produces the following graph:\u003c/p\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"/static/images/2015-08-03-git-merge-vs-rebase-04.png\"\n      alt=\"Typical workflow diagram\" title=\"Typical workflow diagram\"\u003e\n  \u003cfigcaption\u003e\n    The git log sequence of events shows a linear series of\n    feature integrations.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eLooking at the above graph, feature branch Feature has been merged successfully\ninto Master (although the graph doesn’t show a merge line) at commit #5.\nImportantly, the git log shows a linear sequence of commits, each indicating a\ncomplete feature integration. The squash flag has collapsed Feature branch\ncommit #a, #b and #c into single commit #5.\u003c/p\u003e\n\u003cp\u003eIn the case where branch Feature introduced a bug into the Master branch, a\nrollback will be as simple as running \u003ccode\u003egit reset --hard HEAD^\u003c/code\u003e because of how\nthe Feature branch was a single commit appended onto Master. In this scenario,\nthe Master branch maintainer would tell the Feature branch maintainer to fix the\nproblem, and they could attempt the merge once the issue was fixed.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI recommend this workflow\u003c/strong\u003e as a best-practice in cases where the feature\nbranch will be shared (eg. pushed to GitHub, shared with other developers.)\u003c/p\u003e\n\u003cp\u003eA potential downside of this workflow is the potential confusion caused by the\norigin commit of the Feature branch. Feature branch origin is located at commit\n#2, and merged at commit #5. This is additional cognitive load on the Master\nbranch maintainer when it comes time to merge the feature branch into Master. A\nsimplified workflow could solve this by having the Feature branch simulate its\norigin commit at commit #4 prior to merging into Master. This would reduce\ncognitive load on the Master branch maintainer.\u003c/p\u003e\n\u003ch2\u003eBranch-Rebase-MergeSquash Workflow\u003c/h2\u003e\n\u003cp\u003eThis workflow is popular with\n\u003ca href=\"https://nodejs.org/documentation/contributing/\"\u003eopen source projects\u003c/a\u003e where the\njob for the Master branch maintainer involves multiple feature branch\nintegrations on a daily basis.\u003c/p\u003e\n\u003cp\u003eThis workflow is designed to make feature branch merges much simpler and easier\nto roll back. The main idea is that each feature branch is a simple append to\nthe end of the Master branch. No merge is simpler than and append-merge.\u003c/p\u003e\n\u003cp\u003eFor this example, lets pretend to be the same single developer working on both\nbranches in parallel (again, as I did above), we use the following sequence:\u003c/p\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit #1\u003c/li\u003e\n\u003cli\u003ecommit #2\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Feature:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit #a\u003c/li\u003e\n\u003cli\u003ecommit #b\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit #3\u003c/li\u003e\n\u003cli\u003ecommit #4\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eon Feature:\u003c/p\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"/static/images/2015-08-03-git-merge-vs-rebase-05.png\"\n      alt=\"Feature with upstream changes before rebase\"\n      title=\"Feature with upstream changes before rebase\"\u003e\n  \u003cfigcaption\u003e\n    On the Feature branch, the graph appears after\n    commit #2 prior to rebase.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cul\u003e\n\u003cli\u003erebase master\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"/static/images/2015-08-03-git-merge-vs-rebase-06.png\"\n      alt=\"Feature with upstream changes after rebase\"\n      title=\"Feature with upstream changes after rebase\"\u003e\n  \u003cfigcaption\u003e\n    After rebase, Feature branch commits #a and #b originate\n    from parent commit #4\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eWe have now changed the origin commit of branch Feature to commit #4. This sets\nup future merges of the Feature branch to append directly to the end of Master\nbranch.\u003c/p\u003e\n\u003cp\u003eon Master:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emerge feature \u003ccode\u003e--squash\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe’ve now switched to the Master branch, and merged in the rebased Feature\nbranch, appending a single commit #5 to the end of the Master branch containing\nall of the Feature branch.\u003c/p\u003e\n\u003cp\u003eThis produces the final graph:\u003c/p\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"/static/images/2015-08-03-git-merge-vs-rebase-07.png\"\n      alt=\"Feature with upstream changes after rebase\"\n      title=\"Feature with upstream changes after rebase\"\u003e\n  \u003cfigcaption\u003e\n    After merging the Feature into Master, commit #5 containing\n    the final result of all Feature branch commits #a and #b.\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eThe final sequence of events on the Master branch read cleanly, showcasing only\npast feature branch integrations. Each feature branch originated directly from\nthe latest commit, making it seem like the feature is a simple fast-forward\nappend onto the latest commit.\u003c/p\u003e\n\u003cp\u003eIt’s worth pointing out the Branch-Merge-MergeSquash and\nBranch-Rebase-MergeSquash workflows both result in the same final sequence of\ncommits. The major benefit of the Branch-Rebase-MergeSquash workflow is that\nits’ branch origin appears much later in the history, reducing cognitive load on\nMaster branch integrations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI recommend this workflow\u003c/strong\u003e as a\n\u003ca href=\"http://blog.izs.me/post/37650663670/git-rebase\"\u003ebest-practice\u003c/a\u003e when the\ndeveloper is working alone on a feature branch, as well as just-prior to merging\nthe feature branch into the master branch.\u003c/p\u003e\n\u003cp\u003eThe\n\u003ca href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\"\u003edownside of this workflow is when sharing a feature branch after a rebase\u003c/a\u003e.\nPushing to GitHub will require the \u003ccode\u003e--force\u003c/code\u003e flag, and anyone else working on\nthe feature branch will see changes to the branch history when they pull an\nupdate. This is why I don’t recommend this workflow for shared feature branches.\u003c/p\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eI see huge benefits in collapsing feature branch commits into the master branch\nwith — — squash, both for simplicity sake, clarity, and reduces cognitive load\nwhen the master branch maintainer needs to merge in big features. Additionally\nit makes the use of git bisect much easier.\u003c/p\u003e\n\u003cp\u003eI love the advantages to using git rebase to merge in upstream changes while\nworking on a feature branch, but it seems people need to use the workflow in\npractice before they can understand its benefits. Give it a shot, you might like\nit.\u003c/p\u003e\n\u003cp\u003eAll three workflows have been published to GitHub\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/0xadada/git-exp-branch-merge-merge/network\"\u003eBranch-Merge-Merge\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/0xadada/git-exp-branch-merge-mergesquash/network\"\u003eBranch-Merge-MergeSquash\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/0xadada/git-exp-branch-rebase-merge/network\"\u003eBranch-Rebase-MergeSquash\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003eThis article was originally published on\n\u003ca href=\"https://medium.com/@0xadada/when-to-use-git-merge-vs-git-rebase-264daeec77bd\"\u003eMedium.com\u003c/a\u003e\u003c/p\u003e\n","slug":"2015-08-03-when-to-use-git-merge-vs-git-rebase","license":"cc-by"}},"__N_SSG":true},"page":"/[year]/[month]/[day]/[slug]","query":{"year":"2015","month":"08","day":"03","slug":"when-to-use-git-merge-vs-git-rebase"},"buildId":"jDSJqHsQyJoddBl0I99ub","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>