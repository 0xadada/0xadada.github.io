<!DOCTYPE html><html lang="en-US"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="/static/images/2015-08-03-git-merge-vs-rebase-01.png"/><link rel="preload" as="image" href="/static/images/2015-08-03-git-merge-vs-rebase-02.png"/><link rel="preload" as="image" href="/static/images/2015-08-03-git-merge-vs-rebase-03.png"/><link rel="preload" as="image" href="/static/images/2015-08-03-git-merge-vs-rebase-04.png"/><link rel="preload" as="image" href="/static/images/2015-08-03-git-merge-vs-rebase-05.png"/><link rel="preload" as="image" href="/static/images/2015-08-03-git-merge-vs-rebase-06.png"/><link rel="preload" as="image" href="/static/images/2015-08-03-git-merge-vs-rebase-07.png"/><link rel="stylesheet" href="/_next/static/css/60d5ae1a4351e98a.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/01f63581d77a7b07.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-426ae7781c70e24b.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-cc48c28d170fddc2.js" async="" crossorigin=""></script><script src="/_next/static/chunks/69-0a6331c18b0d37aa.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-715e3a652bc6b546.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-d7e0a94ebe194dac.js" async=""></script><script src="/_next/static/chunks/app/page-84b663e6d1625d16.js" async=""></script><script src="/_next/static/chunks/749-1aefd436964833c3.js" async=""></script><script src="/_next/static/chunks/app/layout-8a3d32e7172cce23.js" async=""></script><title>When to Use Git Merge vs Git Rebase</title><meta name="description" content="This article will attempt to provide an overview to the different workflows, and explain when merge and rebase are the more appropriate workflow to use."/><link rel="author" href="https://0xadada.pub"/><meta name="author" content="0xADADA"/><meta name="keywords" content="essays,software-development,version-control"/><link rel="alternate" type="application/rss+xml" href="https://0xadada.pub/rss.xml"/><meta property="og:title" content="When to Use Git Merge vs Git Rebase"/><meta property="og:description" content="This article will attempt to provide an overview to the different workflows, and explain when merge and rebase are the more appropriate workflow to use."/><meta property="og:url" content="https://0xadada.pub/2015/08/03/when-to-use-git-merge-vs-git-rebase/"/><meta property="og:site_name" content="0xADADA"/><meta property="og:locale" content="en_US"/><meta property="og:image" content="https://0xadada.pub/static/images/2015-08-03-git-merge-vs-rebase-07.png"/><meta property="og:image:width" content="800"/><meta property="og:image:height" content="800"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="When to Use Git Merge vs Git Rebase"/><meta name="twitter:description" content="This article will attempt to provide an overview to the different workflows, and explain when merge and rebase are the more appropriate workflow to use."/><meta name="twitter:image" content="https://0xadada.pub/static/images/2015-08-03-git-merge-vs-rebase-07.png"/><meta name="twitter:image:width" content="800"/><meta name="twitter:image:height" content="800"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="48x48"/><link rel="apple-touch-icon" href="/apple-icon.png?b764b3a1dbf00a82" type="image/png" sizes="180x180"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><main class="layout_layout__dCqca"><article class="hentry h-entry"><header><h1 class="entry-title p-name">When to Use Git Merge vs Git Rebase</h1><time class="display-date_published__A_L_d dt-published" dateTime="2015-08-03T00:00:00.000Z">Monday August 3, 2015</time><span class="h-card page_byline__wbXsN"> by <span class="fn p-author p-name">0xADADA</span></span></header><div class="entry-content e-content"><p>I‚Äôve seen many articles and discussions online discussing the merits of merge
and rebase when integrating parallel branches into the main branch. It seems
there are two camps arguing ‚Äúwhich is better‚Äù when in reality, both have their
own use cases.</p>
<p>The task we need to accomplish is to determine which workflow is right for your
project. This article will attempt to provide an overview to the different
workflows, and explain when merge and rebase are the more appropriate workflow
to use.</p>
<h2 id="the-simplistic-branch-workflow">The Simplistic Branch Workflow</h2>
<h3 id="aka-the-gitflow--branch-merge-merge-workflow">aka the GitFlow / Branch-Merge-Merge Workflow</h3>
<p>Software development teams have a typical way of doing things, but all have a
main integration branch (I‚Äôll call it ‚ÄúMaster‚Äù for the remainder of this
article) that receives feature branches.</p>
<p>Feature branches originate from Master, active development is performed along
the feature branch, and when the feature is complete, it‚Äôs combined back into
Master.</p>
<p>I call this workflow the
‚Äú<a href="http://nvie.com/posts/a-successful-git-branching-model/">GitFlow</a> /
Branch-Merge-Merge‚Äù workflow. The history of events for this simplistic workflow
are as follows:</p>
<p>on Master:</p>
<ul>
<li>commit #1</li>
<li>commit #2</li>
</ul>
<p>on Feature:</p>
<ul>
<li>commit #a</li>
<li>commit #b</li>
</ul>
<p>on Master:</p>
<ul>
<li>merge feature <code>--no-ff</code></li>
</ul>
<p>This produces the following graph:</p>
<figure><img src="/static/images/2015-08-03-git-merge-vs-rebase-01.png" alt="Graph of a typical git workflow. Numbered commits occur along Master.
Alphabetized commits occur along Feature." title="Graph of a typical git
workflow. Numbered commits occur along Master.  Alphabetized commits occur
along Feature."/><figcaption>Graph of a typical git workflow. Numbered commits occur
along Master. Alphabetized commits occur along Feature.</figcaption></figure>
<p>This workflow performs well for a single developer because while the feature
development occurred on the feature branch, the sequence of events occurred
linearly. Importantly, no changes occurred on Master while Feature branch was
changed.</p>
<p>When development occurs in parallel on the upstream branch (ie. Master), either
by the developer, or a co-developer, the history gets more complicated.</p>
<p>For this example, we‚Äôll pretend to be a single developer working on both
branches in parallel, we use the following sequence:</p>
<p>on Master:</p>
<ul>
<li>commit #1</li>
<li>commit #2</li>
</ul>
<p>on Feature:</p>
<ul>
<li>commit #a</li>
<li>commit #b</li>
</ul>
<p>on Master:</p>
<ul>
<li>commit #3</li>
<li>commit #4</li>
</ul>
<p>on Master:</p>
<ul>
<li>git merge feature <code>--no-ff</code></li>
</ul>
<p>This produces the following graph:</p>
<figure><img src="/static/images/2015-08-03-git-merge-vs-rebase-02.png" alt="Typical workflow diagram" title="Typical workflow diagram"/><figcaption><p>Graph of a typical git workflow. Numbered commits occur along Master.
Alphabetized commits occur along Feature.</p></figcaption></figure>
<p>In the above scenario the developer runs into the problem where Feature commits
#a and #b were done independently of Master commits #3, #4 and #5. This merge
will fail.</p>
<p>To solve this problem, the developer must first merge the upstream changes in
Master into feature branch Feature. To accomplish this, the developer must
switch into the feature branch and merge in the changes from Master. The
developer must then switch back to Master and merge the changes from Feature
into Master. Use the following sequence:</p>
<p>on Feature:</p>
<ul>
<li>merge master</li>
</ul>
<p>on Master:</p>
<ul>
<li>merge feature</li>
</ul>
<p>This produces the following graph:</p>
<figure><img src="/static/images/2015-08-03-git-merge-vs-rebase-03.png" alt="Typical workflow diagram" title="Typical workflow diagram"/><figcaption><p>Note how the final git log interleaves the commits on
Feature between commits on Master.</p></figcaption></figure>
<p>I call this workflow the ‚ÄúBranch-Merge-Merge‚Äù workflow because in the most
general case‚Ää‚Äî‚Ääthe workflow begins with a branch, requires an upstream merge
into the feature branch prior to merging the feature branch back into the master
branch.</p>
<p>Looking at the above graph, feature branch Feature has been merged successfully
into Master, but the git log shows an interleaved sequence of commits between
Master and Feature that make debugging complex.</p>
<p>In the case where branch Feature introduced a bug into the Master branch, a
rollback will be difficult because of how the commits are interleaved. In the
case where the bug was introduced in Feature branch commit #b, the maintainer of
Master branch would need to roll-back commits #6, #c, #5, #4 and #b. This is a
difficult roll-back because Master branch features #5 and #4 were rolled back in
the effort to roll back to Feature branch feature #b. We‚Äôve thrown some of the
baby out with the bathwater.</p>
<p>One way to address the problems with this particular scenario is to merge in the
Feature branch as a single commit appended to the Master branch, rather than as
a set of interleaved commits within the Master branch. This brings us to the
next workflow.</p>
<h2 id="branch-merge-mergesquash-workflow">Branch-Merge-MergeSquash Workflow</h2>
<p>This workflow attempts to address the shortcomings of the workflow above by
appending feature branches as a single commit at the end of the integration
branch.</p>
<p>For this example, lets pretend to be a single developer working on both branches
in parallel (as I did above), we use the following sequence:</p>
<p>on Master:</p>
<ul>
<li>commit #1</li>
<li>commit #2</li>
</ul>
<p>on Feature:</p>
<ul>
<li>commit #a</li>
<li>commit #b</li>
</ul>
<p>on Master:</p>
<ul>
<li>commit #3</li>
<li>commit #4</li>
</ul>
<p>on Feature:</p>
<ul>
<li>merge master</li>
</ul>
<p>on Master:</p>
<ul>
<li>git merge feature <code>--squash</code></li>
</ul>
<p>This produces the following graph:</p>
<figure><img src="/static/images/2015-08-03-git-merge-vs-rebase-04.png" alt="Typical workflow diagram" title="Typical workflow diagram"/><figcaption><p>The git log sequence of events shows a linear series of
feature integrations.</p></figcaption></figure>
<p>Looking at the above graph, feature branch Feature has been merged successfully
into Master (although the graph doesn‚Äôt show a merge line) at commit #5.
Importantly, the git log shows a linear sequence of commits, each indicating a
complete feature integration. The squash flag has collapsed Feature branch
commit #a, #b and #c into single commit #5.</p>
<p>In the case where branch Feature introduced a bug into the Master branch, a
rollback will be as simple as running <code>git reset --hard HEAD^</code> because of how
the Feature branch was a single commit appended onto Master. In this scenario,
the Master branch maintainer would tell the Feature branch maintainer to fix the
problem, and they could attempt the merge once the issue was fixed.</p>
<p><strong>I recommend this workflow</strong> as a best-practice in cases where the feature
branch will be shared (eg. pushed to GitHub, shared with other developers.)</p>
<p>A potential downside of this workflow is the potential confusion caused by the
origin commit of the Feature branch. Feature branch origin is located at commit
#2, and merged at commit #5. This is additional cognitive load on the Master
branch maintainer when it comes time to merge the feature branch into Master. A
simplified workflow could solve this by having the Feature branch simulate its
origin commit at commit #4 prior to merging into Master. This would reduce
cognitive load on the Master branch maintainer.</p>
<h2 id="branch-rebase-mergesquash-workflow">Branch-Rebase-MergeSquash Workflow</h2>
<p>This workflow is popular with
<a href="https://nodejs.org/documentation/contributing/">open source projects</a> where the
job for the Master branch maintainer involves multiple feature branch
integrations on a daily basis.</p>
<p>This workflow is designed to make feature branch merges much simpler and easier
to roll back. The main idea is that each feature branch is a simple append to
the end of the Master branch. No merge is simpler than and append-merge.</p>
<p>For this example, lets pretend to be the same single developer working on both
branches in parallel (again, as I did above), we use the following sequence:</p>
<p>on Master:</p>
<ul>
<li>commit #1</li>
<li>commit #2</li>
</ul>
<p>on Feature:</p>
<ul>
<li>commit #a</li>
<li>commit #b</li>
</ul>
<p>on Master:</p>
<ul>
<li>commit #3</li>
<li>commit #4</li>
</ul>
<p>on Feature:</p>
<figure><img src="/static/images/2015-08-03-git-merge-vs-rebase-05.png" alt="Feature with upstream changes before rebase" title="Feature with upstream changes before rebase"/><figcaption><p>On the Feature branch, the graph appears after
commit #2 prior to rebase.</p></figcaption></figure>
<ul>
<li>rebase master</li>
</ul>
<figure><img src="/static/images/2015-08-03-git-merge-vs-rebase-06.png" alt="Feature with upstream changes after rebase" title="Feature with upstream changes after rebase"/><figcaption><p>After rebase, Feature branch commits #a and #b originate
from parent commit #4</p></figcaption></figure>
<p>We have now changed the origin commit of branch Feature to commit #4. This sets
up future merges of the Feature branch to append directly to the end of Master
branch.</p>
<p>on Master:</p>
<ul>
<li>merge feature <code>--squash</code></li>
</ul>
<p>We‚Äôve now switched to the Master branch, and merged in the rebased Feature
branch, appending a single commit #5 to the end of the Master branch containing
all of the Feature branch.</p>
<p>This produces the final graph:</p>
<figure><img src="/static/images/2015-08-03-git-merge-vs-rebase-07.png" alt="Feature with upstream changes after rebase" title="Feature with upstream changes after rebase"/><figcaption><p>After merging the Feature into Master, commit #5 containing
the final result of all Feature branch commits #a and #b.</p></figcaption></figure>
<p>The final sequence of events on the Master branch read cleanly, showcasing only
past feature branch integrations. Each feature branch originated directly from
the latest commit, making it seem like the feature is a simple fast-forward
append onto the latest commit.</p>
<p>It‚Äôs worth pointing out the Branch-Merge-MergeSquash and
Branch-Rebase-MergeSquash workflows both result in the same final sequence of
commits. The major benefit of the Branch-Rebase-MergeSquash workflow is that
its‚Äô branch origin appears much later in the history, reducing cognitive load on
Master branch integrations.</p>
<p><strong>I recommend this workflow</strong> as a
<a href="http://blog.izs.me/post/37650663670/git-rebase">best-practice</a> when the
developer is working alone on a feature branch, as well as just-prior to merging
the feature branch into the master branch.</p>
<p>The
<a href="http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/">downside of this workflow is when sharing a feature branch after a rebase</a>.
Pushing to GitHub will require the <code>--force</code> flag, and anyone else working on
the feature branch will see changes to the branch history when they pull an
update. This is why I don‚Äôt recommend this workflow for shared feature branches.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I see huge benefits in collapsing feature branch commits into the master branch
with‚Ää‚Äî‚Ää‚Äî squash, both for simplicity sake, clarity, and reduces cognitive load
when the master branch maintainer needs to merge in big features. Additionally
it makes the use of git bisect much easier.</p>
<p>I love the advantages to using git rebase to merge in upstream changes while
working on a feature branch, but it seems people need to use the workflow in
practice before they can understand its benefits. Give it a shot, you might like
it.</p>
<p>All three workflows have been published to GitHub</p>
<ul>
<li><a href="https://github.com/0xadada/git-exp-branch-merge-merge/network">Branch-Merge-Merge</a></li>
<li><a href="https://github.com/0xadada/git-exp-branch-merge-mergesquash/network">Branch-Merge-MergeSquash</a></li>
<li><a href="https://github.com/0xadada/git-exp-branch-rebase-merge/network">Branch-Rebase-MergeSquash</a></li>
</ul>
<hr/>
<p>This article was originally published on
<a href="https://medium.com/@0xadada/when-to-use-git-merge-vs-git-rebase-264daeec77bd">Medium.com</a></p></div><footer class="license_copyright__EpMnZ">This is licensed under a Creative Commons <!-- -->cc-by<!-- --> International License</footer></article></main><footer class="footer_footer__woFMY layout_layout__dCqca"><nav><p>¬© 2003-<!-- -->2024<!-- --> 0xADADA (unless otherwise noted.)<br/><span class="h-card"><span class="p-note" hidden="">0xADADA is a Software Engineer / Writer / Motorsports Driver exploring the impact of the attention economy on idleness, time, and lived experience. üßë‚Äçüíªüîßüöó‚úçÔ∏èüîí</span><a class="u-url u-uid" title="0xADADA" href="https://0xadada.pub/">0xADADA</a> <a class="c-Meta u-email" rel="me" title="0xADADA" href="mailto:0xadada.pub@protonmail.com">Email</a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on Warpcast" href="https://warpcast.com/0xadada">Farcaster</a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on Mastodon" href="https://mastodon.cloud/@0xADADA">Mastodon</a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on Bluesky" href="https://bsky.app/profile/0xadada.bsky.social">Bluesky</a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on Twitter" href="https://twitter.com/0xadada"><del>Twitter</del></a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on GitHub" href="https://github.com/0xadada">GitHub</a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on Goodreads" href="https://www.goodreads.com/review/list/60524683-0xadada?shelf=wanted">Goodreads</a> <a href="/colophon/">Colophon</a> <a href="/rss.xml">RSS</a> <img alt="0xADADA icon" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="u-photo" style="color:transparent;margin-bottom:-0.125rem" src="/static/images/meta/avatar.svg"/></span></p></nav><form action="https://buttondown.email/api/emails/embed-subscribe/0xadada" method="post" target="popupwindow"><label for="email">Sign up to get emailed when I write new things:<!-- --> </label><input type="email" id="email" name="email"/><input type="submit" value="Subscribe"/></form></footer><script src="/_next/static/chunks/webpack-426ae7781c70e24b.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/60d5ae1a4351e98a.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/01f63581d77a7b07.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"4:I[7690,[],\"\"]\n7:I[5613,[],\"\"]\n9:I[1778,[],\"\"]\na:I[5250,[\"250\",\"static/chunks/250-d7e0a94ebe194dac.js\",\"931\",\"static/chunks/app/page-84b663e6d1625d16.js\"],\"\"]\nb:I[1749,[\"250\",\"static/chunks/250-d7e0a94ebe194dac.js\",\"749\",\"static/chunks/749-1aefd436964833c3.js\",\"185\",\"static/chunks/app/layout-8a3d32e7172cce23.js\"],\"Image\"]\nd:I[8955,[],\"\"]\n8:[\"slug\",\"2015/08/03/when-to-use-git-merge-vs-git-rebase\",\"c\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/60d5ae1a4351e98a.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"6utciVI0xUQP7RUATbUP2\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/2015/08/03/when-to-use-git-merge-vs-git-rebase/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"2015/08/03/when-to-use-git-merge-vs-git-rebase\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"2015\\\",\\\"08\\\",\\\"03\\\",\\\"when-to-use-git-merge-vs-git-rebase\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"2015/08/03/when-to-use-git-merge-vs-git-rebase\",\"c\"],{\"children\":[\"__PAGE__\",{},[\"$L5\",\"$L6\",null]]},[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$8\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/01f63581d77a7b07.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[null,[\"$\",\"html\",null,{\"lang\":\"en-US\",\"children\":[\"$\",\"body\",null,{\"children\":[[\"$\",\"main\",null,{\"className\":\"layout_layout__dCqca\",\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"footer\",null,{\"className\":\"footer_footer__woFMY layout_layout__dCqca\",\"children\":[[\"$\",\"nav\",null,{\"children\":[\"$\",\"p\",null,{\"children\":[\"¬© 2003-\",\"2024\",\" 0xADADA (unless otherwise noted.)\",[\"$\",\"br\",null,{}],[\"$\",\"span\",null,{\"className\":\"h-card\",\"children\":[[\"$\",\"span\",null,{\"className\":\"p-note\",\"hidden\":true,\"children\":\"0xADADA is a Software Engineer / Writer / Motorsports Driver exploring the impact of the attention economy on idleness, time, and lived experience. üßë‚Äçüíªüîßüöó‚úçÔ∏èüîí\"}],[\"$\",\"$La\",null,{\"className\":\"u-url u-uid\",\"href\":\"https://0xadada.pub/\",\"title\":\"0xADADA\",\"children\":\"0xADADA\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"mailto:0xadada.pub@protonmail.com\",\"className\":\"c-Meta u-email\",\"rel\":\"me\",\"title\":\"0xADADA\",\"children\":\"Email\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://warpcast.com/0xadada\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on Warpcast\",\"children\":\"Farcaster\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://mastodon.cloud/@0xADADA\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on Mastodon\",\"children\":\"Mastodon\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://bsky.app/profile/0xadada.bsky.social\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on Bluesky\",\"children\":\"Bluesky\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://twitter.com/0xadada\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on Twitter\",\"children\":[\"$\",\"del\",null,{\"children\":\"Twitter\"}]}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://github.com/0xadada\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on GitHub\",\"children\":\"GitHub\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://www.goodreads.com/review/list/60524683-0xadada?shelf=wanted\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on Goodreads\",\"children\":\"Goodreads\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"/colophon/\",\"children\":\"Colophon\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"/rss.xml\",\"children\":\"RSS\"}],\" \",[\"$\",\"$Lb\",null,{\"className\":\"u-photo\",\"src\":\"/static/images/meta/avatar.svg\",\"alt\":\"0xADADA icon\",\"width\":\"20\",\"height\":\"20\",\"style\":{\"marginBottom\":\"-0.125rem\"}}]]}]]}]}],[\"$\",\"form\",null,{\"action\":\"https://buttondown.email/api/emails/embed-subscribe/0xadada\",\"method\":\"post\",\"target\":\"popupwindow\",\"children\":[[\"$\",\"label\",null,{\"htmlFor\":\"email\",\"children\":[\"Sign up to get emailed when I write new things:\",\" \"]}],[\"$\",\"input\",null,{\"type\":\"email\",\"name\":\"email\",\"id\":\"email\"}],[\"$\",\"input\",null,{\"type\":\"submit\",\"value\":\"Subscribe\"}]]}]]}]]}]}],null]],\"initialHead\":[false,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]]\n"])</script><script>self.__next_f.push([1,"6:[\"$\",\"article\",null,{\"className\":\"hentry h-entry\",\"children\":[[\"$\",\"header\",null,{\"children\":[[\"$\",\"h1\",null,{\"className\":\"entry-title p-name\",\"children\":\"When to Use Git Merge vs Git Rebase\"}],\"$undefined\",[\"$\",\"time\",null,{\"className\":\"display-date_published__A_L_d dt-published\",\"dateTime\":\"2015-08-03T00:00:00.000Z\",\"children\":\"Monday August 3, 2015\"}],[\"$\",\"span\",null,{\"className\":\"h-card page_byline__wbXsN\",\"children\":[\" by \",[\"$\",\"span\",null,{\"className\":\"fn p-author p-name\",\"children\":\"0xADADA\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"entry-content e-content\",\"children\":[[\"$\",\"p\",null,{\"children\":\"I‚Äôve seen many articles and discussions online discussing the merits of merge\\nand rebase when integrating parallel branches into the main branch. It seems\\nthere are two camps arguing ‚Äúwhich is better‚Äù when in reality, both have their\\nown use cases.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The task we need to accomplish is to determine which workflow is right for your\\nproject. This article will attempt to provide an overview to the different\\nworkflows, and explain when merge and rebase are the more appropriate workflow\\nto use.\"}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"the-simplistic-branch-workflow\",\"children\":\"The Simplistic Branch Workflow\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"aka-the-gitflow--branch-merge-merge-workflow\",\"children\":\"aka the GitFlow / Branch-Merge-Merge Workflow\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Software development teams have a typical way of doing things, but all have a\\nmain integration branch (I‚Äôll call it ‚ÄúMaster‚Äù for the remainder of this\\narticle) that receives feature branches.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Feature branches originate from Master, active development is performed along\\nthe feature branch, and when the feature is complete, it‚Äôs combined back into\\nMaster.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"I call this workflow the\\n‚Äú\",[\"$\",\"a\",null,{\"href\":\"http://nvie.com/posts/a-successful-git-branching-model/\",\"children\":\"GitFlow\"}],\" /\\nBranch-Merge-Merge‚Äù workflow. The history of events for this simplistic workflow\\nare as follows:\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #1\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #2\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Feature:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #a\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #b\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"merge feature \",[\"$\",\"code\",null,{\"children\":\"--no-ff\"}]]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This produces the following graph:\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2015-08-03-git-merge-vs-rebase-01.png\",\"alt\":\"Graph of a typical git workflow. Numbered commits occur along Master.\\nAlphabetized commits occur along Feature.\",\"title\":\"Graph of a typical git\\nworkflow. Numbered commits occur along Master.  Alphabetized commits occur\\nalong Feature.\"}],[\"$\",\"figcaption\",null,{\"children\":\"Graph of a typical git workflow. Numbered commits occur\\nalong Master. Alphabetized commits occur along Feature.\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This workflow performs well for a single developer because while the feature\\ndevelopment occurred on the feature branch, the sequence of events occurred\\nlinearly. Importantly, no changes occurred on Master while Feature branch was\\nchanged.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"When development occurs in parallel on the upstream branch (ie. Master), either\\nby the developer, or a co-developer, the history gets more complicated.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"For this example, we‚Äôll pretend to be a single developer working on both\\nbranches in parallel, we use the following sequence:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #1\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #2\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Feature:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #a\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #b\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #3\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #4\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"git merge feature \",[\"$\",\"code\",null,{\"children\":\"--no-ff\"}]]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This produces the following graph:\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2015-08-03-git-merge-vs-rebase-02.png\",\"alt\":\"Typical workflow diagram\",\"title\":\"Typical workflow diagram\"}],[\"$\",\"figcaption\",null,{\"children\":[\"$\",\"p\",null,{\"children\":\"Graph of a typical git workflow. Numbered commits occur along Master.\\nAlphabetized commits occur along Feature.\"}]}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In the above scenario the developer runs into the problem where Feature commits\\n#a and #b were done independently of Master commits #3, #4 and #5. This merge\\nwill fail.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"To solve this problem, the developer must first merge the upstream changes in\\nMaster into feature branch Feature. To accomplish this, the developer must\\nswitch into the feature branch and merge in the changes from Master. The\\ndeveloper must then switch back to Master and merge the changes from Feature\\ninto Master. Use the following sequence:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Feature:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"merge master\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"merge feature\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This produces the following graph:\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2015-08-03-git-merge-vs-rebase-03.png\",\"alt\":\"Typical workflow diagram\",\"title\":\"Typical workflow diagram\"}],[\"$\",\"figcaption\",null,{\"children\":[\"$\",\"p\",null,{\"children\":\"Note how the final git log interleaves the commits on\\nFeature between commits on Master.\"}]}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"I call this workflow the ‚ÄúBranch-Merge-Merge‚Äù workflow because in the most\\ngeneral case‚Ää‚Äî‚Ääthe workflow begins with a branch, requires an upstream merge\\ninto the feature branch prior to merging the feature branch back into the master\\nbranch.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Looking at the above graph, feature branch Feature has been merged successfully\\ninto Master, but the git log shows an interleaved sequence of commits between\\nMaster and Feature that make debugging complex.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In the case where branch Feature introduced a bug into the Master branch, a\\nrollback will be difficult because of how the commits are interleaved. In the\\ncase where the bug was introduced in Feature branch commit #b, the maintainer of\\nMaster branch would need to roll-back commits #6, #c, #5, #4 and #b. This is a\\ndifficult roll-back because Master branch features #5 and #4 were rolled back in\\nthe effort to roll back to Feature branch feature #b. We‚Äôve thrown some of the\\nbaby out with the bathwater.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"One way to address the problems with this particular scenario is to merge in the\\nFeature branch as a single commit appended to the Master branch, rather than as\\na set of interleaved commits within the Master branch. This brings us to the\\nnext workflow.\"}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"branch-merge-mergesquash-workflow\",\"children\":\"Branch-Merge-MergeSquash Workflow\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This workflow attempts to address the shortcomings of the workflow above by\\nappending feature branches as a single commit at the end of the integration\\nbranch.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"For this example, lets pretend to be a single developer working on both branches\\nin parallel (as I did above), we use the following sequence:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #1\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #2\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Feature:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #a\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #b\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #3\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #4\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Feature:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"merge master\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"git merge feature \",[\"$\",\"code\",null,{\"children\":\"--squash\"}]]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This produces the following graph:\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2015-08-03-git-merge-vs-rebase-04.png\",\"alt\":\"Typical workflow diagram\",\"title\":\"Typical workflow diagram\"}],[\"$\",\"figcaption\",null,{\"children\":[\"$\",\"p\",null,{\"children\":\"The git log sequence of events shows a linear series of\\nfeature integrations.\"}]}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Looking at the above graph, feature branch Feature has been merged successfully\\ninto Master (although the graph doesn‚Äôt show a merge line) at commit #5.\\nImportantly, the git log shows a linear sequence of commits, each indicating a\\ncomplete feature integration. The squash flag has collapsed Feature branch\\ncommit #a, #b and #c into single commit #5.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"In the case where branch Feature introduced a bug into the Master branch, a\\nrollback will be as simple as running \",[\"$\",\"code\",null,{\"children\":\"git reset --hard HEAD^\"}],\" because of how\\nthe Feature branch was a single commit appended onto Master. In this scenario,\\nthe Master branch maintainer would tell the Feature branch maintainer to fix the\\nproblem, and they could attempt the merge once the issue was fixed.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"I recommend this workflow\"}],\" as a best-practice in cases where the feature\\nbranch will be shared (eg. pushed to GitHub, shared with other developers.)\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"A potential downside of this workflow is the potential confusion caused by the\\norigin commit of the Feature branch. Feature branch origin is located at commit\\n#2, and merged at commit #5. This is additional cognitive load on the Master\\nbranch maintainer when it comes time to merge the feature branch into Master. A\\nsimplified workflow could solve this by having the Feature branch simulate its\\norigin commit at commit #4 prior to merging into Master. This would reduce\\ncognitive load on the Master branch maintainer.\"}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"branch-rebase-mergesquash-workflow\",\"children\":\"Branch-Rebase-MergeSquash Workflow\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"This workflow is popular with\\n\",[\"$\",\"a\",null,{\"href\":\"https://nodejs.org/documentation/contributing/\",\"children\":\"open source projects\"}],\" where the\\njob for the Master branch maintainer involves multiple feature branch\\nintegrations on a daily basis.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This workflow is designed to make feature branch merges much simpler and easier\\nto roll back. The main idea is that each feature branch is a simple append to\\nthe end of the Master branch. No merge is simpler than and append-merge.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"For this example, lets pretend to be the same single developer working on both\\nbranches in parallel (again, as I did above), we use the following sequence:\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #1\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #2\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Feature:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #a\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #b\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #3\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"commit #4\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Feature:\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2015-08-03-git-merge-vs-rebase-05.png\",\"alt\":\"Feature with upstream changes before rebase\",\"title\":\"Feature with upstream changes before rebase\"}],[\"$\",\"figcaption\",null,{\"children\":[\"$\",\"p\",null,{\"children\":\"On the Feature branch, the graph appears after\\ncommit #2 prior to rebase.\"}]}]]}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"rebase master\"}],\"\\n\"]}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2015-08-03-git-merge-vs-rebase-06.png\",\"alt\":\"Feature with upstream changes after rebase\",\"title\":\"Feature with upstream changes after rebase\"}],[\"$\",\"figcaption\",null,{\"children\":[\"$\",\"p\",null,{\"children\":\"After rebase, Feature branch commits #a and #b originate\\nfrom parent commit #4\"}]}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We have now changed the origin commit of branch Feature to commit #4. This sets\\nup future merges of the Feature branch to append directly to the end of Master\\nbranch.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"on Master:\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"merge feature \",[\"$\",\"code\",null,{\"children\":\"--squash\"}]]}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We‚Äôve now switched to the Master branch, and merged in the rebased Feature\\nbranch, appending a single commit #5 to the end of the Master branch containing\\nall of the Feature branch.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This produces the final graph:\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2015-08-03-git-merge-vs-rebase-07.png\",\"alt\":\"Feature with upstream changes after rebase\",\"title\":\"Feature with upstream changes after rebase\"}],[\"$\",\"figcaption\",null,{\"children\":[\"$\",\"p\",null,{\"children\":\"After merging the Feature into Master, commit #5 containing\\nthe final result of all Feature branch commits #a and #b.\"}]}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The final sequence of events on the Master branch read cleanly, showcasing only\\npast feature branch integrations. Each feature branch originated directly from\\nthe latest commit, making it seem like the feature is a simple fast-forward\\nappend onto the latest commit.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"It‚Äôs worth pointing out the Branch-Merge-MergeSquash and\\nBranch-Rebase-MergeSquash workflows both result in the same final sequence of\\ncommits. The major benefit of the Branch-Rebase-MergeSquash workflow is that\\nits‚Äô branch origin appears much later in the history, reducing cognitive load on\\nMaster branch integrations.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":[[\"$\",\"strong\",null,{\"children\":\"I recommend this workflow\"}],\" as a\\n\",[\"$\",\"a\",null,{\"href\":\"http://blog.izs.me/post/37650663670/git-rebase\",\"children\":\"best-practice\"}],\" when the\\ndeveloper is working alone on a feature branch, as well as just-prior to merging\\nthe feature branch into the master branch.\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"The\\n\",[\"$\",\"a\",null,{\"href\":\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\",\"children\":\"downside of this workflow is when sharing a feature branch after a rebase\"}],\".\\nPushing to GitHub will require the \",[\"$\",\"code\",null,{\"children\":\"--force\"}],\" flag, and anyone else working on\\nthe feature branch will see changes to the branch history when they pull an\\nupdate. This is why I don‚Äôt recommend this workflow for shared feature branches.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"conclusion\",\"children\":\"Conclusion\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"I see huge benefits in collapsing feature branch commits into the master branch\\nwith‚Ää‚Äî‚Ää‚Äî squash, both for simplicity sake, clarity, and reduces cognitive load\\nwhen the master branch maintainer needs to merge in big features. Additionally\\nit makes the use of git bisect much easier.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"I love the advantages to using git rebase to merge in upstream changes while\\nworking on a feature branch, but it seems people need to use the workflow in\\npractice before they can understand its benefits. Give it a shot, you might like\\nit.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"All three workflows have been published to GitHub\"}],\"\\n\",[\"$\",\"ul\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/0xadada/git-exp-branch-merge-merge/network\",\"children\":\"Branch-Merge-Merge\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/0xadada/git-exp-branch-merge-mergesquash/network\",\"children\":\"Branch-Merge-MergeSquash\"}]}],\"\\n\",[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/0xadada/git-exp-branch-rebase-merge/network\",\"children\":\"Branch-Rebase-MergeSquash\"}]}],\"\\n\"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"This article was originally published on\\n\",[\"$\",\"a\",null,{\"href\":\"https://medium.com/@0xadada/when-to-use-git-merge-vs-git-rebase-264daeec77bd\",\"children\":\"Medium.com\"}]]}]]}],[\"$\",\"footer\",null,{\"className\":\"license_copyright__EpMnZ\",\"children\":[\"This is licensed under a Creative Commons \",\"cc-by\",\" International License\"]}]]}]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"When to Use Git Merge vs Git Rebase\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"This article will attempt to provide an overview to the different workflows, and explain when merge and rebase are the more appropriate workflow to use.\"}],[\"$\",\"link\",\"4\",{\"rel\":\"author\",\"href\":\"https://0xadada.pub\"}],[\"$\",\"meta\",\"5\",{\"name\":\"author\",\"content\":\"0xADADA\"}],[\"$\",\"meta\",\"6\",{\"name\":\"keywords\",\"content\":\"essays,software-development,version-control\"}],[\"$\",\"link\",\"7\",{\"rel\":\"alternate\",\"type\":\"application/rss+xml\",\"href\":\"https://0xadada.pub/rss.xml\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:title\",\"content\":\"When to Use Git Merge vs Git Rebase\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:description\",\"content\":\"This article will attempt to provide an overview to the different workflows, and explain when merge and rebase are the more appropriate workflow to use.\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:url\",\"content\":\"https://0xadada.pub/2015/08/03/when-to-use-git-merge-vs-git-rebase/\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:site_name\",\"content\":\"0xADADA\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:locale\",\"content\":\"en_US\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:image\",\"content\":\"https://0xadada.pub/static/images/2015-08-03-git-merge-vs-rebase-07.png\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:image:width\",\"content\":\"800\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:image:height\",\"content\":\"800\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"17\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:title\",\"content\":\"When to Use Git Merge vs Git Rebase\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:description\",\"content\":\"This article will attempt to provide an overview to the different workflows, and explain when merge and rebase are the more appropriate workflow to use.\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:image\",\"content\":\"https://0xadada.pub/static/images/2015-08-03-git-merge-vs-rebase-07.png\"}],[\"$\",\"meta\",\"21\",{\"name\":\"twitter:image:width\",\"content\":\"800\"}],[\"$\",\"meta\",\"22\",{\"name\":\"twitter:image:height\",\"content\":\"800\"}],[\"$\",\"link\",\"23\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"48x48\"}],[\"$\",\"link\",\"24\",{\"rel\":\"apple-touch-icon\",\"href\":\"/apple-icon.png?b764b3a1dbf00a82\",\"type\":\"image/png\",\"sizes\":\"180x180\"}]]\n"])</script><script>self.__next_f.push([1,"5:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>