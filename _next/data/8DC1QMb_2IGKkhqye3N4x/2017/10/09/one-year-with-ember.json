{"pageProps":{"post":{"slugs":{"year":"2017","month":"10","day":"09","slug":"one-year-with-ember"},"title":"One Year with Ember","displayTitle":"One Year with Ember","metaDescription":"Thoughts on Ember after a year of use.","metaKeywords":"javascript, frameworks, web development, software development, progressive web apps,","date":1507580760000,"author":"0xADADA","content":"<p>In early 2015, I was working at an artificial intelligence startup. My team was\nplanning to build a web application to connect to our neural network platform.\nThe team as a whole had experience (on the AI–side) with Python, and the web\nteam had a lot of experience using Django. We'd implemented a hybrid-app in\nCordova using Backbone.js the previous year. My task was to evaluate the\nstate-of-the-art in the frontend development landscape.</p>\n<p>I included React, Angular and Ember to the list of contenders for comparison. We\nread the docs, implemented <a href=\"http://todomvc.com/\">ToDo MVC</a> apps, prototypes, and\nreviewed the community. We produced comparison spreadsheets and went to local\nmeetups. We reviewed design docs and discussed the merits of each approach.\nFinally, we discussed our findings. Both Ember's FastBoot and React's\nserver-side pipeline were not yet ready for production. The Angular community\nwas in flames from the v2 rewrite. Angular 4 was yet another rewrite that was\nshaping up to look disastrous. The core Angular team had abandoned ship. Instead\nof making a final decision on a framework, the team wanted to wait until we\nunderstood more of our applications use cases.</p>\n<p><strong>TL;DR</strong>: We decided to defer the decision. Instead we wrote the app with a\n\"NOJS-first\" approach. The implementation was simple, using HTML forms. Using\nprogressive enhancement, we could add a richer frontend in the future.</p>\n<p>The experience investigating Ember stuck with me. Ember was using web-standards\nand best practices. Convention-over-configuration came from Ruby on Rails. It\nborrowed performance UI rendering strategies from React. It had a first-class\ntesting and documentation story much like Django. Ember was distilling the best\nideas and practices and placing them at the core of their project.</p>\n<p>A year later, our decision was working out well, and the project was humming\nalong. It was well-tested, performant, and had frequent new feature additions. I\ndecided a change of pace would be fun and challenging. The app was in good\nhands.</p>\n<p>When starting my job search, I focused on companies that were using Ember. One\nof the major considerations for my next job was getting my hands deep into\nEmber. In November 2016, I joined a startup using Ember to build a personal\nfinance application.</p>\n<p>Almost a year of working in Ember, I'd like to summarize my thoughts about what\nmakes it a great framework. There are a million articles comparing the big JS\nframeworks; this isn't one of those. This article focuses on what keeps me happy\nabout the decision to continue using Ember.</p>\n<p><strong>Ember feels familiar</strong> to anyone coming from developing basic HTML/JS/CSS\nsites, WordPress, Ruby on Rails apps, or even Django apps. You have template\nfiles, you have JavaScript files, and you have CSS. You're not writing markup,\nJavaScript or CSS in JS files. The templates are much like Mustache. It feels\nlike you're writing code for the web.</p>\n<p><strong>You spend little time in configuration</strong> relative to building application\nfeatures. The framework defaults work well. Ember's architecture is better known\nas “convention-over-configuration”. The core team dedicates time and resources\nto understand how the community uses the framework. This helps them bake-in best\npractices as the defaults.</p>\n<p><strong>There is a single \"Ember way\" of doing things</strong> with the framework. This\naspect of Ember is one of its biggest benefits. When the community grapples with\nproblems that span applications, the core team distills common solutions by\ndefining well-crafted abstractions. It's amazing how quickly an opinionated\nframework can help you see patterns in your project, and solve problems using\nframework abstractions. These abstractions also make it easier to follow best\npractices without thinking about it. Good examples of these are the build\nsystem, the pluggable deployments system, and routing. In the end, developers\nfocus on building features rather than making many small decisions around 3rd\nparty libraries and app configuration.</p>\n<p><strong>Ember has a bigger learning curve</strong> than React, but smaller than Angular. This\nstatement is misleading because Ember is solving more problems than React. React\nis only the 'V' in MVC, while Ember is solving the problem of building complete\napplications. A fair comparison would be between the learning curve of Ember vs\nReact with Redux, Apollo, React Router, Koa, Relay, and Webpack. Ember provides\na solution <em>as well as a converging ecosystem</em> for building modern web\napplications. Ember's design is to solve application-level problems. This means\nno liabilities around custom code that wires libraries together. This design\neliminates a class of problems where library bounderies don't connect. Worse\neven, is when inconsistencies get introduced because libraries have overlapping\nconcerns.</p>\n<p><strong>Web standards are important</strong> in the Ember community. The core team adds new\nfeatures with an eye towards standards organizations such as the W3C and\nECMAScript TC39. Features are first adopted in an Ember-specific way (i.e.\nEmber.RSVP); allowing developers to use these features before the standard has\nlanded. Eventually these \"welcome mats\" get replaced with the final\nstandards-based implementations. This ensures that the framework will not only\nkeep pace with, but stay ahead of and influence the standardization process.\nThis also adds a degree of future-proofing into the framework.</p>\n<p><strong>Ember makes it easier to stay up to date</strong> with the latest and greatest\nframework features. With an all-in-one architecture, everything is well tested,\nand works together as versions move ahead. Addon authors can use packages like\n<code>ember-try</code> to test against various versions. Finally, the Ember team takes a\nresponsible approach as it moves along the roadmap\n(<a href=\"https://emberjs.com/statusboard\">it has a roadmap!</a>). The project has a\nlong-term vision, and the core libraries align their roadmaps on a 6-week\nrelease cycle. The release team flags deprecated features and wrapping new ones\nin feature flags. This allows developers to safely test out new APIs and\nresponsibly sunset deprecated ones.</p>\n<p><strong>CSS organization becomes trivial</strong> if you let the CSS follow Ember routes and\ncomponents. Pair any page-oriented CSS with the route-template, and pair the\nmajority of your CSS with components. Combine this with a solid CSS framework\nlike Bootstrap, Foundation, Bulma- and you've made long-term CSS maintenance\neasier.</p>\n<p>After a year of working in Ember, attending EmberConf 2017, visiting meetup\ngroups, and talking with folks in Slack, I'm sold. It's a pleasure to work in,\nand the roadmap ahead points to a bright future. Tree-shaking and improvements\nin static analysis are shaping up to help break the app into smaller pieces for\nfaster delivery over the wire. I look forward to the next year using Ember.</p>\n","slug":"2017-10-09-one-year-with-ember"}},"__N_SSG":true}