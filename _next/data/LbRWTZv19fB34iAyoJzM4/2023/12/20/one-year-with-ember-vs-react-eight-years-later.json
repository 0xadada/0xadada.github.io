{"pageProps":{"post":{"slugs":{"year":"2023","month":"12","day":"20","slug":"one-year-with-ember-vs-react-eight-years-later"},"title":"One (more) Year with Ember: Thoughts on Ember vs React, Eight Years Later","displayTitle":"One (more) Year with Ember: Thoughts on Ember vs React, Eight Years Later","metaDescription":"An examination of the similarities of Ember & React, some thoughts, and a conclusion.","metaKeywords":"ember, react, web development, javascript, frameworks","date":1703084640000,"author":"0xADADA","content":"<p>Six years ago, I <a href=\"https://0xadada.pub/2017/10/09/one-year-with-ember/\">wrote a summary of my experience working with Ember for a year</a>.\nI had been with Cinch Financial for a year, building their web &#x26; mobile apps with\nEmber and Elixir/Phoenix. After Cinch I joined Salsify, a leader in the Ember\necosystem, and shipped some great products built with Ember during my\nfive-year tenure. I built their Catalog Sites product using an Ember admin app\nand a React/Next.js frontend. Building a single product with both frameworks was\nenlightening as it provided a day-to-day experience with both.</p>\n<blockquote>\n<p>Almost a year of working in Ember, I'd like to summarize my thoughts about what\nmakes it a great framework. There are a million articles comparing the big JS\nframeworks; this isn't one of those.</p>\n</blockquote>\n<p>Almost eight years of working in Ember, I'd like to revisit some of the things\nI said about Ember. There are a million articles comparing the big JS\nframeworks, this one is mine.</p>\n<h2>Ember vs React</h2>\n<p>React allows us to create <em>very declarative</em> code, but to do it idiomatically,\nthe way <em>React wants</em> takes quite a bit of experience and refinement to\n<em>do it the right way</em>.\nWhen examining purely declarative code, especially to the uninitiated, it can\nbe hard to comprehend when states are responding to events, and what their\ndownstream effects are. React code can be very composable, and their <code>useEffect</code>,\n<code>useCallback</code>, <code>useState</code> primitives can be combined to create a wide variety\nof functionality from these granular affordances.</p>\n<p>With the composability of hooks, however, comes a level of complexity. We spend\na lot of time thinking through how different code is going to run, when it was\ngoing to run, and how it could potentially interact with other hooks and code\naround it. It all makes sense in the end, and it’s also declarative, but it’s\na bit harder to follow the intent all the way through.</p>\n<p>React (for most of us) is usually only legible in motion, not at rest. This is\nto say that the only way to figure out how a given piece of React code works is\nby prodding it through use, it's not enough to just read it.</p>\n<p><strong>Differences in developer feeling of focus</strong> Reacts dogmatic re-running of a\ncomponent when its state changes forces developers to consider <em>all</em> starting\nand possible states, and their dependencies. It requires juggling a lot of\ncontext on the part of the developer, and that is why <em>reducing state to the\nminimum</em> is considered a best practice.\nBy contrast, Embers autotracking makes component development <em>feel</em> a lot\nless complicated, and <strong>an Ember developer can focus more on intent while React\ndeveloper <em>feels</em> they must focus more on exactitude</strong>.\nThese are just feelings, but they’re there.</p>\n<p><strong>Ember is more baroque</strong> with its <code>@action</code> and <code>@tracked</code> decorators,\nits template control logic with <code>{{#if}} {{#each list of |item|}}</code> and\nits native classes. With this baroque-ness however, comes an additional level\nof legibility one gets from reading Ember code. Ember code feels familiar\neverywhere, and separating arguments(props) from attributes really helped to\nclarify intent.</p>\n<p><em>Ember suffers from a small and shrinking ecosystem</em>. This could be due to\nearly technical decisions that required all 3rd-party Ember npm packages\nto specifically adhere to Ember addon requirements. This meant that regular\nnpm packages couldn’t be used in Ember apps until <code>ember-auto-import</code> arrived,\nand later, Embroider. Unfortunately this means most Ember addons aren’t\ncompatible with the wider javascript ecosystem, and many Ember packages\nlanguish or are abandoned once maintainers move away from Ember. This means\nthe Ember core-team is burdened with adopting these orphaned packages or risk\nlosing them to the shifting sands of time.</p>\n<h3>Direct Comparison</h3>\n<p>When speaking to Ember devs about React, or React devs about Ember, I frequently\nuse this chart to map concepts in one to the other:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>Concept</strong></th>\n<th align=\"left\"><strong>Ember</strong></th>\n<th align=\"left\"><strong>React</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><strong>File structure</strong></td>\n<td align=\"left\">Convention<br /><code>app/components/component.js</code>, <code>app/components/template.hbs</code></td>\n<td align=\"left\">Configuration<br />use <code>import</code> to bring files from wherever, file may contain both logic and template.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Component primative</strong></td>\n<td align=\"left\">JavaScript classes</td>\n<td align=\"left\">JavaScript functions</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Rendering</strong></td>\n<td align=\"left\">Glimmer VM</td>\n<td align=\"left\">React DOM</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>State transition detection</strong></td>\n<td align=\"left\"><code>@tracked</code> decorator with autotracking provided by the framework</td>\n<td align=\"left\"><code>React.useState()</code> function with dependency keys and memoization</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Component lifecycle</strong></td>\n<td align=\"left\">Use the classes <code>constructor()</code> to initialize the component for first-render and reuses that instance for the life of the component.</td>\n<td align=\"left\">Components are pure functions, relies on memoization or <code>useEffect</code> to run code conditionally after initial render.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Event handling</strong></td>\n<td align=\"left\"><code>@action</code> decorator to bind context to event callback functions that respond to user inputs, event handler must be referred to in templates using Ember modifiers e.g. <code>{{on 'click' (fn this.handleEvent value)}}</code> and use the <code>fn()</code> helper to bind arguments to the callback.</td>\n<td align=\"left\">Pure function callbacks that are lexically in-scope and bound using standard closure <code>onClick={() => handleEvent(value)}</code> style invocations.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Template lexical scope</strong></td>\n<td align=\"left\">Double curly <code>{{this.value}}</code> which requires <code>this</code> to reference lexically scoped variables available in the class.</td>\n<td align=\"left\">Single curly interpolation <code>value={value}</code> which is directly bound to the functions lexical scope.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Template interpolation</strong></td>\n<td align=\"left\">Sigils <code>@value={{this.value}}</code> to distinguish component arguments from standard HTML attributes. Ember requires using <code>...attributes</code> to spread HTML attributes to HTML tags. Use <code>{{yield}}</code> to render child components.</td>\n<td align=\"left\">No difference between component props and HTML attributes.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Template Control Logic</strong></td>\n<td align=\"left\">handlebars/HTMLbars<br />iteration<br /><code>{{#each @list as item}}&#x3C;Item />{{/each}}</code><br />conditionals<br /><code>{{#if true}}its true{{else}}not true{{/if}}</code></td>\n<td align=\"left\">pure javascript<br />iteration<br /><code>lilst.map(item => &#x3C;Item />)</code><br />conditionals<br /><code>{item.isTrue ? &#x3C;TrueItem /> : &#x3C;FalseItem />}</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Global State Management</strong></td>\n<td align=\"left\">Ember Services</td>\n<td align=\"left\">React Context API</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Application Routing</strong></td>\n<td align=\"left\">Ember Router</td>\n<td align=\"left\">React-Router (not built-in)</td>\n</tr>\n</tbody>\n</table>\n<h2>Eight Years On</h2>\n<p>Revisiting <a href=\"https://0xadada.pub/2017/10/09/one-year-with-ember/\">my original post</a>,\nI'd like to provide some updates to that thinking:</p>\n<blockquote>\n<p>Ember feels familiar…</p>\n</blockquote>\n<p>Ember still feels familiar, <em>especially</em> for teams that work across many Ember\nrepos. <strong>Ember teams are very productive because of Embers\nconvention-over-configuration approach</strong>.\nAn Ember app is an Ember app is an Ember app. <strong>This familiarity isn’t always\ntypical with React apps</strong>. React apps are to-each-their-own, and teams need to\nspend time to make their apps feel familiar enough to be seamless when moving\nbetween repos.</p>\n<blockquote>\n<p>There is a single \"Ember way\" of doing things…</p>\n</blockquote>\n<p>This isn’t as true as it used to be. Ember is wonderfully backwards compatible,\nbut that also puts it into an awkward position when it comes to writing\nidiomatic Ember applications: It has become very difficult to discern\n<em>what is idiomatic Ember</em>, especially in real-world app ecosystems where you\nmay have apps using Ember (classic) or Ember Octane, or an in-between state.\nOngoing projects like template imports will make Ember apps even more difficult\nto determine what is \"idiomatic\".</p>\n<p>At Salsify, there are a handful of Ember-gurus who shepherd the engineering org\ntowards idiomatic Ember, but the average engineer doesn't necessarily know when:</p>\n<ul>\n<li><code>Ember.get/set</code> vs. native getters/setters</li>\n<li><code>Component.extend({})</code> vs <code>class Component extends Component {}</code></li>\n<li>invoke component with <code>{{my-component}}</code> or <code>&#x3C;MyComponent /></code></li>\n<li>render a value with <code>{{value}}</code> or <code>{{this.value}}</code> or <code>{{@value}}</code></li>\n<li>when to use <code>@tracked</code> or <code>@action</code></li>\n</ul>\n<p>The <a href=\"https://ember-learn.github.io/ember-octane-vs-classic-cheat-sheet/\">Ember cheat sheet</a>\nis a great resource, but its there because people aren’t confidant. Tools like\n<code>eslint</code>, <code>prettier</code>, <code>stylelint</code> and others help migrating to idiomatic\nconventions.</p>\n<h2>Concluding</h2>\n<p>Ember and React are both great. There are tradeoffs on both sides. The answer\nis always <em>it depends</em>. Ember is an amazing upleveler for bigger teams with\nnovice and expert developers working across multiple codebases building\nambitious applications. React is elegant in its simplicity, can be pure and\nprecise. React has an amazing ecosystem, and is used to create enterprise\napplications. Ember has a larger API surface area, and while it seems to\nhave a higher learning curve, I’d argue that it takes longer for an engineer\nto become an expert at React: <em>one having the ability to see the forest\nfor the trees.</em></p>\n","slug":"2023-12-20-one-year-with-ember-vs-react-eight-years-later","license":"cc-by-nc-sa"}},"__N_SSG":true}