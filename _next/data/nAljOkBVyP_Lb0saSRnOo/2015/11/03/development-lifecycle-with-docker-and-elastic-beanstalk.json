{"pageProps":{"post":{"slugs":{"year":"2015","month":"11","day":"03","slug":"development-lifecycle-with-docker-and-elastic-beanstalk"},"title":"Development Lifecycle with Docker and Elastic Beanstalk","displayTitle":"Development Lifecycle with Docker and Elastic Beanstalk","metaDescription":"This article explains the advantages of using Docker over automated configuration management tools, and describes a workflow from development through QA and into production deployment using Amazons' Elastic Beanstalk.","metaKeywords":"docker, elastic beanstalk, amazon aws, python, django, development, lifecycle, engineering, workflow","date":1446537300000,"author":"0xADADA","content":"<p>Docker is getting a lot of hype these days, for good reason. There are plenty of\narticles touting the merits of Docker but most are written without context and\nare limited to examining the the benefits of Docker independently of its'\npractical everyday use in a software development project lifecycle.</p>\n<p>This article aims to examine the benefits of Docker within the context of a\nsoftware company with multiple developers working on multiple projects, having\nto manage these projects deployed in a cloud production environment. In this\ncontext the benefits of Docker become more readily apparent.</p>\n<p>With the rise of cloud computing, the number of systems that need to be\nmaintained has exploded. Manual <em><a href=\"#provisioning\">provisioning</a></em> of an\nincreasingly large number of systems becomes impossible for a small team, given\nplatforms like Amazon EC2 provide <em><a href=\"#autoscaling\">auto-scaling</a></em> when additional\nload is detected.</p>\n<p>Tools like Ansible, Chef, Puppet and Salt are great solutions towards achieving\nautomated provisioning of virtual machines. The industry has responded by\nquickly adopting these tools, but even more agility and performance can be\nachieved by using <em><a href=\"#docker-container\">Docker containers</a></em>.</p>\n<p>Combining Docker with a deployment tool like AWS Elastic Beanstalk can provide\neven greater efficiencies for developing and deploying cloud applications.</p>\n<h2>Dockdj</h2>\n<p><img src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f6a2.png\" alt=\"Dockdj\"></p>\n<p>This article will be using <a href=\"https://github.com/0xadada/dockdj\">Dockdj</a> to\nillustrate using Docker and Elastic Beanstalk in the context of a real-world web\nproject. Dockdj is a recipe for building 12-factor Python / Django web apps with\nmulti-container Docker and deploying to Amazon AWS using Elastic Beanstalk.\n<a href=\"https://github.com/0xadada/dockdj\">Dockdj is available on GitHub</a>.</p>\n<h3>Manual Provisioning</h3>\n<p>The naive approach is <em>manual provisioning</em>: the developer installs Apache and\nassociated system libraries directly on the local development machine, configure\nit according to the WordPress documentation.</p>\n<p>These manual steps will need to be repeated for every additional member of the\ndevelopment team, and again for the production web server. When provisioned\nsoftware is updated or configurations change. All members of the development\nteam and the production systems need to be updated accordingly. Larger teams\ninevitably begin experiencing the <em>\"works on my machine\"</em> problems between\ndevelopers when some developers haven't updated their configurations to match\ncoworkers who have.</p>\n<p>Manual provisioning quickly becomes a frequent and resource-intensive process,\nwith the side-effect of prolonging the deployment of important vendor bug fixes\nand security patches across both development and productions systems.</p>\n<p>Additionally, when increased traffic hits productions systems, new systems need\nto be allocated and scaled horizontally to support the new traffic. All the\nprovisioning needs to repeated. This system doesn't scale as more production\nservers are added to serve additional traffic load.</p>\n<p>Even worse is when differences between developer-systems and production-systems\nresult in hard-to-reproduce bugs once the app is deployed from development into\nproduction.</p>\n<h3>Automated Provisioning</h3>\n<p>An improvement over manual provisioning is <em>automated provisioning</em> using a\n<em><a href=\"#confg-mgmt\">configuration management</a></em> tool like Ansible, Chef, Puppet, Salt,\netc. These tools have been developed to address the problems of provisioning at\nlarge scale.</p>\n<p>The aim of these tools are:</p>\n<ol>\n<li>Initialize and start virtual machines</li>\n<li>Automate the provisioning process in a repeatable way</li>\n<li>Manage changes to provisioning in a version control system</li>\n<li>Establishing and maintaining consistency of system dependencies and\nconfiguration throughout an applications life</li>\n</ol>\n<p>Configuration management tools are wonderful for automated provisioning, but <em>in\npractice</em><sup><a href=\"#user-content-fn-1\" id=\"user-content-fnref-1\" data-footnote-ref aria-describedby=\"footnote-label\">1</a></sup> they tend to\nsplit management of the stack-app into two parts:</p>\n<ol>\n<li>the software Stack</li>\n</ol>\n<ul>\n<li>Operating system</li>\n<li>System libraries</li>\n<li>Provisioned software</li>\n<li>Configuration</li>\n</ul>\n<ol>\n<li>the Application</li>\n</ol>\n<ul>\n<li>Source code &#x26; binaries</li>\n<li>Dependencies</li>\n<li>Runtime environment</li>\n</ul>\n<p>The result is that the stack (#1) is initially allocated and provisioned using\none of the configuration management tools. The application (#2) is then deployed\non the stack— resulting in a running application. When subsequent\napplication versions (#2) are released and deployed, they are deployed onto the\n(unchanged) stack. <strong>The problem with this model is that the stack and the\napplication are managed independently.</strong> Changes to the stack are managed as a\nunit separate from changes to the application. No data is recorded that\ndescribes the compatibility of the integrated whole.</p>\n<p>This results in increased complexity during rollbacks or simultaneous updates to\nboth stack and application. More importantly <strong>version numbers of the\napplication are not tied to versions of the stack.</strong></p>\n<p>Under this model, the stack version and application version aren't\ncoupled— which increases the likelihood of integration failures.</p>\n<p>An example will illustrate where this model will fail:</p>\n<blockquote>\n<p>Our production web server is provisioned with Apache 3.3.0 and the application\n(WordPress) was at version 0.7.0 last week, and have just released version\n0.8.0 this past week.</p>\n<p>Apache announces a security vulnerability fix at version 3.3.1. Under the\n(typical) automated provisioning model, the configuration management tool\nwould be updated to provision the new version of Apache. The tool runs against\nall production server systems. Here the application doesn't change, it simply\nrides on top of the Apache stack without change. No problems occur with the\nrollout of the new Apache release.</p>\n<p>Next the application updates and releases a new version for deployment- 0.9.0.\nThe deploy process runs, and for some reason the application fails, it isn't\ncompatible with version 3.3.1 of Apache.</p>\n<p>The decision is made to rollback the application to 0.8.0, which runs\nsuccessfully with Apache 3.3.1. The system is working again.</p>\n<p>A critical security vulnerability is discovered in application 0.8.0 and the\ndecision is made to roll application back to version 0.7.0. (Keep in mind the\nprevious app version 0.7.0 was running Apache 3.3.0, and the stack is\ncurrently 3.3.1).</p>\n<p>The application fails— because 0.7.0 was never integration tested\nagainst Apache 3.3.1. What do you do?</p>\n</blockquote>\n<p>In this example the devops team <strong>failed to remember</strong> to rollback Apache,\nsimply because the integrated dependencies were not internally coupled. The\ncompatible coupling existed <strong>only as institutional knowledge</strong> outside the\nscope of the configuration management system, as Stack and Application were\nmanaged separately.</p>\n<h2>Docker for Configuration Management</h2>\n<p>One major advantage of Docker is that it does not necessitate running a unique\nVM<sup><a href=\"#user-content-fn-2\" id=\"user-content-fnref-2\" data-footnote-ref aria-describedby=\"footnote-label\">2</a></sup> for every project a team works on.\nIf developers work on multiple projects, each with its own customized VM,\nswitching between projects becomes a time-consuming context shift for\ndevelopers.</p>\n<p>Docker containers run directly on the Linux operating system and yet each\ncontainer is isolated. This eliminates the slowness of booting and the overhead\nof a VM. Docker containers start up as quickly as running a normal process, and\neliminate VM \"booting\" for every Docker project the developer works on.\nDeploying changes to the environment for every developer working on the project\nis as easy as publishing a new <em><a href=\"#docker-image\">Docker image</a></em>. Next time a\ndeveloper starts the container, he/she will get the new image.</p>\n<p>Another advantage of Docker over an automated configuration management tool is\nthat it <strong>does not</strong> bifurcate the stack and the application into independent\nsegments.</p>\n<p>A stack using Docker containers has the same benefit of configuration\nmanagement, but can couple the stack and the application into a single managed\ncomponent. The application is deployed along with its stack— and the\ncomplete stack-app component is deployed together as a single Docker image or a\nbundle of Docker images that have already been integration tested at least on a\ndevelopers machine.</p>\n<p>As opposed the the \"automated provisioning\" model, the Docker model of the\nstack-app looks more like this:</p>\n<ol>\n<li>Set of Docker images</li>\n</ol>\n<ul>\n<li>Operating system (the software Stack)</li>\n<li>Provisioned software (the software Stack)</li>\n<li>Configuration (the software Stack)</li>\n<li>System libraries (the software Stack)</li>\n<li>Source code &#x26; binaries (Application)</li>\n<li>Dependencies (Application)</li>\n<li>Runtime environment (Application)</li>\n</ul>\n<p>With every deployment, the entire stack-app (1) will be deployed. Docker uses\nhashes (like Git) to minimize the amount of data that will be downloaded for any\nupdate. This means only the differences are downloaded rather than the entire\nstack.</p>\n<p><strong>The greatest advantage of using Docker is that developers can run the\napplication in the very same environment as production</strong>. According to\n<a href=\"http://12factor.net/dev-prod-parity\">Twelve-Factor Methodology</a> this is called\nachieving \"Dev/Prod Parity\". This is a huge benefit in that it eliminates an\nentire class of bugs that result from differences between\ndevelopers-and-developers as well as bugs that result from differences between\ndevelopers-and-production.</p>\n<h2>Elastic Beanstalk for Deployment</h2>\n<p>If you know <a href=\"https://www.heroku.com/\">Heroku</a>, than Amazons' Elastic Beanstalk\nwill be extremely familiar. EB borrows many ideas from Heroku, but the killer\nfeature is its' ability to dynamically run, deploy and scale Docker containers\non a cluster of servers. It handles hardware allocation, network configuration,\nload balancing, auto-scaling, health monitoring and rolling deployments.</p>\n<p>EB doesn't do everything, but it's good enough to adopt early and use until your\nteam understands its deployment use-cases more clearly and understands\nlimitations of EB and its trade-offs.</p>\n<h2>Django specific structure</h2>\n<p>The core structure of the Docker / Elastic Beanstalk app can be explained by\ndescribing the directory structure.</p>\n<p>These comments describe the application-specific file structure:</p>\n<pre><code>.dockerignore\n.ebextensions/\n  01_envvars.config\n.ebignore\n.elasticbeanstalk/\nDockerrun.aws.json\n.gitignore               # Describes which files git ignores\n.bowerrc                 # Configures where web frontend dependencies live\n.csslintrc.json          # Describes CSS syntax rules\n.jshintrc                # Describes JavaScript syntax rules\nbower.json               # Describes web frontend dependencies\ngulpfile.js              # Describes app build and dev tasks\npackage.json             # Describes NPM dependencies\napp/                     # Our python app\n  apps/*                 # python app modules\n  project/*              # App-specific settings\n  dist/*                 # App static assets (served via Nginx)\nbin/*\ndocker/\n  django/\n    dev/\n      docker-compose.yml\n      Dockerfile\n    prod/\n      docker-compose.yml\n      Dockerfile\n      gunicorn.conf.py   # Settings for production app-server\n    start.sh             # Script to start app-server\n  nginx/*                # Nginx config files\nenvironments/            # Environment-specific settings\n  dev/                   # Development-only environment settings\n    .env                 # Actual environment vars (Excluded from git)\n    .env.example         # Example environment vars\n    Procfile             # Configures how Honcho starts app-servers\n    requirements.txt     # Describes dev Python dependencies\n  prod/                  # Development-only environment settings\n    .env                 # Actual environment vars (Excluded from git)\n    .env.example         # Example environment vars\n    Procfile             # Configures how Honcho starts app-servers\n    requirements.txt     # Describes prod Python dependencies\n</code></pre>\n<p>Some of these directories and files are described in more depth below:</p>\n<h3>.gitignore</h3>\n<pre><code>environments/*/.env\nnode_modules\n.elasticbeanstalk/*\n!.elasticbeanstalk/*.cfg.yml\n!.elasticbeanstalk/*.global.yml\n# Built testing and static asset artifacts\napp/dist\n</code></pre>\n<p>Files matching the name <code>environments/*/.env</code> contain sensitive information\n(usernames, passwords, etc) about per-deployment environments that shouldn't be\nincluded in version control.</p>\n<p>The <code>node_modules</code> directory and will be created when the developer installs NPM\npackages. These are dependencies and should not be committed into the source\ncode repository.</p>\n<p>The <code>.elasticbeanstalk/*</code> directory is excluded from Git because it contains\nfiles that are generated by EB command-line during environment creation and\nversion deployment that shouldn't be written to the repository. It also contains\ntemporary configuration files (written by the EB cli).</p>\n<p>Both <code>!.elasticbeanstalk/*.cfg.yml</code> and <code>!.elasticbeanstalk/*.global.yml</code>\nentries use the \"NOT\" operator to re- include themselves into the repo. These\nfiles can be useful to have in version control, as they contain useful\nenvironment configuration settings.</p>\n<h3>bower.json</h3>\n<p>Bower is a web frontend package management system. The application declares its\nfrontend dependencies in this file.</p>\n<p>During docker image creation, these dependencies are installed.</p>\n<h3>gulpfile.js</h3>\n<p>Gulp.js is a task runner for Node.js. <code>gulpfile.js</code> defines common tasks and\nutilities related to this application:</p>\n<ul>\n<li>Running code Syntax checking &#x26; automated testing</li>\n<li>SASS and CSS compilation and minification</li>\n<li>Frontend asset building</li>\n</ul>\n<h3>package.json</h3>\n<p>NPM is a package management system for Node.js applications. <code>package.json</code> The\napplication declares its Node.js dependencies in this file.</p>\n<h3>app/</h3>\n<p>The <code>app/</code> directory contains all source code related to the Django python web\napplication.</p>\n<h3>docker/django/prod/gunicorn.conf.py</h3>\n<p>This project uses two application servers, <code>runserver_plus</code> during development\nand <code>gunicorn</code> in production.</p>\n<p>These are settings related to the Gunicorn application server. In production, a\nmore performant application is used, requiring this configuration file.</p>\n<h3>docker/nginx/sites-enabled.conf</h3>\n<p>On production systems, where nginx acts as a reverse-proxy for the Gunicorn web\napplication, we use Docker links to connect the two containers together. This\nconfiguration is best for reducing latency. Inside our nginx config file, we can\nuse a named entry for the <code>proxy_pass</code> value to reference our Django application\nserver running in another container on port 8080.</p>\n<pre><code># ...\nlocation / {\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header Host $http_host;\n    proxy_redirect   off;\n    proxy_pass       http://django:8080;\n    # ...\n</code></pre>\n<h3>docker/django/start.sh</h3>\n<pre><code>cd /var/app\n# ...\nhoncho --procfile \"environments/$ENV_NAME/Procfile\" \\\n       --env \"environments/$ENV_NAME/.env\" start\n</code></pre>\n<p><code>start.sh</code> is used during both development and production as a single task to\nbootstrap the application server. It uses the <code>honcho</code> task runner to start the\nserver according to a set of tasks in a <code>Procfile</code> for development and another\nfor production.</p>\n<p>The <code>--env</code> parameter is used to pass environment variables sourced from the\nenvironments subdirectory. At runtime, the <code>$ENV_NAME</code> variable will be set:\n<code>dev</code> for development and <code>prod</code> for production. This way a separate Procfile\nand separate set of environment variables are available to configure the modes\nindependently.</p>\n<h3>environments/dev/Procfile</h3>\n<pre><code># The webserver: Python\nwebserver: cd app &#x26;&#x26; ./manage.py runserver_plus 0.0.0.0:8080\n# The CDN assets emulation server\ncdnserver: cd /var/app/app/dist &#x26;&#x26; python -m http.server 8010\n</code></pre>\n<p>During development, the Django <code>runserver_plus</code> application server interprets\nPython, while a simple HTTP server serves assets (images, CSS, etc).</p>\n<h3>environments/prod/Procfile</h3>\n<pre><code class=\"language-bash\">webserver: cd app &#x26;&#x26; gunicorn \\\n  -c /etc/gunicorn/gunicorn.conf.py project.wsgi:application\n</code></pre>\n<p>In production, we use Gunicorn to serve the python application, so the only task\nrun is the gunicorn app server. Static assets aren't handled here because Nginx\nwill be reverse-proxying the application and also serving static assets.</p>\n<p>This decision was made because Nginx is optimized to serve static assets and it\nwill reduce load on the application server.</p>\n<h3>environments/[dev | prod]/.env.example</h3>\n<p>Both <code>environments/dev/.env.example</code> and <code>environments/prod/.env.example</code> are\ncommitted into git to provide hints to developers that they should create a\n<code>.env</code> file in the same directory as a place to store environment variables that\nare passed into the application.</p>\n<p>The <code>.env</code> file is excluded from the git repository as it contains sensitive\nusernames passwords and cryptographic information.</p>\n<h3>environments/[dev | prod]/requirements.txt</h3>\n<p>The python utility <code>pip</code> is a package management utility. It uses a file named\n<code>requirements.txt</code> to install all package dependencies. The development\nenvironment adds some useful debugging utilities that shouldn't be included on\nproduction systems, so production has its own file.</p>\n<p>During docker image creation, these dependencies are installed.</p>\n<h2>Docker specific structure</h2>\n<pre><code>.dockerignore            # Describes which files Docker ignores\n.ebextensions/\n  01_envvars.config\n.ebignore\n.elasticbeanstalk/\nDockerrun.aws.json\n.gitignore\n.bowerrc\n.csslintrc.json\n.jshintrc\nbower.json\ngulpfile.js\npackage.json\napp/\n  apps/*\n  project/*\n  dist/*\nbin/*                    # Scripts for Docker, build and deployment\ndocker/                  # Configuration files required by docker\n  django/                # Django related settings\n    dev/                 # Development-only settings\n      docker-compose.yml # Orchestrates dev containers\n      Dockerfile         # Builds dev Docker image\n    prod/                # Production-only settings\n      docker-compose.yml # Orchestrates prod containers\n      Dockerfile         # Builds prod Docker image\n      gunicorn.conf.py\n    start.sh\n  nginx/*\nenvironments/\n  dev/\n    .env\n    .env.example\n    Procfile\n    requirements.txt\n  prod/\n    .env\n    .env.example\n    Procfile\n    requirements.txt\n</code></pre>\n<h3>.dockerignore</h3>\n<p>The <code>.dockerignore</code> file specifies a list of patterns to exclude from the build\ncontext during creation of the Docker image. These files are not required by the\nexecution of the container, and should be removed to reduce the size of the\nfinal image.</p>\n<pre><code>.coverage\n.ebextensions/*\n.elasticbeanstalk/*\n.ebignore\n.dockerignore\n.git\n.gitignore\n.DS_Store\nnode_modules\napp/dist\ndocs\nhtmlcov\nREADME.md\nghostdriver.log\n</code></pre>\n<p>Some notable entries are described below:</p>\n<p>The <code>node_modules</code> directory and will be created when the developer installs NPM\npackages. If the developer is using on OS X, packages compiled on OS X will not\nwork when the container is running in the Linux VM, so this entry ensures that\nnode modules are installed on the host OS independently from the container OS.</p>\n<p><code>.ebextensions/*</code>, <code>.elasticbeanstalk/*</code> and <code>.ebignore</code> are required by the\nElastic Beanstalk deploy process, and are outside the scope of execution of the\nDocker container, and are not required.</p>\n<p>The <code>app/dist</code> directory contains frontend assets served by both Django and\nNginx, and are required by both Django and Nginx containers. Because Amazon ECS\ncannot (currently) directly mount a single volume from one container into\nanother container, we need these files to be deployed directly on the host OS.\nDocker can mount the directory on both Django and Nginx containers as a shared\nvolume. This directory will be deployed by EB, and is thus excluded from Docker.</p>\n<h3>bin/image</h3>\n<p><code>bin/image</code> is a shell script that wraps common Docker commands used to create\nDocker images. There are three major subcommands: <code>build</code>, <code>destroy</code> and\n<code>update</code> all take a single argument, the name of the environment subdirectory of\nthe <code>environments/</code> directory. This will spawn Docker and build, delete or\nrebuild the image as specified by the <code>Dockerfile</code> in the directory\ncorresponding to the final argument.</p>\n<h3>bin/stevedore</h3>\n<p><code>bin/stevedore</code> is a shell script that wraps common Docker commands used to\nstart and stop Docker containers. There are many subcommands, but the most\nuseful are: <code>start</code>, <code>stop</code> and either of the two <code>build</code> commands. All\nsubcommands take take a single argument, the name of the environment\nsubdirectory of the <code>environments/</code> directory. This will spawn Docker and start,\nstop or run the corresponding build process.</p>\n<h3>docker/django/dev/docker-compose.yml</h3>\n<p>This file provides configuration for Docker to orchestrate the management of the\ndevelopment Docker container for the local dev environment.</p>\n<pre><code>django:\n  build: ../../..\n  dockerfile: docker/django/dev/Dockerfile\n  env_file: ../../../environments/dev/.env\n  volumes:\n    - \"../../../app/apps:/var/app/app/apps\"\n    - \"../../../app/dist:/var/app/app/dist\"\n    - \"../../../app/project:/var/app/app/project\"\n    - \"../../../app/manage.py:/var/app/app/manage.py\"\n    - \"../../../environments:/var/app/environments\"\n    - \"../../../gulpfile.js:/var/app/gulpfile.js\"\n  ports:\n    - \"80:8080\"\n    - \"8010:8010\"\n</code></pre>\n<p>It defines one container \"django\", specifying a path to the <code>build</code>-context as\nwell as a path to load the <code>Dockerfile</code>. <code>env_file</code> specifies the path the a\nfile containing all environment variables. A set of volumes to share from the\nhost OS to the container are listed in <code>volumes</code>. Finally <code>ports</code> tells Docker\nwhich ports on the host to map to the container.</p>\n<h3>docker/django/dev/Dockerfile</h3>\n<p>The <code>Dockerfile</code> is a set of instructions for Docker to execute in order to\nproduce a Docker image— a file used to create a Docker container running\nyour application code.</p>\n<pre><code class=\"language-bash\"># ...\n# Install apt, Python then NodeJS dependencies.\nRUN             apt-get update &#x26;&#x26; \\\n                curl -sL https://deb.nodesource.com/setup_0.12 | bash - &#x26;&#x26; \\\n                apt-get install -y nodejs &#x26;&#x26; \\\n                pip install --upgrade pip &#x26;&#x26; \\\n                pip install -r \\\n                    environments/dev/requirements.txt &#x26;&#x26; \\\n                npm update &#x26;&#x26; \\\n                npm install -g gulp &#x26;&#x26; \\\n                npm install &#x26;&#x26; \\\n                gulp\n# Add our initialization script to the image and run it upon startup.\nADD             docker/django/start.sh /\nCMD             [\"/start.sh\"]\n</code></pre>\n<p>In the development Dockerfile, <code>pip</code> and <code>npm</code> commands install the necessary\ndependencies from the <code>environments/dev</code> folder. Finally <code>start.sh</code> is called to\nstart the Django application server.</p>\n<h3>docker/django/prod/docker-compose.yml</h3>\n<p>This file provides configuration for Docker to orchestrate the management of the\nproduction Docker containers. This configuration can be used for testing locally\nprior to deployment to Amazon AWS.</p>\n<pre><code class=\"language-yml\">django:\n  build: ../../..\n  dockerfile: docker/django/prod/Dockerfile\n  env_file: ../../../environments/prod/.env\n  volumes:\n    - \"../../../docker/django/prod/gunicorn.conf.py:/etc/gunicorn/gunicorn.conf.py:ro\"\n    - \"/var/app/app/dist\"\n\nnginx:\n  image: nginx\n  links:\n    - django\n  volumes:\n    - \"../../../docker/nginx/nginx.conf:/etc/nginx/nginx.conf:ro\"\n    - \"../../../docker/nginx/sites-enabled.conf:/etc/nginx/conf.d/default.conf:ro\"\n  volumes_from:\n    - django\n  ports:\n    - \"80:80\"\n</code></pre>\n<p>It defines two containers \"django\" and \"nginx\". \"Django\" is configured quite\nsimilar to the development setup, but doesn't map as many volumes from the host\nOS to the container. In this configuration \"django\" doesn't need to expose a\nport externally, as the \"nginx\" container will expose port 80 externally.</p>\n<p>Importantly, the \"nginx\" container uses <code>links</code> to connect the \"django\"\ncontainer to \"nginx\". This way nginx config files can refer to \"django\" as-if it\nwas another host on the same network with the name \"nginx\".</p>\n<p>Finally, the \"nginx\" container will mount all volumes from the \"django\"\ncontainer with the <code>volumes_from</code> directive, and expose port 80 to the host OS.</p>\n<h3>docker/django/prod/Dockerfile</h3>\n<p>The major difference between the development <code>Dockerfile</code> and the production\nversion is:</p>\n<ul>\n<li>It exposes port 8080 for other containers</li>\n<li>It runs <code>gulp build</code> during image creation</li>\n</ul>\n<p>This Dockerfile also installs production-only Python pip dependencies in\nrequirements.txt.</p>\n<pre><code class=\"language-bash\"># Install apt, Python then NodeJS dependencies.\nRUN             apt-get update &#x26;&#x26; \\\n                curl -sL https://deb.nodesource.com/setup_0.12 | bash - &#x26;&#x26; \\\n                apt-get install -y nodejs &#x26;&#x26; \\\n                pip install --upgrade pip &#x26;&#x26; \\\n                pip install -r \\\n                    environments/prod/requirements.txt &#x26;&#x26; \\\n                npm update &#x26;&#x26; \\\n                npm install -g gulp &#x26;&#x26; \\\n                npm install &#x26;&#x26; \\\n                gulp build\n# Exposes port 8080\nEXPOSE          8080\n</code></pre>\n<p>When Docker runs the image build, it runs <code>gulp build</code>, which runs code-quality,\nunit tests and produces production-ready web frontend assets. This allows for\ntesting prior to deployment, and gives the team an opportunity to fix errors\nbefore they go into the wild.</p>\n<h2>Elastic Beanstalk specific structure</h2>\n<p>Finally, these comments describe files related to Amazons' Elastic Beanstalk:</p>\n<pre><code>.dockerignore\n.ebextensions/           # Describes how EB builds environments\n  01_envvars.config      # Describes env vars for AWS Docker containers\n.ebignore                # Describes how Amazon EB ignores some files\n.elasticbeanstalk/       # Location Amazon EB stores its cli settings\nDockerrun.aws.json       # Describes how to run our containers in AWS\n.gitignore\n.bowerrc\n.csslintrc.json\n.jshintrc\nbower.json\ngulpfile.js\npackage.json\napp/\n  apps/*\n  project/*\n  dist/*\nbin/*\ndocker/\n  django/\n    dev/\n      docker-compose.yml\n      Dockerfile\n    prod/\n      docker-compose.yml\n      Dockerfile\n      gunicorn.conf.py\n    start.sh\n  nginx/*\nenvironments/\n  dev/\n    .env\n    .env.example\n    Procfile\n    requirements.txt\n  prod/\n    .env\n    .env.example\n    Procfile\n    requirements.txt\n</code></pre>\n<h3>.ebextensions/01_envvars.config</h3>\n<p>This file is used by the Elastic Beanstalk command line utilities to pass\nkey-value parameters to Amazon EC2 and ECS. This file is used to store all\nproduction environment variables that are provided to running containers. This\nvariables often vary between deployments.</p>\n<h3>.ebignore</h3>\n<p>When Elastic Beanstalk does a deployment, it creates a zip file of the current\ndirectory, uploads it to Amazon S3, and deploys the files to running EC2\ninstances. Since this project is using Docker images to package the app, we can\nignore most files; with the exception of the <code>app/dist</code> directory— which\nboth \"Django\" and \"Nginx\" containers will need access too.</p>\n<p>The <code>.ebignore</code> file is used to ignore certain files in a project directory.\nThis file works like a <code>.gitignore</code> file.</p>\n<pre><code># Ignore everything!\n*\n# Except for these exclusion patterns required by Amazon ECS\n!Dockerrun.aws.json\n!.ebextensions/*.config\n!.elasticbeanstalk/*.cfg.yml\n!.elasticbeanstalk/*.global.yml\n!app/dist/**\n!docker/**\n</code></pre>\n<p>The only files our EB package should contain are those required by Docker,\nElastic Beanstalk itself, or any files shared between both containers (such as\nthe <code>app/dist</code> directory).</p>\n<p>When you deploy your project directory to Elastic Beanstalk and create a new\napplication version, the EB CLI will not include files specified by the\n<code>.ebignore</code> in the source bundle that it creates. This is useful for creating\nsmaller packages by excluding files that aren't required for running\nproduction-only code.</p>\n<h3>.elasticbeanstalk/</h3>\n<p>Elastic Beanstalk uses this directory to store temp files and configuration\ninformation about the current AWS account, EB Application name and IAM\ncredentials to utilize.</p>\n<h3>Dockerrun.aws.json</h3>\n<p><code>Dockerrun.aws.json</code> is a proprietary Amazon-specific JSON format called a\n\"<a href=\"#task-def\">Task Definition</a>\" used to configure how to manage Docker containers\nrunning on Amazon EC2 Container Service (ECS) platform.</p>\n<pre><code class=\"language-json\">\"containerDefinitions\": [\n{\n    \"name\": \"django\",\n    \"image\": \"0xadada/dockdj:latest\",\n    \"essential\": true,\n    \"memory\": 512,\n    \"mountPoints\": [\n        {\n            \"sourceVolume\": \"gunicorn-conf\",\n            \"containerPath\": \"/etc/gunicorn/gunicorn.conf.py\",\n            \"readOnly\": true\n        }\n    ]\n}\n</code></pre>\n<p>The JSON format is very similar to the docker-compose Yaml format, having a\nnearly 1-to-1 mapping of <code>image</code>, <code>mountPoints</code> to volumes and ports all\ndefined.</p>\n<p>This file is functionally identical to <code>docker/prod/docker-compose.yml</code> in that\nit runs, configures and connects the \"Django\" and \"Nginx\" Docker containers. As\nsuch, changes to the <code>docker-compose.yml</code> file should be mirrored in the\n<code>Dockerrun.aws.json</code> file.</p>\n<h2>Lifecycle</h2>\n<p>New developers to this project simply clone the project from GitHub, install\nDocker (and boot2docker/docker-machine on OS X) and can begin running the app.\nThere is no need to setup a developer environment or create (yet) another VM.</p>\n<h3>Development</h3>\n<p>When the developer starts working on the project from scratch, the only\nrequirement is Docker and a machine capable of running Docker containers (Linux\n3+ or boot2docker/docker-machine).</p>\n<p>Once an organization or developer has adopted Docker for a single project,\nstartup time for other docker projects is drastically reduced as this core\nrequirement has already been met. From that point forward, the projects\nthemselves can define and provision their own dependencies.</p>\n<p>For this project, the next steps required of the developer are as follows:</p>\n<pre><code class=\"language-bash\">git clone &#x3C;PROJECT>\n&#x3C;create .env file>\n.bin/stevedore dev start\n</code></pre>\n<p>The developer is now running the app. Any internal OS configuration, system\nlibraries, software dependencies and provisioning are all handled by the project\nand Docker— transparently to the developer.</p>\n<p>Subsequent context-switches between other projects and this project have been\nreduced to a single command:</p>\n<pre><code class=\"language-bash\">.bin/stevedore dev start\n</code></pre>\n<p>The developer doesn't need to boot up a VM, nor does she/he need to understand\nor start any internal processes or run any commands internal to the VM.</p>\n<p><strong>In development, Docker can be used to lower cognitive load on developers\nswitching between multiple projects.</strong></p>\n<h3>QA</h3>\n<p>In this particular project, QA tests are run during build of the the production\nDocker image via the <code>gulp build</code> task. See\n<a href=\"#dockerdjangoproddockerfile\">the production Dockerfile</a> to view how it calls\nthe gulp task.</p>\n<p>In effect, this will prevent developers or continuous Integration systems from\npublishing a production Docker image to Docker Hub, as the build will trigger a\nDocker image build failure.</p>\n<p>More generally, development teams could create different tags for \"production\"\nreleases and \"development\" Docker image releases. Lets say \"prod\" vs \"dev\".</p>\n<p>Development teams could publish images tagged with \"dev\", to Docker Hub. Other\ndevelopers on the team or members of the QA team could <code>docker pull</code> that tagged\nimage and run their suite of tests on it.</p>\n<p>Using Docker in this manner, dev and QA teams no longer have to keep VM\nconfigurations synchronized, as the OS and other dependencies have been pushed\ndown from VM directly into dependencies within the scope of the project. <strong>This\nhas the effect of reducing manual synchronization and de-necessitating\nout-of-channel communication between development and QA teams about the state of\nthe runtime environment.</strong> This allows for faster, less-error-prone iteration of\nthe runtime environment.</p>\n<h3>Production</h3>\n<p>Developers have iterated on functionality, QA has run tests against the code,\nand the projects is ready for deployment to production.</p>\n<p>At this point, a working Docker image has been run on developers local machines,\nand QA has passed. These three phases could've gone through multiple iterations\nwhile bugs were identified and fixed. The end result is a working Docker image\nexists that has been deemed \"ready\" for production.</p>\n<p>Either manually or as part of a continuous integration tool, the\nproduction-ready Docker image can now be tagged with a release version and\npublished to Docker Hub (or other compatible Docker image repository). Finally,\nthe deploy process needs to update the production servers running our working\napplication stack and run the latest application code.</p>\n<p>These tasks are handled by our <code>bin/deploy</code> script, a wrapper for Docker, Git\nand Elastic Beanstalk. It will tag the latest Docker image, publish the tag to\nDocker Hub, tag the publish the tags to GitHub and use Elastic Beanstalk to\ndeploy both the latest stack and application code:</p>\n<p>(Lets use 1.2.3 as an arbitrary version number for this example)</p>\n<pre><code class=\"language-bash\">bin/deploy release 1.2.3 # Create a release branch and tag the image\nbin/deploy publish 1.2.3 # Publish the Docker image and git branch\n                         # to Docker Hub and GitHub\nbin/deploy deploy 1.2.3  # Use EB to deploy the latest release\n</code></pre>\n<p>The deploy script is a light bash wrapper that automates Git, Docker and Elastic\nBeanstalk commands in an easy-to-reproduce set of short commands.</p>\n<p>Once complete, the Amazon environment will be running your latest application\ncode, as well as any new changes to the container OS, system libraries and\ndependencies. Most importantly, <strong>any changes in provisioning to the stack have\nbeen deployed along with the Docker image</strong>, thus enabling seamless roll-backs.\n<strong>Rolling back the application version will also rollback the stack version</strong>.\nThe application and stack are deployed together.</p>\n<p>Happy cloud computing!</p>\n<h2>Terms</h2>\n<ul>\n<li>\n<p><a name=\"autoscaling\"><em>Auto-scaling</em></a> A method of setting a threshold that\ndetects when the load on a server cluster necessitates adding or removing\nservers in order to optimize the number of servers servicing that load.\nAuto-scaling allows an organization to decrease operating costs by running the\nminimum number of servers required to service its load, and eliminating the\nneed to accurately predict future traffic patterns.</p>\n</li>\n<li>\n<p><a name=\"config-mgmt\"><em>Configuration Management</em></a> Software tools that are\ndesigned to automatically start, provision and configure software on virtual\nmachines rather than have engineers run these steps manually on each server.\nThese tools can be used both locally to create development VMs (virtual\nmachines) as well as in the cloud to create staging and production VMs.</p>\n</li>\n<li>\n<p><a name=\"docker-image\"><em>Docker image</em></a> A docker image is like an executable\nprogram binary. It takes source files and other assets and bundles them\ntogether, and the resulting bundle can be run/executed as a single process on\na Linux machine.</p>\n</li>\n<li>\n<p><a name=\"docker-container\"><em>Docker container</em></a> A docker container is like a\nrunning executable program. It is a running instance of a docker image. Like a\nrunning program, it has a PID, and it is appropriate to call it a process. It\ncan be started and stopped. One docker image can be run many times on one or\nmore machines.</p>\n</li>\n<li>\n<p><a name=\"provisioning\"><em>Provisioning</em></a> The installation and configuration\nof software needed to run an application. E.g. Installing and configuring\nApache and its system libraries in order to run WordPress.</p>\n</li>\n<li>\n<p><a name=\"task-def\"><em>Task definition</em></a> A proprietary JSON format for\ndescribing how Docker containers are run within the Amazon EC2 Cloud Service.\nRead more about\n<a href=\"http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html\">Amazon ECS Task Definitions</a>.\nDocker uses the <a href=\"https://docs.docker.com/compose/yml/\">docker-compose Yaml</a>\nfile to do the same thing.</p>\n</li>\n</ul>\n<section data-footnotes class=\"footnotes\"><h2 class=\"sr-only\" id=\"footnote-label\">Footnotes</h2>\n<ol>\n<li id=\"user-content-fn-1\">\n<p>Configuration management tools can be used to couple both Stack and\nApplication, but experience has has shown that over time, these tools\nare not strongly opinionated, and therefore Stack-App decoupling occurs\norganically over the lifetime of a project. <a href=\"#user-content-fnref-1\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-2\">\n<p>Docker runs on  Linux version 3. In the case where the developer is\nusing OS X, Windows or another non-Linux OS, they'll need to run a Linux\nVM in order to use Docker. However, this single VM will be able to run\nall Docker containers for all Docker projects they use. Tools like\nDocker Machine make working with the Docker VM much simpler. <a href=\"#user-content-fnref-2\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n</ol>\n</section>\n","slug":"2015-11-03-development-lifecycle-with-docker-and-elastic-beanstalk","license":"cc-by-nc-sa"}},"__N_SSG":true}