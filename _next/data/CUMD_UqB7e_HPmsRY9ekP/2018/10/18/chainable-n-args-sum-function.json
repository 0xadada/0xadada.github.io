{"pageProps":{"post":{"slugs":{"year":"2018","month":"10","day":"18","slug":"chainable-n-args-sum-function"},"title":"An Interview Question: Write a chainable n-argument sum function","metaDescription":"Writing a javascript function to sum multiple inputs with chainable invocation","metaKeywords":"javascript","date":1539861180000,"author":"0xADADA","content":"<p>I came across an interesting interview question, along the lines of</p>\n<blockquote>\n<p>\"How would you make this work?\"</p>\n</blockquote>\n<pre><code class=\"language-javascript\">add(2, 5);\n> 7\nadd(2)(5);\n> 7\n</code></pre>\n<p>I thought this was a very interesting question, so took some time last night to\nplay with it.</p>\n<p>Heres what I got:</p>\n<p>A solution to the invocation one isn't tough, theres just the tricky bit to\ncoerce the <code>arguments</code> into an Array, and to handle the case when nothing is\npassed in.</p>\n<pre><code class=\"language-javascript\">let sum = function() {\n  let args = Array.prototype.slice.call(arguments.length ? arguments : [0]);\n  return args.reduce((acc, i) => (acc += i));\n};\n</code></pre>\n<p>Now, to get chained invocation to work, I used <code>bind</code> to generate a new function\nthat would be returned to the caller, allowing for chained invocation. The\ntricky bit is to set the <code>valueOf</code> function to return the sum, so when checked\nfor a value, the function returns a number. I also changed the way i convert\narguments into an array by using the spread <code>...</code> operator.</p>\n<p>Thus:</p>\n<pre><code class=\"language-javascript\">let sumChainable = function() {\n  let sum = [0, ...arguments].reduce((acc, i) => (acc += i)); // see (a)\n  let f = sumChainable.bind(null, sum); // see (b)\n  f.valueOf = () => sum; // see (c)\n  return f;\n};\n/* (a)\n * [0, ...arguments] will convert arguments to an Array\n * to allow the `reduce`. It will also create an initial item\n * `0` to handle the case no arguments are passed in. Thus\n * making `sumChainable()` possible.\n *\n * (b)\n * Generate a nested function that will be returned, and pass\n * the sum to it. This allows the return value of the function\n * to be invoked in a chain, each changed invocation passing\n * the sum of its caller. Thus `sumChainable()()` is possible.\n *\n * (c)\n * Setting the `valueOf()` function on the returned function to\n * return the sum allows the comparison operator `==` to check\n * the value of the function against a number. Thus making\n * `sumChainable() == 0` possible.\n */\n</code></pre>\n<p>added some sanity tests:</p>\n<pre><code class=\"language-javascript\">/* some tests: */\nconsole.log( `typeof sumChainable(1) == 'function'`, typeof sumChainable(1) == `function` ? 'passed' : 'failed' );\nconsole.log( `sumChainable() == 0`, sumChainable() == 0 ? 'passed' : 'failed' );\nconsole.log( `sumChainable(1) == 1`, sumChainable(1) == 1 ? 'passed' : 'failed' );\nconsole.log( `sumChainable(1) !== 1`, sumChainable(1) !== 1 ? 'passed' : 'failed' );\nconsole.log( `x = sumChainable(1), x.valueOf() === 1`, (x = sumChainable(1), x.valueOf() === 1) ? 'passed' : 'failed' );\nconsole.log( `sumChainable(1,2) == 3`, sumChainable(1,2) == 3 ? 'passed' : 'failed' );\nconsole.log( `sumChainable(1,2,3) == 6`, sumChainable(1,2,3) == 6 ? 'passed' : 'failed' );\nconsole.log( `sumChainable()() == 0`, sumChainable()() == 0 ? 'passed' : 'failed' );\nconsole.log( `sumChainable(0)(1)`, sumChainable(0)(1) == 1 ? 'passed' : 'failed' );\nconsole.log( `sumChainable(1,2)(3)`, sumChainable(1,2)(3) == 6 ? 'passed' : 'failed' );\nconsole.log( `sumChainable(1,2,3)(4)(5)`, sumChainable(1,2,3)(4)(5) == 15 ? 'passed' : 'failed' );\nconsole.log( `sumChainable(1,2,3)(4,5)(6)`, sumChainable(1,2,3)(4,5)(6) == 21 ? 'passed' : 'failed' );\n</code></pre>\n<p>viola!</p>\n","slug":"2018-10-18-chainable-n-args-sum-function","license":"cc-by-nc-sa"}},"__N_SSG":true}