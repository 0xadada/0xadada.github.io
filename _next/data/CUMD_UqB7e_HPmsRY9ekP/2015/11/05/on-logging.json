{"pageProps":{"post":{"slugs":{"year":"2015","month":"11","day":"05","slug":"on-logging"},"title":"on logging","metaDescription":"Thoughts and best practices on application logging","metaKeywords":"software engineering, web development, 12 factor","date":1446721980000,"author":"0xADADA","content":"<p>Application logs are useful for many reasons. They are the primary source of\ntroubleshooting information. Logs are essential to forensics during any rigorous\nsecurity analysis. Web server logs are often used for analysis in order to gain\ninsight into usage, audience, and trends.</p>\n<h2>Logging</h2>\n<p>Logs are time-ordered streams: there is no beginning or end, but rather an\nongoing, collated collection of events which we may wish to view in realtime as\nthey happen. Unix provides some excellent tools for handling streams. There are\ntwo default output streams, <code>stdout</code> and <code>stderr</code>, available automatically to\nall programs.</p>\n<p>A program which uses <code>stdout</code> is equipped to log in a variety of ways without\nadding any weight to its codebase or configuration format.</p>\n<p>Treating your logs as streams is a form of future-proofing for your application.\nChoosing to use <code>stdout</code> over custom-implementing a specific logging solution\nallows your application to change logging mechanisms with 0-code changes. It\nallows you to be the most agnostic as you haven't needed to make any decisions\nor implementations other than adopting a long-standard convention.</p>\n<p>If you run them in the foreground, as is typical of development mode, you see\nthe output right in your terminal. This is exactly what you want. If you run in\nproduction mode, you can redirect the output to a file, to syslog, to both, or\nto any other logging system that can accept an input stream.</p>\n<p>Logging on any reasonably large distributed system will generally end up using\nthe syslog protocol to send logs from many components to a single location.\nPrograms that treat logs as files are now on the wrong path: if they wish to log\nto syslog, each program needs to implement syslog internally - and provide yet\nmore logging configuration options to set the various syslog fields.</p>\n<h3>Best Practices</h3>\n<ol>\n<li>An app shouldn't implement a custom logging solution. Simply write to\n<code>stdout</code> and <code>stderr</code>.</li>\n<li>Don't write to a log file, and don't expect log files to be managed. This\nthen requires log rotation and log file maintenance.</li>\n</ol>\n<p>During local development, the developer will view this stream in the foreground\nof their terminal to observe app behavior. During production the runtime\nenvironment will read <code>stdout</code> and <code>stderr</code> from the app, the streams will be\ncaptured by the execution environment, collated together with all other streams\nfrom the app, and routed to one or more final destinations for viewing and\nlong-term archival. These archival destinations are not visible to or\nconfigurable by the app, and instead are completely managed by the execution\nenvironment. Furthermore, the app needn't implement any logging solution.</p>\n<p>The event stream for an app can be rerouted to a file (if needed), or watched in\na terminal. Most significantly, the stream can be sent to a log indexing and\nanalysis system such as Splunk. These systems allow for great power and\nflexibility for introspecting an app's behavior over time, including:</p>\n<ul>\n<li>Finding specific events in the past.</li>\n<li>Large-scale graphing of trends (such as requests per minute).</li>\n<li>Active alerting according to user-defined heuristics</li>\n</ul>\n<h3>In Practice</h3>\n<p>Already using Amazon AWS? Checkout CloudWatch, the additional advantages here\nare that you could have a central source of truth for all monitoring needs\nbecause such metrics as CPU, disk I/O, and network for your container instances\nare already available on CloudWatch.</p>\n<p>If using Docker,\n<a href=\"https://github.com/docker/docker/releases/tag/v1.9.0\">Docker 1.9 announced a logging driver for CloudWatch</a>.\nUse these options to enable the <code>awslogs</code> Amazon AWS CloudWatch logging driver:</p>\n<pre><code>--log-opt awslogs-region=&#x3C;aws_region>\n--log-opt awslogs-group=&#x3C;log_group_name>\n--log-opt awslogs-stream=&#x3C;log_stream_name>\n</code></pre>\n<p>Provide AWS credentials to the Docker daemon to use the <code>awslogs</code> logging\ndriver. You can provide these credentials with the <code>AWS_ACCESS_KEY_ID</code> ,\n<code>AWS_SECRET_ACCESS_KEY</code>, and <code>AWS_SESSION_TOKEN</code> environment variables.</p>\n<p>Credentials must have a policy applied that allows the <code>logs:CreateLogStream</code>\nand <code>logs:PutLogEvents</code> actions, as shown in the following example.</p>\n<pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": [\n        \"logs:CreateLogStream\",\n        \"logs:PutLogEvents\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\n</code></pre>\n<p>Use containers to move logs from one container into another service using a\nDocker logging driver. Docker allows configuration of container log driver:</p>\n<pre><code>container_name:\n    log_driver: syslog\n      log_opt:\n        syslog-tag: nginxproxy_nginx\n        syslog-address: udp://MY_DOCKER_HOST\n</code></pre>\n<p>Using Splunk?\n<a href=\"http://blogs.splunk.com/2015/08/24/collecting-docker-logs-and-stats-with-splunk/\">Use containers to run a Splunk forwarder</a></p>\n<pre><code>splunkforwarder:\n  image: outcoldman/splunk:6.2-forwarder\n  environment:\n    - SPLUNK_FORWARD_SERVER=YOUR_DOCKER_HOSTNAME:9997\n  volumes_from:\n    - vforwarder\n  ports:\n    - 514:1514/udp\n  restart: always\n</code></pre>\n","slug":"2015-11-05-on-logging","license":"cc-by-nc-sa"}},"__N_SSG":true}