{"pageProps":{"post":{"slugs":{"year":"2015","month":"08","day":"03","slug":"when-to-use-git-merge-vs-git-rebase"},"title":"When to Use Git Merge vs Git Rebase","displayTitle":"When to Use Git Merge vs Git Rebase","metaDescription":"This article will attempt to provide an overview to the different workflows, and explain when merge and rebase are the more appropriate workflow to use.","metaImage":"/static/images/2015-08-03-git-merge-vs-rebase-07.png","date":1438587060000,"author":"0xADADA","content":"<p>I’ve seen many articles and discussions online discussing the merits of merge\nand rebase when integrating parallel branches into the main branch. It seems\nthere are two camps arguing “which is better” when in reality, both have their\nown use cases.</p>\n<p>The task we need to accomplish is to determine which workflow is right for your\nproject. This article will attempt to provide an overview to the different\nworkflows, and explain when merge and rebase are the more appropriate workflow\nto use.</p>\n<h2>The Simplistic Branch Workflow</h2>\n<h3>aka the GitFlow / Branch-Merge-Merge Workflow</h3>\n<p>Software development teams have a typical way of doing things, but all have a\nmain integration branch (I’ll call it “Master” for the remainder of this\narticle) that receives feature branches.</p>\n<p>Feature branches originate from Master, active development is performed along\nthe feature branch, and when the feature is complete, it’s combined back into\nMaster.</p>\n<p>I call this workflow the\n“<a href=\"http://nvie.com/posts/a-successful-git-branching-model/\">GitFlow</a> /\nBranch-Merge-Merge” workflow. The history of events for this simplistic workflow\nare as follows:</p>\n<p>on Master:</p>\n<ul>\n<li>commit #1</li>\n<li>commit #2</li>\n</ul>\n<p>on Feature:</p>\n<ul>\n<li>commit #a</li>\n<li>commit #b</li>\n</ul>\n<p>on Master:</p>\n<ul>\n<li>merge feature <code>--no-ff</code></li>\n</ul>\n<p>This produces the following graph:</p>\n<figure>\n    <img src=\"/static/images/2015-08-03-git-merge-vs-rebase-01.png\"\n      alt=\"Graph of a typical git workflow. Numbered commits occur along Master.\n        Alphabetized commits occur along Feature.\" title=\"Graph of a typical git\n        workflow. Numbered commits occur along Master.  Alphabetized commits occur\n        along Feature.\">\n  <figcaption>Graph of a typical git workflow. Numbered commits occur\n  along Master. Alphabetized commits occur along Feature.</figcaption>\n</figure>\n<p>This workflow performs well for a single developer because while the feature\ndevelopment occurred on the feature branch, the sequence of events occurred\nlinearly. Importantly, no changes occurred on Master while Feature branch was\nchanged.</p>\n<p>When development occurs in parallel on the upstream branch (ie. Master), either\nby the developer, or a co-developer, the history gets more complicated.</p>\n<p>For this example, we’ll pretend to be a single developer working on both\nbranches in parallel, we use the following sequence:</p>\n<p>on Master:</p>\n<ul>\n<li>commit #1</li>\n<li>commit #2</li>\n</ul>\n<p>on Feature:</p>\n<ul>\n<li>commit #a</li>\n<li>commit #b</li>\n</ul>\n<p>on Master:</p>\n<ul>\n<li>commit #3</li>\n<li>commit #4</li>\n</ul>\n<p>on Master:</p>\n<ul>\n<li>git merge feature <code>--no-ff</code></li>\n</ul>\n<p>This produces the following graph:</p>\n<figure>\n  <img src=\"/static/images/2015-08-03-git-merge-vs-rebase-02.png\"\n      alt=\"Typical workflow diagram\" title=\"Typical workflow diagram\">\n  <figcaption>\n    Graph of a typical git workflow. Numbered commits occur along Master.\n    Alphabetized commits occur along Feature.\n  </figcaption>\n</figure>\n<p>In the above scenario the developer runs into the problem where Feature commits\n#a and #b were done independently of Master commits #3, #4 and #5. This merge\nwill fail.</p>\n<p>To solve this problem, the developer must first merge the upstream changes in\nMaster into feature branch Feature. To accomplish this, the developer must\nswitch into the feature branch and merge in the changes from Master. The\ndeveloper must then switch back to Master and merge the changes from Feature\ninto Master. Use the following sequence:</p>\n<p>on Feature:</p>\n<ul>\n<li>merge master</li>\n</ul>\n<p>on Master:</p>\n<ul>\n<li>merge feature</li>\n</ul>\n<p>This produces the following graph:</p>\n<figure>\n  <img src=\"/static/images/2015-08-03-git-merge-vs-rebase-03.png\"\n      alt=\"Typical workflow diagram\" title=\"Typical workflow diagram\">\n  <figcaption>\n    Note how the final git log interleaves the commits on\n    Feature between commits on Master.\n  </figcaption>\n</figure>\n<p>I call this workflow the “Branch-Merge-Merge” workflow because in the most\ngeneral case — the workflow begins with a branch, requires an upstream merge\ninto the feature branch prior to merging the feature branch back into the master\nbranch.</p>\n<p>Looking at the above graph, feature branch Feature has been merged successfully\ninto Master, but the git log shows an interleaved sequence of commits between\nMaster and Feature that make debugging complex.</p>\n<p>In the case where branch Feature introduced a bug into the Master branch, a\nrollback will be difficult because of how the commits are interleaved. In the\ncase where the bug was introduced in Feature branch commit #b, the maintainer of\nMaster branch would need to roll-back commits #6, #c, #5, #4 and #b. This is a\ndifficult roll-back because Master branch features #5 and #4 were rolled back in\nthe effort to roll back to Feature branch feature #b. We’ve thrown some of the\nbaby out with the bathwater.</p>\n<p>One way to address the problems with this particular scenario is to merge in the\nFeature branch as a single commit appended to the Master branch, rather than as\na set of interleaved commits within the Master branch. This brings us to the\nnext workflow.</p>\n<h2>Branch-Merge-MergeSquash Workflow</h2>\n<p>This workflow attempts to address the shortcomings of the workflow above by\nappending feature branches as a single commit at the end of the integration\nbranch.</p>\n<p>For this example, lets pretend to be a single developer working on both branches\nin parallel (as I did above), we use the following sequence:</p>\n<p>on Master:</p>\n<ul>\n<li>commit #1</li>\n<li>commit #2</li>\n</ul>\n<p>on Feature:</p>\n<ul>\n<li>commit #a</li>\n<li>commit #b</li>\n</ul>\n<p>on Master:</p>\n<ul>\n<li>commit #3</li>\n<li>commit #4</li>\n</ul>\n<p>on Feature:</p>\n<ul>\n<li>merge master</li>\n</ul>\n<p>on Master:</p>\n<ul>\n<li>git merge feature <code>--squash</code></li>\n</ul>\n<p>This produces the following graph:</p>\n<figure>\n  <img src=\"/static/images/2015-08-03-git-merge-vs-rebase-04.png\"\n      alt=\"Typical workflow diagram\" title=\"Typical workflow diagram\">\n  <figcaption>\n    The git log sequence of events shows a linear series of\n    feature integrations.\n  </figcaption>\n</figure>\n<p>Looking at the above graph, feature branch Feature has been merged successfully\ninto Master (although the graph doesn’t show a merge line) at commit #5.\nImportantly, the git log shows a linear sequence of commits, each indicating a\ncomplete feature integration. The squash flag has collapsed Feature branch\ncommit #a, #b and #c into single commit #5.</p>\n<p>In the case where branch Feature introduced a bug into the Master branch, a\nrollback will be as simple as running <code>git reset --hard HEAD^</code> because of how\nthe Feature branch was a single commit appended onto Master. In this scenario,\nthe Master branch maintainer would tell the Feature branch maintainer to fix the\nproblem, and they could attempt the merge once the issue was fixed.</p>\n<p><strong>I recommend this workflow</strong> as a best-practice in cases where the feature\nbranch will be shared (eg. pushed to GitHub, shared with other developers.)</p>\n<p>A potential downside of this workflow is the potential confusion caused by the\norigin commit of the Feature branch. Feature branch origin is located at commit\n#2, and merged at commit #5. This is additional cognitive load on the Master\nbranch maintainer when it comes time to merge the feature branch into Master. A\nsimplified workflow could solve this by having the Feature branch simulate its\norigin commit at commit #4 prior to merging into Master. This would reduce\ncognitive load on the Master branch maintainer.</p>\n<h2>Branch-Rebase-MergeSquash Workflow</h2>\n<p>This workflow is popular with\n<a href=\"https://nodejs.org/documentation/contributing/\">open source projects</a> where the\njob for the Master branch maintainer involves multiple feature branch\nintegrations on a daily basis.</p>\n<p>This workflow is designed to make feature branch merges much simpler and easier\nto roll back. The main idea is that each feature branch is a simple append to\nthe end of the Master branch. No merge is simpler than and append-merge.</p>\n<p>For this example, lets pretend to be the same single developer working on both\nbranches in parallel (again, as I did above), we use the following sequence:</p>\n<p>on Master:</p>\n<ul>\n<li>commit #1</li>\n<li>commit #2</li>\n</ul>\n<p>on Feature:</p>\n<ul>\n<li>commit #a</li>\n<li>commit #b</li>\n</ul>\n<p>on Master:</p>\n<ul>\n<li>commit #3</li>\n<li>commit #4</li>\n</ul>\n<p>on Feature:</p>\n<figure>\n  <img src=\"/static/images/2015-08-03-git-merge-vs-rebase-05.png\"\n      alt=\"Feature with upstream changes before rebase\"\n      title=\"Feature with upstream changes before rebase\">\n  <figcaption>\n    On the Feature branch, the graph appears after\n    commit #2 prior to rebase.\n  </figcaption>\n</figure>\n<ul>\n<li>rebase master</li>\n</ul>\n<figure>\n  <img src=\"/static/images/2015-08-03-git-merge-vs-rebase-06.png\"\n      alt=\"Feature with upstream changes after rebase\"\n      title=\"Feature with upstream changes after rebase\">\n  <figcaption>\n    After rebase, Feature branch commits #a and #b originate\n    from parent commit #4\n  </figcaption>\n</figure>\n<p>We have now changed the origin commit of branch Feature to commit #4. This sets\nup future merges of the Feature branch to append directly to the end of Master\nbranch.</p>\n<p>on Master:</p>\n<ul>\n<li>merge feature <code>--squash</code></li>\n</ul>\n<p>We’ve now switched to the Master branch, and merged in the rebased Feature\nbranch, appending a single commit #5 to the end of the Master branch containing\nall of the Feature branch.</p>\n<p>This produces the final graph:</p>\n<figure>\n  <img src=\"/static/images/2015-08-03-git-merge-vs-rebase-07.png\"\n      alt=\"Feature with upstream changes after rebase\"\n      title=\"Feature with upstream changes after rebase\">\n  <figcaption>\n    After merging the Feature into Master, commit #5 containing\n    the final result of all Feature branch commits #a and #b.\n  </figcaption>\n</figure>\n<p>The final sequence of events on the Master branch read cleanly, showcasing only\npast feature branch integrations. Each feature branch originated directly from\nthe latest commit, making it seem like the feature is a simple fast-forward\nappend onto the latest commit.</p>\n<p>It’s worth pointing out the Branch-Merge-MergeSquash and\nBranch-Rebase-MergeSquash workflows both result in the same final sequence of\ncommits. The major benefit of the Branch-Rebase-MergeSquash workflow is that\nits’ branch origin appears much later in the history, reducing cognitive load on\nMaster branch integrations.</p>\n<p><strong>I recommend this workflow</strong> as a\n<a href=\"http://blog.izs.me/post/37650663670/git-rebase\">best-practice</a> when the\ndeveloper is working alone on a feature branch, as well as just-prior to merging\nthe feature branch into the master branch.</p>\n<p>The\n<a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">downside of this workflow is when sharing a feature branch after a rebase</a>.\nPushing to GitHub will require the <code>--force</code> flag, and anyone else working on\nthe feature branch will see changes to the branch history when they pull an\nupdate. This is why I don’t recommend this workflow for shared feature branches.</p>\n<h2>Conclusion</h2>\n<p>I see huge benefits in collapsing feature branch commits into the master branch\nwith — — squash, both for simplicity sake, clarity, and reduces cognitive load\nwhen the master branch maintainer needs to merge in big features. Additionally\nit makes the use of git bisect much easier.</p>\n<p>I love the advantages to using git rebase to merge in upstream changes while\nworking on a feature branch, but it seems people need to use the workflow in\npractice before they can understand its benefits. Give it a shot, you might like\nit.</p>\n<p>All three workflows have been published to GitHub</p>\n<ul>\n<li><a href=\"https://github.com/0xadada/git-exp-branch-merge-merge/network\">Branch-Merge-Merge</a></li>\n<li><a href=\"https://github.com/0xadada/git-exp-branch-merge-mergesquash/network\">Branch-Merge-MergeSquash</a></li>\n<li><a href=\"https://github.com/0xadada/git-exp-branch-rebase-merge/network\">Branch-Rebase-MergeSquash</a></li>\n</ul>\n<hr>\n<p>This article was originally published on\n<a href=\"https://medium.com/@0xadada/when-to-use-git-merge-vs-git-rebase-264daeec77bd\">Medium.com</a></p>\n","slug":"2015-08-03-when-to-use-git-merge-vs-git-rebase"}},"__N_SSG":true}