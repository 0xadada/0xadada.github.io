{"pageProps":{"post":{"slugs":{"year":"2020","month":"03","day":"20","slug":"ember-emplates-classic-vs-angle-bracket-syntaxes"},"title":"Ember Templates: Classic vs Angle Bracket Syntaxes","displayTitle":"Ember Templates: Classic vs Angle Bracket Syntaxes","metaDescription":"Diving into the difference between Ember component invocation when using curlies, angle brackets, and s-expression in Ember templates.","metaKeywords":"ember, web development","image":"/static/images/2020-03-20-ember-emplates-classic-vs-angle-bracket-syntaxes.png","metaImage":"/static/images/2020-03-20-ember-emplates-classic-vs-angle-bracket-syntaxes.png","date":1584720840000,"author":"0xADADA","content":"<p>This articles describes the difference between how component invocation differs\nwhen using curlies <code>{​{...}}</code>, angle brackets <code>&#x3C;...></code> or an <code>(...)</code> s-expression\nin Ember templates.</p>\n<p>Ember has three methods for invoking components and helpers in a template,\neither of the three can be used to invoke both classic and modern glimmer\ncomponents.</p>\n<p>The \"classic\" syntax in the form that uses curly braces <code>{​{...}}</code>, e.g.</p>\n<pre><code class=\"language-html\">{​{user-profile firstName=\"Dan\" lastName=\"F.\"}}\n</code></pre>\n<p>The \"angle bracket\" syntax that uses a HTML-like form <code>&#x3C;... /></code>, e.g.:</p>\n<pre><code class=\"language-html\">&#x3C;UserProfile @firstName=\"Dan\" @lastName=\"F.\" />\n</code></pre>\n<p>Finally the s-expression (for sub-expression) form used inside curly and angle\nbracket syntax to invoke a sub component or helper. This takes the form\n<code>(concat a \" \" b)</code>, thus:</p>\n<pre><code class=\"language-html\">{​{user-profile name=(concat firstName \" \" lastName)}}\n</code></pre>\n<p>and</p>\n<pre><code class=\"language-html\">&#x3C;UserProfile @classNames={​{concat \"sticky \" (if this.isActive \"is-active\")}} />\n</code></pre>\n<h2>Angle Brackets</h2>\n<p>Similar to the vanilla DOM APIs that distinguish between\n<a href=\"https://joji.me/en-us/blog/html-attribute-vs-dom-property/\">JS properties from HTML attributes</a>,\nangle bracket component invocations have two different namespaces you're\noperating against.</p>\n<p>You are probably most familiar with HTML attributes, which tell the browser how\nto draw an HTML element. These attributes can do things like defining the <code>alt</code>\ntext on an image <code>&#x3C;img alt=\"A bird\"></code> or the URL on an anchor tag\n<code>&#x3C;a href=\"https://example.com\"></code>. Angle bracket syntax implements attributes in\na similar way, allowing the developer to apply these attributes to a DOM node\nsomewhere in the component's template.</p>\n<pre><code class=\"language-html\">&#x3C;!-- parent.hbs -->\n&#x3C;UserProfile class=\"abc\" @tagName=\"figure\" />\n</code></pre>\n<p>The <code>...attributes</code> syntax determines where the attributes passed into a\ncomponent from an angle bracket invocation should appear in the component's\ntemplate. Any number of attributes\n<a href=\"https://github.com/emberjs/rfcs/blob/master/text/0435-modifier-splattributes.md\">and element modifiers</a>\ncan be specified on the user profile component now, and they will all be applied\nto the element that has <code>...attributes</code> on it.</p>\n<pre><code class=\"language-html\">&#x3C;!-- UserProfile.hbs -->\n&#x3C;figure>\n  &#x3C;img ...attributes src=\"default.jpg\" />\n&#x3C;/figure>\n</code></pre>\n<p>the resulting HTML output is:</p>\n<pre><code class=\"language-html\">&#x3C;figure>\n  &#x3C;img class=\"abc\" src=\"default.jpg\" />\n&#x3C;/figure>\n</code></pre>\n<p>Anything prefixed with <code>@</code> is an \"argument\", is passed to the component by its\ncaller, is accessible to the class backing the component, and can be any JS\nruntime value. Unlike attributes, which tell the browser what to render,\narguments tell your custom Ember component tag what to do.</p>\n<pre><code class=\"language-html\">&#x3C;!-- parent.hbs -->\n&#x3C;UserProfile @name=\"Dan F.\" />\n</code></pre>\n<p>This template invokes the <code>&#x3C;UserProfile></code> component, which expects one argument:\n<code>@name</code>, the value we pass is the hardcoded string \"Dan F.\".</p>\n<p>In the backing component class, arguments are namespaced on the <code>this.args</code>\nobject, which is immutable. You can access this argument as:</p>\n<pre><code class=\"language-js\">// user-profile.js\nthis.args.name; // \"Dan F.\"\n</code></pre>\n<p>To illustrate the differences, here is an invocation of an angle bracket\ncomponent using both arguments and attributes:</p>\n<pre><code class=\"language-html\">&#x3C;Foo\n  @bar={​{123}}\n  @baz={​{hash a=\"1\" b=\"hi\"}}\n  class=\"hello\"\n  data-fizz=\"ok\"\n/>\n</code></pre>\n<p>In the above, <code>bar</code> and <code>baz</code> would be arguments with the values <code>123</code> and\n<code>{ a: 1, b: 'hi' }</code> respectively, while <code>class</code> and <code>data-fizz</code> would be\nattributes that could be applied to a DOM node somewhere in the component's\ntemplate.</p>\n<h2>Curly and s-expression Syntax</h2>\n<p>Ember curly (also called \"classic\") component invocation only have one\nnamespace: the argument, everything is treated as an argument, as if you\nimplicitly included <code>@</code> in front of each one. Historically, this was compensated\nfor by automatically applying the value of the <code>class</code> argument to the <code>class</code>\n<em>attribute</em> of a component's root element (if it had one), and this behavior\ncould be extended to other attributes using the Ember classic\n<code>attributeBindings</code> API.</p>\n<pre><code class=\"language-html\">&#x3C;!-- parent.hbs -->\n{​{user-profile bar={​{123}} baz=(hash a=1 b='hi') class=\"hello\"\ndata-fizz=\"ok\"}}\n</code></pre>\n<p>In the above, <code>bar</code>, <code>baz</code>, <code>class</code> and <code>data-fizz</code> would all be treated as\n<strong>arguments</strong> to the receiving component, so any <code>...attributes</code> in its template\nwould be a no-op. In Ember classic components, all of these arguments can be\naccessed in the backing component class using either the argument name alone,\n<code>&#x3C;argument name></code>, or using <code>this.&#x3C;argument name></code>, thus:</p>\n<pre><code class=\"language-js\">// user-profile.js\nbar; // 123\nthis.bar; // 123\nbaz; // { a: 1, b: 'hi' }\nthis.baz; // { a: 1, b: 'hi' }\nthis.class; // 'hello'\nthis[\"data-fizz\"]; // 'ok'\n</code></pre>\n<p>Usage in the template is:</p>\n<pre><code class=\"language-html\">&#x3C;!-- user-profile.hbs -->\n{​{bar}}&#x3C;br />\n{​{this.bar}}&#x3C;br />\n{​{baz}}&#x3C;br />\n{​{this.baz}}&#x3C;br />\n{​{this.class}}&#x3C;br />\n{​{data-fizz}}&#x3C;br />\n{​{this.data-fizz}}\n</code></pre>\n<p>results in the following output:</p>\n<pre><code class=\"language-html\">123&#x3C;br />\n123&#x3C;br />\n[Object]&#x3C;br />\n[Object]&#x3C;br />\nhello&#x3C;br />\nok&#x3C;br />\nok\n</code></pre>\n<p>It's important to note that both Ember classic and glimmer components can be\ninvoked by either syntax: classic curly or angle brackets—and what matters is\nhow the backing class is defined. Thus, if the above example was implemented as\na modern glimmer component, the backing class must access the argument <code>bar</code>\nwith <code>this.args.bar</code>. If the above example was implemented as a classic\ncomponent, the backing class must access the argument with either <code>bar</code> or\n<code>this.bar</code>.</p>\n<h2>So What's Missing?</h2>\n<p>For those following closely, you may have noticed that this leaves us with some\nkind of hole in the programming model, because there's no angle-bracket\nequivalent for setting up a contextual component to pass in as an argument or\nyield out as a block parameter. That's the topic under discussion at\n<a href=\"https://github.com/emberjs/rfcs/issues/497\">Ember RFC issue #497</a>.</p>\n<p>In the meantime, <code>&#x3C;div class={​{@class}} local-class=\"whatever\" ...attributes></code>\nwill ensure that a class applied to a component will pass through correctly\nregardless of how it's being invoked.</p>\n<aside>\n  This article was adapted from a\n  <a href=\"https://github.com/salsify/ui-localization/pull/44#pullrequestreview-340619675)\" rel=\"external\">PR comment</a>\n  by <a href=\"https://dfreeman.io/\" rel=\"external\">Dan Freeman</a>.\n  Thanks to\n  <a href=\"https://twitter.com/jamscdavis\" rel=\"external\">James Davis</a>\n  for proof reading this article.\n</aside>\n","slug":"2020-03-20-ember-emplates-classic-vs-angle-bracket-syntaxes"}},"__N_SSG":true}