{"pageProps":{"post":{"slugs":{"year":"2019","month":"06","day":"17","slug":"essential-ember-addons"},"title":"Essential Ember Addons: The State of the Ember Addon Ecosystem in 2019","displayTitle":"Essential Ember Addons: The State of the Ember Addon Ecosystem in 2019","metaDescription":"A list of Ember addons that I use in most of my projects","metaKeywords":"ember, ember.js, addons, ember addons, web framework, web development, programming, software engineering","image":"/static/images/2019-06-17-essential-ember-addons.png","metaImage":"/static/images/2019-06-17-essential-ember-addons.png","date":1560810180000,"author":"0xADADA","content":"<p>2019 has been a great year for Ember so far, so while my peers are focused on\nsetting direction for the framework for the rest of 2019, I wanted to take stock\nof the existing addons ecosystem.</p>\n<p>In this article I’d like to present a list of Ember addons that I use in most of\nmy projects. I've been using Ember for the last few years as my go–to framework\nfor developing web applications, and many of these addons make appearances in\nnearly all of them.</p>\n<p>Ember addons generally fall into one (or more) category of functionality I'll be\nreferring to throughout this guide:</p>\n<ul>\n<li><strong>Build-time</strong> Build-time addons provide command-line tools that help\ndevelopers during the creation of the application. An example is\n<code>ember-cli-eslint</code> which provides code linting, or <code>ember-cli-typescript</code>\nwhich adds a build pipeline for transforming TypeScript files into JavaScript\nfiles. These addons don't ship features to your deployed application. These\naddons typically start with the prefix <code>ember-cli-</code><strong>.</strong></li>\n<li><strong>Runtime</strong> Runtime addons provide features that will be present in the final\napplication, these include Ember components like <code>ember-power-select</code> and\n<code>ember-svg-jar</code> these addons increase the payload of the deployed application.\nThese addons typically start with the prefix <code>ember-</code></li>\n<li><strong>Infrastructure</strong> Infrastructure addons provide features that aren't shipped\nwith the payload of your application, but provide functionality that improves\nthe development ergonomics or deployment of the project. For example\n<code>ember-cli-fastboot</code> provides a backend Node.js server for rendering Ember\napps serverside.</li>\n<li><strong>Quality Assurance</strong> Quality assurance addons provide tools for improving\nquality of code over time, and improving the developer experience of writing\nand testing code. These addons typically provide functionality that is used at\nbuild and test time, but isn't shipped to your deployed application.\n<code>qunit-dom</code>, <code>coveralls</code>, and <code>ember-test-selectors</code> are examples of quality\nassurance addons.</li>\n</ul>\n<p>Some of these addons are included by default by <code>ember new &#x3C;project-name></code> but\nI'll elaborate on their use a bit more.</p>\n<p>Finally, before diving into the addon list, I won’t be discussing many standard\nJavaScript packages. There are a bunch of JavaScript packages that I often use\n(<code>ramda</code>, <code>lodash</code>, etc) but these are outside of the scope of this article.</p>\n<h2>Contents</h2>\n<ul>\n<li><a href=\"#general-purpose-addons\">General Purpose Addons</a>\n<ul>\n<li><a href=\"#ember-a11y-testing\">ember-a11y-testing</a></li>\n<li><a href=\"#ember-auto-import\">ember-auto-import</a></li>\n<li><a href=\"#ember-cli-update\">ember-cli-update</a></li>\n<li><a href=\"#ember-cli-code-coverage\">ember-cli-code-coverage</a></li>\n<li><a href=\"#ember-cli-dependency-lint\">ember-cli-dependency-lint</a></li>\n<li><a href=\"#ember-cli-deprecation-workflow\">ember-cli-deprecation-workflow</a></li>\n<li><a href=\"#ember-cli-document-title\">ember-cli-document-title</a></li>\n<li><a href=\"#ember-cli-dotenv\">ember-cli-dotenv</a></li>\n<li><a href=\"#ember-cli-template-lint\">ember-cli-template-lint</a></li>\n<li><a href=\"#ember-test-selectors\">ember-test-selectors</a></li>\n<li><a href=\"#ember-truth-helpers\">ember-truth-helpers</a></li>\n<li><a href=\"#eslint-plugin-ember\">eslint-plugin-ember</a></li>\n<li><a href=\"#eslint-plugin-prettier\">eslint-plugin-prettier</a></li>\n<li><a href=\"#prettier\">prettier</a></li>\n<li><a href=\"#qunit-dom\">qunit-dom</a></li>\n</ul>\n</li>\n<li><a href=\"#specific-usecase-addons\">Specific Usecase Addons</a>\n<ul>\n<li><a href=\"#ember-cli-addon-docs\">ember-cli-addon-docs</a></li>\n<li><a href=\"#ember-cli-bundle-analyzer\">ember-cli-bundle-analyzer</a></li>\n<li><a href=\"#ember-cli-deploy\">ember-cli-deploy</a></li>\n<li><a href=\"#ember-cli-mirage\">ember-cli-mirage</a></li>\n<li><a href=\"#ember-cli-page-object\">ember-cli-page-object</a></li>\n<li><a href=\"#ember-cli-release\">ember-cli-release</a></li>\n<li><a href=\"#ember-cli-typescript\">ember-cli-typescript</a></li>\n<li><a href=\"#ember-cli-fastboot\">ember-cli-fastboot</a></li>\n<li><a href=\"#ember-cli-fastboot-testing\">ember-cli-fastboot-testing</a></li>\n<li><a href=\"#ember-concurrency\">ember-concurrency</a></li>\n<li><a href=\"#ember-css-modules\">ember-css-modules</a></li>\n<li><a href=\"#ember-intl\">ember-intl</a></li>\n<li><a href=\"#ember-intl-analyzer\">ember-intl-analyzer</a></li>\n<li><a href=\"#ember-fetch\">ember-fetch</a></li>\n<li><a href=\"#ember-power-select\">ember-power-select</a></li>\n<li><a href=\"#ember-simple-auth\">ember-simple-auth</a></li>\n<li><a href=\"#ember-svg-jar\">ember-svg-jar</a></li>\n</ul>\n</li>\n<li><a href=\"#conclusion\">Conclusion</a></li>\n</ul>\n<h2>General Purpose Addons</h2>\n<p>These addons are used in nearly all my projects, I often install and configure\nthem right after I've created a new project.</p>\n<h3>ember-a11y-testing</h3>\n<p><a href=\"https://github.com/ember-a11y/ember-a11y-testing\">ember-a11y-testing</a> is a\nquality assurance addon that integrates into the existing Ember test framework,\nadding tests that check for accessibility problems. The addon leverages the\nwonderful <a href=\"https://github.com/dequelabs/axe-core\">axe-core library</a> to test for\nform labels, high contrast colors, ARIA attributes and much more.</p>\n<h3>ember-auto-import</h3>\n<p>Ember apps can import standard NPM libraries, but it wasn't straightforward,\nuntil now.</p>\n<p><a href=\"https://github.com/ef4/ember-auto-import\">ember-auto-import</a> is included with\nthe new Ember Octane edition. It is a build time addon with optional runtime\nlazy-loading that enables developers to use import statements from standard NPM\npackages without having to wrap it in an Ember addon or manually wire it into\nthe build by adding it to <code>ember-cli-build.js</code></p>\n<p>Now we can just:</p>\n<pre><code>$ ember install ember-auto-import\n$ yarn add -D lodash-es\n</code></pre>\n<p>and in your code:</p>\n<pre><code>import { capitalize } from 'lodash-es';\nlet nameUpper = capitalize('edward faulkner');\n// Edward Faulkner\n</code></pre>\n<h3>ember-cli-update</h3>\n<p><a href=\"https://github.com/ember-cli/ember-cli-update\">ember-cli-update</a> is a build\ntime addon that adds the <code>update</code> sub-command to the Ember CLI. This command\nincrementally updates your app or addon to the latest Ember CLI version. It does\nthis by fetching the latest version and comparing it to your project's Ember CLI\nversion. It then applies a diff of the changes from the latest version to your\nproject. It will only modify the files if there are changes between your\nproject's version and the latest version, and it will only change the section\nnecessary, not the entire file.</p>\n<p>This tool gets regular use over the lifecycle of all the Ember apps I maintain.</p>\n<h3>ember-cli-code-coverage</h3>\n<p>ember-cli-code-coverage is a quality assurance addon that runs at test time. The\naddon introspects the code running during tests and analyses which code branches\nwere run and how often. It generates a report showing your source code and which\nbranches are covered by tests. This allows you to write test code that covers\nall code branches. The report looks something like this:</p>\n<pre><code>3x  export function asset(param) {\n8x    const rootURL = config.rootURL ? config.rootURL : '';\n8x    return `${rootURL}${param}`;\n    }\n</code></pre>\n<p>Coveralls is a code-coverage-report-as-a-service provider that tracks your\nprojects code coverage over time. The tool auto-uploads your coverage report\nafter tests are run.</p>\n<h3>ember-cli-dependency-lint</h3>\n<p><a href=\"https://github.com/salsify/ember-cli-dependency-lint\">ember-cli-dependency-lint</a>\nis a build time addon that will lint your app's addon dependencies, making sure\nyour app or addon has only one version of any dependency. If your app has\nmultiple versions, which is actually packaged in the final build? This situation\ncan lead to anything from hard exceptions to subtle behavioral bugs.</p>\n<pre><code>my-app\n├─┬ ember-modal-dialog\n│ └── ember-wormhole@0.3.6\n└─┬ ember-power-select\n  └─┬ ember-basic-dropdown\n    └── ember-wormhole@0.5.1\n</code></pre>\n<p>This addon will throw a build error until the developer explicitly resolves the\ndependency either by pinning the dependency with a resolution, or updating the\naddon with the outdated dependency.</p>\n<h3>ember-cli-deprecation-workflow</h3>\n<p>ember-cli-deprecation-workflow is a runtime addon that comes in handy whenever\nyou are updating Ember.js or Ember Data, you'll eventually get deprecation\nwarnings that need to resolved. In the meantime the console is filled with\ndeprecation warning noise.</p>\n<p>The addon listens for deprecation warnings in the console, and adds each to a\nlist. It allows you to add each deprecation warning to a config file where you\ncan work through resolving the deprecations one-by-one.</p>\n<h3>ember-cli-document-title</h3>\n<p>ember-cli-document-title is a runtime addon that lets you update the document\n<code>&#x3C;title></code> on a per-route basis. It lets you define the title directly on a\n<code>title</code> field on any route:</p>\n<pre><code>// app/routes/post.js\nexport default Ember.Route.extend({\n  title: 'A fresh new post 🥖'\n});\n</code></pre>\n<p>This addon should probably be part of Ember core.</p>\n<h3>ember-cli-dotenv</h3>\n<p>ember-cli-dotenv is an addon that allows your app to consume environment\nvariables at build time, as defined in a <code>.env</code> file:</p>\n<pre><code>API_HOST=https://api.webapp.dev\nAPI_TOKEN=CHANGEME\nAPI_SECRET=CHANGEME\n</code></pre>\n<p>This addon reads these variables and exposes them through the built-in\n<code>config/environment.js</code> that you can then import in your app wherever you need\nthem. You might want to make your API endpoint URL, port, or any secrets\nconfigured as environment variables.</p>\n<h3>ember-cli-template-lint</h3>\n<p>ember-cli-template-lint adds lint tooling for handlebars templates to the\nember-cli. The lint rules are also automatically added to the test runner so the\nrules are tested against during <code>ember test</code> runs. This addon was recently\nintegrated into Ember core as a default addon.</p>\n<h3>ember-test-selectors</h3>\n<p>ember-test-selectors helps you write tests that look more semantic, and with\nless churn between refactors. This is because the pattern leads you do bind your\ntests to a test selector that shouldn't change during a refactor (instead of\ndirectly to an HTML tag).</p>\n<p>If your component produces HTML markup like this:</p>\n<pre><code>&#x3C;!-- before ember-test-selectors -->\n&#x3C;h1>{{post.title}}&#x3C;/h1>\n\n&#x3C;!-- after ember-test-selectors -->\n&#x3C;h1 data-test-heading>{{post.title}}&#x3C;/h1>\n</code></pre>\n<p>You'd change your testing patters to something like this:</p>\n<pre><code>// without ember-test-selectors\nassert.dom('h1').hasText('Example text'); /* you've explicitly tied the test harness\n                                           * to an HTML tag &#x3C;h1>.\n                                           */\n\n// with ember-test-selectors\nassert.dom('[data-test-heading]').hasText('Example text') /* Now you're free to change\n                                                           * the HTML tag under test to\n                                                           * anything, and the test\n                                                           * assertion is less context\n                                                           * dependent.\n                                                           */\n</code></pre>\n<p>The test hooks, bindings, and data are removed from production builds leaving\nyour live code running quickly, and clean of any test artifacts.</p>\n<h3>ember-truth-helpers</h3>\n<p>ember-truth-helpers is a runtime addon adding a set of useful handlebars\ntemplate helpers for additional truth logic, useful in <code>if</code> statements:\n<code>eq not-eq not and or xor gt gte lt lte is-array is-empty is-equal</code>.</p>\n<h3>qunit-dom</h3>\n<p>One of my favorites, qunit-dom is a quality assurance addon that makes for more\nelegant test assertions against DOM elements. Given the following rendered Ember\ncomponent:</p>\n<pre><code>&#x3C;div class=\"ember-view\">\n  &#x3C;p class=\"copy\">This is great&#x3C;/p>\n&#x3C;/div>\n</code></pre>\n<p>and some example test code, before and after:</p>\n<pre><code>// before qunit-dom\nassert.equal(this.element.querySelector('.copy').textContent.trim(), 'This is great');\n\n// after qunit-dom\nassert.dom('.copy').hasText('This is great');\n</code></pre>\n<p>Combining qunit-dom with ember-test-selectors makes for even more powerful test\nassertions that are independent of the DOM, and all test artifacts are stripped\nfrom production builds.</p>\n<pre><code>&#x3C;div class=\"ember-view\">\n  &#x3C;p class=\"copy\" data-test-copy>This is great&#x3C;/p>\n&#x3C;/div>\n\n// combining qunit-dom and ember-test-selectors\nassert.dom('[data-test-copy]').hasText('This is great')\n</code></pre>\n<h3>eslint-plugin-ember</h3>\n<p>eslint-plugin-ember adds Ember-specific ESLint rules to your ember app, and\ncomes with a\n<a href=\"https://github.com/ember-cli/eslint-plugin-ember/blob/master/lib/recommended-rules.js\">great set of recommended defaults</a>\nthat are updated as the community coalesces around best practices. This addon\nwill keep your app code looking clean and tidy, and nudges the code along a path\nof best practices.</p>\n<p>This addon was integrated into the core as a default addon in Ember 2.18.</p>\n<h3>eslint-plugin-prettier</h3>\n<p>Prettier is an opinionated code formatter, and eslint-plugin-prettier runs the\nformat rules as an ESLint rule; it reports differences as errors or warnings as\nESLint issues. This allows you to catch formatting discrepancies in your editor\nas well as in CI builds. Prettier rules can be applied automatically in your\neditor, or by ESLint using <code>eslint --fix</code>.</p>\n<h3>prettier</h3>\n<p>Prettier is not an Ember addon, but a package I use in all my Ember projects.\nPrettier is a code formatter that can automatically format the code in your\neditor (vim, VS Code, etc all have plugins) as well as detecting formatting\nissues test time. Super useful for teams trying to maintain a consistent looking\ncodebase.</p>\n<h2>Specific Usecase Addons</h2>\n<p>The following addons may not be generally applicable to all applications. I may\nnot use them in all my projects but, when I need the capabilities they offer,\nthen I will reach for them. For example, if I need to authenticate users with an\nOAuth provider like Facebook or Twitter, I use <code>ember-simple-auth</code>.</p>\n<h3>ember-cli-addon-docs</h3>\n<p><a href=\"https://ember-learn.github.io/ember-cli-addon-docs/\">ember-cli-addon-docs</a> is a\nbuild time addon that creates an interactive sandbox for versioned addon\ndocumentation. This tools is wonderful for addon (and app developers!) who need\nto maintain versioned documentation. This addon lets the developers write their\ncode and not have to think about how the documentation is presented, generated,\nversioned. The addon has its own code syntax highlighting, interactive live\ndemos, and more.</p>\n<h3>ember-cli-bundle-analyzer</h3>\n<p>ember-cli-bundle-analyzer is a build-time tool that creates a visualization\nchart allowing you to view the size and contents of an app's bundled output,\nwith their relative and overall sizes. This tool is essential for determining\nwhich packages have the largest impact on the deployment size of your\napplication payload.</p>\n<h3>ember-cli-deploy</h3>\n<p>ember-cli-deploy is a build time addon that implements a deployment pipeline to\nupload and activate your Ember app on a variety of hosting providers. It uses a\nplugin architecture allowing you to find a plugin to deploy to AWS, GCP, and\nmany many more.</p>\n<h3>ember-cli-mirage</h3>\n<p>ember-cli-mirage is an addon for mocking backend API responses on the client. It\nruns in both development mode and testing mode to help you write, test, and\nprototype your app without forcing you to write the backend parts first. The\nkiller feature is how it unlocks your ability to do FDD (frontend driven\ndevelopment)— you can build frontend features that don't depend on a backend by\nmocking the backend in mirage. You can continue modifying mirage requests\nalongside your frontend feature. Then when the frontend is feature complete, you\nhave established a set of clear patterns you can then implement on the backend\nof your choice. Mirage is also used during testing, intercepting and mocking API\nrequests instantly so the tests can run more quickly, without making any\nexternal network requests.</p>\n<h3>ember-cli-page-object</h3>\n<p>ember-cli-page-object is a test-time addon making it easy to follow the\npage-object pattern by Martin Fowler. Page objects allow you to define the shape\nof a DOM page in an Ember acceptance test or integration test. They tell your\ncode <em>what</em> to interact with, but do not make assertions about those objects.\nYour tests then reuse this object. This reduces duplication of DOM selectors in\nyour tests, making your test code less fragile and much easier to refactor.</p>\n<h3>ember-cli-release</h3>\n<p>ember-cli-release provides a CLI for building your package, auto-incrementing\nversion numbers, and publishing the packages to a package repository. This is\nmore useful for Ember addons that typically conform to semver conventions, but\ncan be used for engines and applications equally.</p>\n<h3>ember-cli-typescript</h3>\n<p>ember-cli-typescript is a build time addon enabling you to write TypeScript in\nyour Ember apps. It hooks into the build pipeline and transpiles TypeScript to\nJavaScript, and also supplies many of the type definitions for the Ember source\ncode.</p>\n<h3>ember-cli-fastboot</h3>\n<p>ember-cli-fastboot is an infrastructure addon. It enables server side rendering\nof your Ember application. FastBoot runs your application in Node.js so when a\nuser visits your site, they are delivered a fully rendered static HTML page, and\nonly after the content has loaded do they start downloading JavaScript. Once\nfinished, your Ember app takes over, delivering a typical SPA experience. The\nbest of both worlds,\n<a href=\"https://0xadada.pub/talk-using-ember-fastboot-in-weird-ways/#gotchas\">but not without complexity</a>.</p>\n<h3>ember-cli-fastboot-testing</h3>\n<p>ember-cli-fastboot-testing is a quality assurance addon that allows you to write\ntests against your Ember app running in the Node.js server context. Since\nFastBoot runs Ember not in the browser but in a Node.js process, the standard\nEmber testing tools don't apply. This addon lets you write acceptance tests that\ncan excersise code running on the FastBoot server.</p>\n<h3>ember-concurrency</h3>\n<p>ember-concurrency is a runtime addon that makes it easier to write asynchronus\ncode that support cancelation, restarting, expose their internal state, and much\nmore. This addon makes the difficulty of managing state transitions much easier.</p>\n<h3>ember-css-modules</h3>\n<p>ember-css-modules is a built time addon enabling you to write component-oriented\nCSS. Your styles become private to a component, route, or controller, with\nexplicity features to allow style sharing and composition. It works by making\neach CSS file its own isolated namespace by transforming class names to ensure\nthey're unique. Your <code>.css</code> files are now peers of your component <code>.hbs</code> and\n<code>.js</code> files.</p>\n<h3>ember-intl</h3>\n<p>ember-intl is a runtime addon for building internationalized Ember apps, has\nhelpers for tranforming strings into multiple locales, formatting for messages,\ndate/time formats, number, and relative time manipulation. Provides translations\nusing the ICU Message Syntax standard with pluralization support.</p>\n<h3>ember-intl-analyzer</h3>\n<p>ember-intl-analyzer is a quality assurance addon providing tools to help you\nanalyze an internationalized app and will locate unused translations.</p>\n<h3>ember-fetch</h3>\n<p>ember-fetch is a runtime addon providing an alternative to AJAX requests. It\nallows the app to make network requests. ember-fetch is useful for applications\nneeding to support network requests in both a browser and FastBoot context, and\ndo not need to depend on jQuery.</p>\n<h3>ember-power-select</h3>\n<p>ember-power-select is a runtime addon providing a powerful, and extensible\n<code>&#x3C;select></code> dropdown component that is highly customizable.</p>\n<h3>ember-simple-auth</h3>\n<p>ember-simple-auth is a runtime addon for implementing authentication and\nauthorization. It maintains an authenticated client side session, authorizes\nnetwork requests, and provides helpers in authentication flows like OAuth.</p>\n<h3>ember-svg-jar</h3>\n<p>ember-svg-jar is both a build and runtime addon that improves the developer\nergonomics around working with SVG assets. It adds a build-time pipeline that\ndiscovers SVG files in the project repo and packages them as Ember templates.\nThese are then inlined into your app with an Ember template helper\n<code>&#x3C;SvgJar \"[ASSET_NAME]\"></code> that embeds the SVG directly into the markup of your\npage, without an additional network request. It also has a beautiful visual\ndirectory route displaying all the SVG assets in your app.</p>\n<h2>Conclusion</h2>\n<p>The above addons should cover most of your Ember needs. I have only listed\naddons with good documentation, test coverage, and that continue to be\nmaintained. If you need anything more or want to take a general look at some of\nthe addons that have are available I recommend starting with\n<a href=\"https://emberobserver.com/\">emberobserver.com</a>.</p>\n","slug":"2019-06-17-essential-ember-addons"}},"__N_SSG":true}