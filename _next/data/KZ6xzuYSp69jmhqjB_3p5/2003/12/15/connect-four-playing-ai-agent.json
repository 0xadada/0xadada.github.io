{"pageProps":{"post":{"slugs":{"year":"2003","month":"12","day":"15","slug":"connect-four-playing-ai-agent"},"title":"A Connect Four Playing AI Agent: Algorithm and Creation Process","displayTitle":"A Connect Four Playing AI Agent: Algorithm and Creation Process","metaDescription":"This paper documents the creation and testing of a game playing artificial intelligence (AI) agent program.  The agent is designed to play a game of Connect Four by Milton-Bradely.","metaKeywords":"ai, artificial intelligence, machine learning, connect four, minimax","date":1071489600000,"author":"0xADADA, Erik Ibsen, Chen Zhang","content":"<p>0xADADA, Erik Ibsen, Chen Zhang\n<br>\nKhoury College of Computer Sciences\n<br>\nNortheastern University Boston, MA</p>\n<hr>\n<p>This paper documents the creation and testing of a game playing artificial\nintelligence (AI) agent program. The agent is designed to play a game of Connect\nFour by Milton-Bradley. The game is played by dropping pieces into a game board\nconsisting of a grid of 6x7 slots. The object is to make a vertical, horizontal\nor diagonal line of four pieces before the opposing player does. The agent\ndesigned in the current study is able to play against a human opponent or\nagainst another AI agent.</p>\n<hr>\n<h2>Introduction</h2>\n<p>In this chapter the rules of the game Connect-Four are described, as well as the\ntask environment. We also introduce a naming convention used throughout this\ntext.</p>\n<h3>The Rules of the Game</h3>\n<p>Connect-Four is a game for two persons. Both players have 21 identical pieces.\nIn the standard form of the game, one set of pieces is red and the other set is\nyellow. The game is played on a vertical, rectangular board consisting of 7\nvertical columns of 6 squares each. If one piece is put in one of the columns,\nit will fall down to the lowest unoccupied square in the column. As soon as a\ncolumn contains 6 pieces, no other piece can be put in the column. Putting a\npiece in one of the columns is called a move.</p>\n<p>The players make their moves in turn. There are no rules stating that the player\nwith, for instance, the red pieces should start. Since it is confusing to\nidentify for each new game the color that started the game, we will assume that\nthe sets of pieces are colored white and black instead of red and yellow. Like\nchess and checkers (and unlike go) it is assumed that the player playing the\nwhite pieces will make the first move.</p>\n<p>Both Players will try to get four connected pieces, horizontally, vertically or\ndiagonally. The first player who achieves one such group of four connected\npieces wins the game. If all 42 pieces are played and no player has achieved\nthis goal, the game is a draw.</p>\n<p>Diagrams 1.1, 1.2 and 1.3 show positions in which White has won the game:</p>\n<figure>\n  <img src=\"/static/images/2003-12-15/1.1.png\" alt=\"Diagram 1.1\" title=\"Diagram 1.1\">\n  <figcaption>Diagram 1.1</figcaption>\n</figure>\n<figure>\n  <img src=\"/static/images/2003-12-15/1.2.png\" alt=\"Diagram 1.2\" title=\"Diagram 1.2\">\n  <figcaption>Diagram 1.2</figcaption>\n</figure>\n<figure>\n  <img src=\"/static/images/2003-12-15/1.3.png\" alt=\"Diagram 1.3\" title=\"Diagram 1.3\">\n  <figcaption>Diagram 1.3</figcaption>\n</figure>\n<p>In the position of diagram 1.1, White has made a horizontal winning group, while\nhis winning groups were respectively vertical and diagonal in the other two\ndiagrams.</p>\n<p>A possible drawn position is shown in the diagram 1.4:</p>\n<figure>\n  <img src=\"/static/images/2003-12-15/1.4.png\" alt=\"Diagram 1.4\" title=\"Diagram 1.4\">\n  <figcaption>Diagram 1.4</figcaption>\n</figure>\n<h3>Task Environment</h3>\n<p>The goal of this study was to create an agent to play the game Connect Four. The\nrules for the game were taken from the classic game of Connect Four. However,\nthe environment and the agent program was created from scratch. On the surface\nthe program functions as a simple Connect Four game playable between two human\nplayers.</p>\n<p>In order to make an appropriate agent design, the task environment must first be\nidentified and described. Table 1.1 is a PEAS description of this task\nenvironment. The task environment can be further categorized by several other\nfactors, such as observability, number of agents, etc. These factors are\ndescribed in Table 1.2.</p>\n<table>\n<thead>\n<tr>\n<th>Agent Type</th>\n<th>Connect Four Playing Software Agent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Performance Measure</td>\n<td>Put four pieces adjacent or diagonal to each other, prevent opponent from doing the same.</td>\n</tr>\n<tr>\n<td>Environment</td>\n<td>Game Board, Agent’s pieces, and Opponent’s pieces.</td>\n</tr>\n<tr>\n<td>Actuators</td>\n<td>Piece placing function.</td>\n</tr>\n<tr>\n<td>Sensors</td>\n<td>Direct access to the state of the board.</td>\n</tr>\n</tbody>\n</table>\n<aside>\n  <a id=\"#table:1.1\"></a>\n  Table 1.1 – A PEAS description of the task environment.\n</aside>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Environment Property</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Fully Observable vs. Partially Observable</td>\n<td align=\"left\">The Connect Four environment is fully observable. The environment consists of the board, which has constant dimensions, and the pieces, which belong to either the player or the opponent. The agent has access to all of this information.</td>\n</tr>\n<tr>\n<td align=\"left\">Deterministic vs. Stochastic</td>\n<td align=\"left\">This environment could be considered deterministic, as there are no random elements at work here. The only unknown is the actions of the opponent. Therefore, the environment can be classified as strategic.</td>\n</tr>\n<tr>\n<td align=\"left\">Episodic vs. Sequential</td>\n<td align=\"left\">The environment could be either episodic or sequential, depending on the algorithm the agent uses. If the algorithm calls for random placement of a piece, then the environment is episodic. However, if the algorithm is more sophisticated, calling for prediction of the opponent’s moves, then the environment is sequential.</td>\n</tr>\n<tr>\n<td align=\"left\">Static vs. Dynamic</td>\n<td align=\"left\">This environment is fully static. Time is not a factor in making the decision as to where to place pieces. Once it is the agent’s turn, the state cannot be changed until it makes its move. The agent is also not penalized as a function of decision time.</td>\n</tr>\n<tr>\n<td align=\"left\">Discrete vs. Continuous</td>\n<td align=\"left\">Connect Four is a fairly simple game with a finite, albeit large, number of different states. Therefore, the environment is decidedly discrete.</td>\n</tr>\n<tr>\n<td align=\"left\">Single agent vs. multi-agent</td>\n<td align=\"left\">In this game, there are two agents at work. From the point of view of the AI agent, there is itself, and another agent. The other agent can either be a human player or another AI agent, which may or may not use the same algorithm. Since both agents (be they human or otherwise) are out to maximize their own performance measure and minimize their opponent’s, the environment is classified as competitive multi-agent.</td>\n</tr>\n</tbody>\n</table>\n<aside>\n  <a id=\"table:1.1\"></a>\n  Table 1.2 – Detailed description of the task environment properties\n</aside>\n<h3>Naming Convention</h3>\n<p>In order to be able to talk about a position, it is useful to give each square a\nname. We have chosen to use a convention as used by chess players. The 7 columns\nare labeled 'a' through 'g' while the rows are numbered 1 through 6. In this way\nthe lowest square in the middle column is called d1.</p>\n<p>It is now possible to make a list of the moves made during a game. For the game\ndiagram 1.1 this could have been:</p>\n<ol>\n<li>d1, d2</li>\n<li>c1, d3</li>\n<li>e1, b1</li>\n<li>f1, White wins.</li>\n</ol>\n<p>It is also easy to use the names of the squares to show where the winning group\nwas created. In diagram 1.1 the winning group was on squares c1, d1, e1 and f1.\nSince the squares must lie on a straight line, it is enough to specify the two\nendpoints of the group. In this case the group can be identified with c1-f1. In\ngeneral the notation <square1><square2> will be used to identify all squares on\nthe line with sqaure1 and square2 as endpoints.</p>\n<h2>Complexity Analysis</h2>\n<p>In this chapter we show why a brute force approach will not be successful at\nthis time.</p>\n<h3>Complexity of the Game</h3>\n<p>In order to get an idea about the complexity of the game an estimate is\npresented of the number of different positions that can be achieved, if the game\nis played according to the rules. A position that can occur during a game is\ncalled a legal position, while a position that cannot be achieved is called\nillegal.</p>\n<p>Each square can be in one of three states: empty, white or black. Therefore it\nis easy to see that the number of possible positions is at most 342 (≥ 1020).\nThis upper bound is a very crude one, and can be brought into better\nproportions.</p>\n<p>If the total number of occupied squares in a given position is odd, the number\nof white pieces is one more than the numbers of black pieces. If the total of\noccupied squares is even, these numbers are equal. Furthermore, if a column\ncontains an empty square, all squares higher than this square are also empty. If\na position contains four connected pieces, the position concludes a game. Since\nthe last move ended the game, at least one of the four squares in the connected\ngroup must be the highest filled square in its column. If this is not the case,\nor both players have connected four pieces, the position is illegal. If one\nplayer has more than one connected group this position can only be legal if\nthese groups share a square that contains the last piece played. In the\ncalculations we are going to make, we do not rule out positions in which are\nillegal for the reasons mentioned above. We also do not rule out positions that\nare not legal, because they cannot be achieved, during normal play. Diagram 2.1\nshows such a position.</p>\n<figure>\n  <img src=\"/static/images/2003-12-15/2.1.png\" alt=\"Diagram 2.1\" title=\"Diagram 2.1\">\n  <figcaption>Diagram 2.1</figcaption>\n</figure>\n<p>Although the position looks perfectly normal, it is clear that Black has made\nthe first move. Therefore it is not legal simply because white is supposed to\nmove first according to the rules.</p>\n<p>We have calculated the number of different positions, including all illegal\npositions which contain too many connected groups of four pieces, and illegal\npositions as shown in diagram 2.1. For the standard 7 x 6 board, an upper bound\nof 7.1 x 1013 is found.</p>\n<p>To determine the amount of memory needed to construct a database for\nConnect-Four this upper bound is useful. In order to show that such a\nconstruction takes too much memory, we need a lower bound instead of an upper\nbound. If we want to find a good lower bound of the number of possible\npositions, we have to make sure that each position we count is legal. Therefore\nall positions which cannot be achieved during normal play, e.g. diagram 2.1,\nshould be ruled out. Diagram 2.2 illustrates the difficulties we are faced with\nin determining if a position is legal.</p>\n<figure>\n  <img src=\"/static/images/2003-12-15/2.2.png\" alt=\"Diagram 2.2\" title=\"Diagram 2.2\">\n  <figcaption>Diagram 2.2</figcaption>\n</figure>\n<p>The position of diagram 2.2 is a draw. Although at first sight it might look\nlike a normal position, it cannot be achieved during normal play. This can be\nseen as follows: the first move White made must have been d1. If Black played as\nhis first move one of b1, d2 and f1, there is no possible second move for White.\nTherefore Black’s second move was one of a1, c1, e1 and g1. Suppose Black played\na1, White then must have played a2 as second move, giving the position of\ndiagram 2.3:</p>\n<figure>\n  <img src=\"/static/images/2003-12-15/2.3.png\" alt=\"Diagram 2.3\" title=\"Diagram 2.3\">\n  <figcaption>Diagram 2.3</figcaption>\n</figure>\n<p>Now Black still cannot have played b1, d2 or f1, for the same reason as before.\nThe move on a3 is not possible either. Therefore Black must have played one of\nthe remaining c1, e1 or g1. After one of these, and after White’s answer to it,\nthe position did not get any better. The furthest we can get with this game is\nshown in diagram 2.4.</p>\n<figure>\n  <img src=\"/static/images/2003-12-15/2.4.png\" alt=\"Diagram 2.4\" title=\"Diagram 2.4\">\n  <figcaption>Diagram 2.4</figcaption>\n</figure>\n<p>In this position Black has to move. For all seven columns, the lower two squares\nshould be filled by black pieces. Therefore after the next move of Black there\nis no move White can make that will eventually result in the position shown in\ndiagram 2.2. Therefore that position is illegal.</p>\n<p>This diagram shows that it can be rather difficult to detect if a position is\nillegal. It is equally difficult to show which of the positions are not legal\nbecause more than one group of four connected pieces is present. We therefore\nassume that a database should contain a large number of illegal positions. We\nbelieve that in that case the order of magnitude of the upper bound presented\nbefore, is a good estimate for the magnitude of the database. This number is by\nfar too big to think seriously about making a database for Connect-Four. To see\nthis, we have to consider the number of positions that must be stored at the\nsame time when we build the database. When a retrograde analysis is applied, as\nhas been done for many endgames in chess, we need not necessarily store the\npositions consisting of, say, 20 pieces, as long as we have not yet determined\nthe value of all positions of 21 pieces. When we have determined the value of\nthese positions, we no longer need the positions consisting of 22 pieces or\nmore. Therefore we only need to be able to store all positions of n and n+1\npieces at the same time. For the 7 x 6 board, this means that we must be able to\nhold all positions of 36 and 37 pieces at the same time, a total over 1.6 x 1013\npositions. We can store the value of a position in 2 bits, since we have 4\npossible states: win for White, win for Black, draw or not checked (we can use\nthe address of the 2 bits as identification for the position). This way we need\nat least 4 Terabyte. Therefore making a database does not yet seem realistic.</p>\n<h2>Development</h2>\n<h3>Interface</h3>\n<p>The interface of the game program consists of two parts, the menu, and the game\nboard. The menu gives the user access to the game controls, such as setting\nwhich AI algorithm to use, and which players will be controlled by humans and\nwhich by AI agents. One interesting feature of this particular design is that\none can begin a game with two human players, and set up the board any way they\nlike. Then one or both of the players can be switched to AI agents, in order to\nsee how they react to different initial configurations of the board.</p>\n<p>Once the players are set, the user can begin a new game. The game board is set\nto the initial configuration of all empty squares. Players then take turns\ndropping pieces into the 7 columns of the game board. Human players make moves\nby clicking the button above the desired row. This design was favored over other\ninterfaces, such as clicking directly on the game board, partially because of\ntime restraints, and partially because it more closely approximates the way the\nreal game is played, by dropping pieces into the top of the board. The AI\nagents, of course, automatically make their moves, so their pieces appear very\nsoon after the opponent makes their move. Since the AI agents are very fast at\nmaking their decisions, AI vs. AI games of Connect Four are for the most part\nvery short.</p>\n<p>When the game is over, a window pops up that notifies the user of the outcome.\nIf the game results in a win for some player, the message states that that\nplayer has won. However, if the game ends in a draw, then this message is\nrelayed to the user instead. From that point, the user can either quit or begin\na new game.</p>\n<p>As a side note, in early versions of the program, there was one other form of\ninterface present. The list of moves in sequential order was output to a text\nwindow, along with system messages such as which player was victorious. This\nlist of moves proved very valuable for the debugging process. At one point, when\npitting AI agents against each other, the program became stuck in an infinite\nloop. It was very beneficial to be able to see what moves led up to the loop and\nwhat moves the AI was trying to make during the loop.</p>\n<h3>Design</h3>\n<p>This design is both intuitive and minimal. The GUI was written in Java/Swing, a\ntoolkit provided by Java, as seen below in diagram 3.1.</p>\n<figure>\n  <img src=\"/static/images/2003-12-15/3.1.png\" alt=\"Diagram 3.1\" title=\"Diagram 3.1\">\n  <figcaption>Diagram 3.1</figcaption>\n</figure>\n<h2>Artificial Intelligence</h2>\n<p>The computer AI opponent of the program is configurable to different difficulty\nlevels. Each difficulty level represents a different algorithm. There are four\ndifferent difficulty levels in this version of the program; Random (easy),\nDefensive, Aggressive, and Minimax (difficult).</p>\n<h3>Random AI</h3>\n<p>The Random AI algorithm simply places pieces randomly each turn. This algorithm\ncan be defeated easily by human players and by the other AI algorithms. It is\nalso the only one that is non-deterministic. Since it randomly places pieces,\nthe move progression will be different each time this algorithm plays. As\ndescribed below, the Random algorithm is the only one with this characteristic.</p>\n<h3>Defensive AI</h3>\n<p>The defensive AI algorithm uses a heuristic function to determine what the next\nmove should be. It looks at the current state of the board and assigns a value\nto each of the available moves. The higher this value is, the more dangerous it\nis not to move there. For instance, if the opponent has three pieces in a row, a\nvalue of 8 is given to the space that would complete the opponent’s\nfour-in-a-row. If the opponent has two pieces in a row, a value of four might be\ngiven to the adjacent square. The point of this algorithm is to block the\nopponent from getting four in a row at all costs.</p>\n<h3>Aggressive AI</h3>\n<p>The Aggressive AI algorithm uses the same type of heuristic function used by the\ndefensive algorithm, with one key difference. The defensive algorithm only\napplies the heuristic function to the opponent’s pieces on the board. The\naggressive algorithm applies it to both the opponent’s pieces and its own\npieces. Thus it simultaneously defends against potentially losing situations by\nblocking the opponent from winning, and makes offensive moves maximizing the\nnumber of pieces it has in a row. Skilled human players are still able to defeat\nthis algorithm fairly easily, however, since it does not look very far ahead in\nthe game tree.</p>\n<h3>Minimax AI</h3>\n<p>This algorithm was initially going to use the minimax algorithm (as implemented\nin Artificial Intelligence: A Modern Approach) to search the game tree for the\noptimal move. However, the tree proved to be too massive to search in this way,\ndue to computational limitations. One possible solution to this problem was the\nalpha-beta pruning algorithm, in which game subtrees are eliminated to cut down\non the number of computations. However, this idea was passed over for a\nsimplified version of the minimax algorithm. Instead of searching the entire\ngame tree, the algorithm used in the final version of the program only searches\nthe tree up to a certain point. So, in effect, the algorithm is looking four\nmoves ahead and making the best move based on that knowledge. The decision to\nlimit the lookahead to four levels was made because it is about equal to the\nnumber of moves a skilled player can look ahead, and it is a good match for the\ncurrent power of processing technology. Thus the Minimax AI is a good match for\na skilled human player.</p>\n<h2>Results</h2>\n<p>One of the primary functions of this study was to learn about how the different\nAI algorithms perform against one another. Due to the short length of the\nmatches played between to AI players, many trials were able to be conducted.\nTable 5.1 is a brief summary of how the different algorithms interact.</p>\n<table>\n<thead>\n<tr>\n<th>Condition</th>\n<th>Winner (most often)</th>\n<th>Comments</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Random vs. Any Other</td>\n<td>Any other</td>\n<td>Since random play is seldom successful, Random AI is most often defeated. However, it can and sometimes does win against stronger AI.</td>\n</tr>\n<tr>\n<td>Defensive vs. Defensive, Aggressive vs. Aggressive</td>\n<td>Draw</td>\n<td>It was hypothesized that whichever player went first would win most often. However, more often than not the game ended in a draw. For those games that did not end in a draw, no player won significantly more than the other.</td>\n</tr>\n<tr>\n<td>Defensive vs. Aggressive</td>\n<td>Aggressive</td>\n<td>Since Aggressive AI takes into account more of the state than the Defensive, Aggressive will always prevail.</td>\n</tr>\n<tr>\n<td>Defensive or Aggressive vs. Minimax</td>\n<td>Minimax</td>\n<td>Since Minimax is able to look ahead four moves, it will usually defeat both Defensive and Aggressive. There are some instances where the game will end in a draw.</td>\n</tr>\n<tr>\n<td>Minimax vs. Minimax</td>\n<td>Player 2</td>\n<td>For some coincidental reason, when Minimax is pitted against itself, the second player always wins, and the same game is always played. This may be due to the fact that the entire game tree is not searched, so the algorithm is not perfect.</td>\n</tr>\n</tbody>\n</table>\n<aside>\n  Table 5.1 – A summary of the results of AI vs. AI games.\n</aside>\n<h2>Conclusion</h2>\n<p>Above all else, this study was designed so that the authors could learn more\nabout AI. This goal was successfully accomplished. The specific area in which\nthe most experience was gained is that of computer game playing agent design.\nWhile the algorithm best suited to success may be impossible to execute with\ncurrent technology, other algorithms are just as suitable to make for an\ninteresting playing experience. This is an important game design concept,\nbecause more often than not, people want to win games they play. Therefore, if\nthe computer AI always wins because the algorithm is perfect, the game will\nsuffer from lack of human interest.</p>\n<p>Heuristic algorithms like the Defensive and Aggressive algorithms outlined in\nthis study are very well suited to solve this problem. Since they do not always\nwin, but sometimes trick a human player, they retain a human player’s interest.\nAs long as no one programs a heuristic algorithm to become frustrated at losing,\nthey will remain one of the best solutions to a computer game-playing problem.</p>\n<h2>References</h2>\n<cite class=\"hanging-indent\" id=\"cite:4\">\nRussell, S., Norvig, P.\n<em>Artificial Intelligence, A Modern Approach</em>.\nThird Edition\nPearson Education, Inc.\nPrentice Hall.\nPrint.\n2003.\n</cite>\n<cite class=\"hanging-indent\" id=\"cite:1\">\nFlanagan, D.\n<em>Java in a Nutshell</em>.\nThird Edition.\nO’Reilly & Associates, Inc. \nPrint.\n1999.\n</cite>\n<cite class=\"hanging-indent\" id=\"cite:2\">\nKnudsen, J.\n<em>Java 2D Graphics</em>.\nO’Reilly & Associates, Inc.\nPrint.\n1999.\n</cite>\n<cite class=\"hanging-indent\" id=\"cite:3\">\nMilton-Bradley, Inc. Connect Four Game, Hasbro, Inc.\n</cite>\n<aside>\n  All source code is available at\n  <a href=\"https://github.com/0xadada/smart-connect-four\">GitHub</a>.\n</aside>\n","slug":"2003-12-15-connect-four-playing-ai-agent","license":"cc-by"}},"__N_SSG":true}