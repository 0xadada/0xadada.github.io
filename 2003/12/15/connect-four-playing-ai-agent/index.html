<!DOCTYPE html><html lang="en-US"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" href="/static/images/2003-12-15/1.1.png"/><link rel="preload" as="image" href="/static/images/2003-12-15/1.2.png"/><link rel="preload" as="image" href="/static/images/2003-12-15/1.3.png"/><link rel="preload" as="image" href="/static/images/2003-12-15/1.4.png"/><link rel="preload" as="image" href="/static/images/2003-12-15/2.1.png"/><link rel="preload" as="image" href="/static/images/2003-12-15/2.2.png"/><link rel="preload" as="image" href="/static/images/2003-12-15/2.3.png"/><link rel="preload" as="image" href="/static/images/2003-12-15/2.4.png"/><link rel="preload" as="image" href="/static/images/2003-12-15/3.1.png"/><link rel="stylesheet" href="/_next/static/css/60d5ae1a4351e98a.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/01f63581d77a7b07.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-e2bcd3b450e10a5e.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-cc48c28d170fddc2.js" async="" crossorigin=""></script><script src="/_next/static/chunks/69-0a6331c18b0d37aa.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-715e3a652bc6b546.js" async="" crossorigin=""></script><script src="/_next/static/chunks/250-d7e0a94ebe194dac.js" async=""></script><script src="/_next/static/chunks/app/page-84b663e6d1625d16.js" async=""></script><script src="/_next/static/chunks/749-1aefd436964833c3.js" async=""></script><script src="/_next/static/chunks/app/layout-8a3d32e7172cce23.js" async=""></script><title>A Connect Four Playing AI Agent: Algorithm and Creation Process</title><meta name="description" content="This paper documents the creation and testing of a game playing artificial intelligence (AI) agent program.  The agent is designed to play a game of Connect Four by Milton-Bradely."/><link rel="author" href="https://0xadada.pub"/><meta name="author" content="0xADADA"/><meta name="keywords" content="projects,artificial intelligence,software engineering"/><link rel="alternate" type="application/rss+xml" href="https://0xadada.pub/rss.xml"/><meta property="og:title" content="A Connect Four Playing AI Agent: Algorithm and Creation Process"/><meta property="og:description" content="This paper documents the creation and testing of a game playing artificial intelligence (AI) agent program.  The agent is designed to play a game of Connect Four by Milton-Bradely."/><meta property="og:url" content="https://0xadada.pub/2003/12/15/connect-four-playing-ai-agent/"/><meta property="og:site_name" content="0xADADA"/><meta property="og:locale" content="en_US"/><meta property="og:image" content="https://0xadada.pub/static/images/meta/avatar.svg"/><meta property="og:image:width" content="660"/><meta property="og:image:height" content="660"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="A Connect Four Playing AI Agent: Algorithm and Creation Process"/><meta name="twitter:description" content="This paper documents the creation and testing of a game playing artificial intelligence (AI) agent program.  The agent is designed to play a game of Connect Four by Milton-Bradely."/><meta name="twitter:image" content="https://0xadada.pub/static/images/meta/avatar.svg"/><meta name="twitter:image:width" content="660"/><meta name="twitter:image:height" content="660"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="48x48"/><link rel="apple-touch-icon" href="/apple-icon.png?b764b3a1dbf00a82" type="image/png" sizes="180x180"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body><main class="layout_layout__dCqca"><article class="hentry h-entry"><header><h1 class="entry-title p-name">A Connect Four Playing AI Agent: Algorithm and Creation Process</h1><time class="display-date_published__A_L_d dt-published" dateTime="2003-12-15T00:00:00.000Z">Monday December 15, 2003</time><span class="h-card page_byline__wbXsN"> by <span class="fn p-author p-name">0xADADA</span></span></header><div class="entry-content e-content"><center>0xADADA, Erik Ibsen, Chen Zhang <br/> Khoury College of Computer Sciences <br/> Northeastern University Boston, MA </center>
<hr/>
<p>This paper documents the creation and testing of a game playing artificial
intelligence (AI) agent program. The agent is designed to play a game of Connect
Four by Milton-Bradley. The game is played by dropping pieces into a game board
consisting of a grid of 6x7 slots. The object is to make a vertical, horizontal
or diagonal line of four pieces before the opposing player does. The agent
designed in the current study is able to play against a human opponent or
against another AI agent.</p>
<hr/>
<h2 id="introduction">Introduction</h2>
<p>In this chapter the rules of the game Connect-Four are described, as well as the
task environment. We also introduce a naming convention used throughout this
text.</p>
<h3 id="the-rules-of-the-game">The Rules of the Game</h3>
<p>Connect-Four is a game for two persons. Both players have 21 identical pieces.
In the standard form of the game, one set of pieces is red and the other set is
yellow. The game is played on a vertical, rectangular board consisting of 7
vertical columns of 6 squares each. If one piece is put in one of the columns,
it will fall down to the lowest unoccupied square in the column. As soon as a
column contains 6 pieces, no other piece can be put in the column. Putting a
piece in one of the columns is called a move.</p>
<p>The players make their moves in turn. There are no rules stating that the player
with, for instance, the red pieces should start. Since it is confusing to
identify for each new game the color that started the game, we will assume that
the sets of pieces are colored white and black instead of red and yellow. Like
chess and checkers (and unlike go) it is assumed that the player playing the
white pieces will make the first move.</p>
<p>Both Players will try to get four connected pieces, horizontally, vertically or
diagonally. The first player who achieves one such group of four connected
pieces wins the game. If all 42 pieces are played and no player has achieved
this goal, the game is a draw.</p>
<p>Diagrams 1.1, 1.2 and 1.3 show positions in which White has won the game:</p>
<figure><img src="/static/images/2003-12-15/1.1.png" alt="Diagram 1.1" title="Diagram 1.1"/><figcaption>Diagram 1.1</figcaption></figure>
<figure><img src="/static/images/2003-12-15/1.2.png" alt="Diagram 1.2" title="Diagram 1.2"/><figcaption>Diagram 1.2</figcaption></figure>
<figure><img src="/static/images/2003-12-15/1.3.png" alt="Diagram 1.3" title="Diagram 1.3"/><figcaption>Diagram 1.3</figcaption></figure>
<p>In the position of diagram 1.1, White has made a horizontal winning group, while
his winning groups were respectively vertical and diagonal in the other two
diagrams.</p>
<p>A possible drawn position is shown in the diagram 1.4:</p>
<figure><img src="/static/images/2003-12-15/1.4.png" alt="Diagram 1.4" title="Diagram 1.4"/><figcaption>Diagram 1.4</figcaption></figure>
<h3 id="task-environment">Task Environment</h3>
<p>The goal of this study was to create an agent to play the game Connect Four. The
rules for the game were taken from the classic game of Connect Four. However,
the environment and the agent program was created from scratch. On the surface
the program functions as a simple Connect Four game playable between two human
players.</p>
<p>In order to make an appropriate agent design, the task environment must first be
identified and described. Table 1.1 is a PEAS description of this task
environment. The task environment can be further categorized by several other
factors, such as observability, number of agents, etc. These factors are
described in Table 1.2.</p>
<table><thead><tr><th>Agent Type</th><th>Connect Four Playing Software Agent</th></tr></thead><tbody><tr><td>Performance Measure</td><td>Put four pieces adjacent or diagonal to each other, prevent opponent from doing the same.</td></tr><tr><td>Environment</td><td>Game Board, Agent‚Äôs pieces, and Opponent‚Äôs pieces.</td></tr><tr><td>Actuators</td><td>Piece placing function.</td></tr><tr><td>Sensors</td><td>Direct access to the state of the board.</td></tr></tbody></table>
<em><a id="#table:1.1"></a><p>Table 1.1 ‚Äì A PEAS description of the task environment.</p></em>
<table><thead><tr><th align="left">Environment Property</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">Fully Observable vs. Partially Observable</td><td align="left">The Connect Four environment is fully observable. The environment consists of the board, which has constant dimensions, and the pieces, which belong to either the player or the opponent. The agent has access to all of this information.</td></tr><tr><td align="left">Deterministic vs. Stochastic</td><td align="left">This environment could be considered deterministic, as there are no random elements at work here. The only unknown is the actions of the opponent. Therefore, the environment can be classified as strategic.</td></tr><tr><td align="left">Episodic vs. Sequential</td><td align="left">The environment could be either episodic or sequential, depending on the algorithm the agent uses. If the algorithm calls for random placement of a piece, then the environment is episodic. However, if the algorithm is more sophisticated, calling for prediction of the opponent‚Äôs moves, then the environment is sequential.</td></tr><tr><td align="left">Static vs. Dynamic</td><td align="left">This environment is fully static. Time is not a factor in making the decision as to where to place pieces. Once it is the agent‚Äôs turn, the state cannot be changed until it makes its move. The agent is also not penalized as a function of decision time.</td></tr><tr><td align="left">Discrete vs. Continuous</td><td align="left">Connect Four is a fairly simple game with a finite, albeit large, number of different states. Therefore, the environment is decidedly discrete.</td></tr><tr><td align="left">Single agent vs. multi-agent</td><td align="left">In this game, there are two agents at work. From the point of view of the AI agent, there is itself, and another agent. The other agent can either be a human player or another AI agent, which may or may not use the same algorithm. Since both agents (be they human or otherwise) are out to maximize their own performance measure and minimize their opponent‚Äôs, the environment is classified as competitive multi-agent.</td></tr></tbody></table>
<em><a id="table:1.1"></a><p>Table 1.2 ‚Äì Detailed description of the task environment properties</p></em>
<h3 id="naming-convention">Naming Convention</h3>
<p>In order to be able to talk about a position, it is useful to give each square a
name. We have chosen to use a convention as used by chess players. The 7 columns
are labeled ‚Äòa‚Äô through ‚Äòg‚Äô while the rows are numbered 1 through 6. In this way
the lowest square in the middle column is called d1.</p>
<p>It is now possible to make a list of the moves made during a game. For the game
diagram 1.1 this could have been:</p>
<ol>
<li>d1, d2</li>
<li>c1, d3</li>
<li>e1, b1</li>
<li>f1, White wins.</li>
</ol>
<p>It is also easy to use the names of the squares to show where the winning group
was created. In diagram 1.1 the winning group was on squares c1, d1, e1 and f1.
Since the squares must lie on a straight line, it is enough to specify the two
endpoints of the group. In this case the group can be identified with c1-f1. In
general the notation <code>square1</code> <code>square2</code> will be used to identify all squares on
the line with sqaure1 and square2 as endpoints.</p>
<h2 id="complexity-analysis">Complexity Analysis</h2>
<p>In this chapter we show why a brute force approach will not be successful at
this time.</p>
<h3 id="complexity-of-the-game">Complexity of the Game</h3>
<p>In order to get an idea about the complexity of the game an estimate is
presented of the number of different positions that can be achieved, if the game
is played according to the rules. A position that can occur during a game is
called a legal position, while a position that cannot be achieved is called
illegal.</p>
<p>Each square can be in one of three states: empty, white or black. Therefore it
is easy to see that the number of possible positions is at most 342 (‚â• 1020).
This upper bound is a very crude one, and can be brought into better
proportions.</p>
<p>If the total number of occupied squares in a given position is odd, the number
of white pieces is one more than the numbers of black pieces. If the total of
occupied squares is even, these numbers are equal. Furthermore, if a column
contains an empty square, all squares higher than this square are also empty. If
a position contains four connected pieces, the position concludes a game. Since
the last move ended the game, at least one of the four squares in the connected
group must be the highest filled square in its column. If this is not the case,
or both players have connected four pieces, the position is illegal. If one
player has more than one connected group this position can only be legal if
these groups share a square that contains the last piece played. In the
calculations we are going to make, we do not rule out positions in which are
illegal for the reasons mentioned above. We also do not rule out positions that
are not legal, because they cannot be achieved, during normal play. Diagram 2.1
shows such a position.</p>
<figure><img src="/static/images/2003-12-15/2.1.png" alt="Diagram 2.1" title="Diagram 2.1"/><figcaption>Diagram 2.1</figcaption></figure>
<p>Although the position looks perfectly normal, it is clear that Black has made
the first move. Therefore it is not legal simply because white is supposed to
move first according to the rules.</p>
<p>We have calculated the number of different positions, including all illegal
positions which contain too many connected groups of four pieces, and illegal
positions as shown in diagram 2.1. For the standard 7 x 6 board, an upper bound
of 7.1 x 1013 is found.</p>
<p>To determine the amount of memory needed to construct a database for
Connect-Four this upper bound is useful. In order to show that such a
construction takes too much memory, we need a lower bound instead of an upper
bound. If we want to find a good lower bound of the number of possible
positions, we have to make sure that each position we count is legal. Therefore
all positions which cannot be achieved during normal play, e.g. diagram 2.1,
should be ruled out. Diagram 2.2 illustrates the difficulties we are faced with
in determining if a position is legal.</p>
<figure><img src="/static/images/2003-12-15/2.2.png" alt="Diagram 2.2" title="Diagram 2.2"/><figcaption>Diagram 2.2</figcaption></figure>
<p>The position of diagram 2.2 is a draw. Although at first sight it might look
like a normal position, it cannot be achieved during normal play. This can be
seen as follows: the first move White made must have been d1. If Black played as
his first move one of b1, d2 and f1, there is no possible second move for White.
Therefore Black‚Äôs second move was one of a1, c1, e1 and g1. Suppose Black played
a1, White then must have played a2 as second move, giving the position of
diagram 2.3:</p>
<figure><img src="/static/images/2003-12-15/2.3.png" alt="Diagram 2.3" title="Diagram 2.3"/><figcaption>Diagram 2.3</figcaption></figure>
<p>Now Black still cannot have played b1, d2 or f1, for the same reason as before.
The move on a3 is not possible either. Therefore Black must have played one of
the remaining c1, e1 or g1. After one of these, and after White‚Äôs answer to it,
the position did not get any better. The furthest we can get with this game is
shown in diagram 2.4.</p>
<figure><img src="/static/images/2003-12-15/2.4.png" alt="Diagram 2.4" title="Diagram 2.4"/><figcaption>Diagram 2.4</figcaption></figure>
<p>In this position Black has to move. For all seven columns, the lower two squares
should be filled by black pieces. Therefore after the next move of Black there
is no move White can make that will eventually result in the position shown in
diagram 2.2. Therefore that position is illegal.</p>
<p>This diagram shows that it can be rather difficult to detect if a position is
illegal. It is equally difficult to show which of the positions are not legal
because more than one group of four connected pieces is present. We therefore
assume that a database should contain a large number of illegal positions. We
believe that in that case the order of magnitude of the upper bound presented
before, is a good estimate for the magnitude of the database. This number is by
far too big to think seriously about making a database for Connect-Four. To see
this, we have to consider the number of positions that must be stored at the
same time when we build the database. When a retrograde analysis is applied, as
has been done for many endgames in chess, we need not necessarily store the
positions consisting of, say, 20 pieces, as long as we have not yet determined
the value of all positions of 21 pieces. When we have determined the value of
these positions, we no longer need the positions consisting of 22 pieces or
more. Therefore we only need to be able to store all positions of n and n+1
pieces at the same time. For the 7 x 6 board, this means that we must be able to
hold all positions of 36 and 37 pieces at the same time, a total over 1.6 x 1013
positions. We can store the value of a position in 2 bits, since we have 4
possible states: win for White, win for Black, draw or not checked (we can use
the address of the 2 bits as identification for the position). This way we need
at least 4 Terabyte. Therefore making a database does not yet seem realistic.</p>
<h2 id="development">Development</h2>
<h3 id="interface">Interface</h3>
<p>The interface of the game program consists of two parts, the menu, and the game
board. The menu gives the user access to the game controls, such as setting
which AI algorithm to use, and which players will be controlled by humans and
which by AI agents. One interesting feature of this particular design is that
one can begin a game with two human players, and set up the board any way they
like. Then one or both of the players can be switched to AI agents, in order to
see how they react to different initial configurations of the board.</p>
<p>Once the players are set, the user can begin a new game. The game board is set
to the initial configuration of all empty squares. Players then take turns
dropping pieces into the 7 columns of the game board. Human players make moves
by clicking the button above the desired row. This design was favored over other
interfaces, such as clicking directly on the game board, partially because of
time restraints, and partially because it more closely approximates the way the
real game is played, by dropping pieces into the top of the board. The AI
agents, of course, automatically make their moves, so their pieces appear very
soon after the opponent makes their move. Since the AI agents are very fast at
making their decisions, AI vs. AI games of Connect Four are for the most part
very short.</p>
<p>When the game is over, a window pops up that notifies the user of the outcome.
If the game results in a win for some player, the message states that that
player has won. However, if the game ends in a draw, then this message is
relayed to the user instead. From that point, the user can either quit or begin
a new game.</p>
<p>As a side note, in early versions of the program, there was one other form of
interface present. The list of moves in sequential order was output to a text
window, along with system messages such as which player was victorious. This
list of moves proved very valuable for the debugging process. At one point, when
pitting AI agents against each other, the program became stuck in an infinite
loop. It was very beneficial to be able to see what moves led up to the loop and
what moves the AI was trying to make during the loop.</p>
<h3 id="design">Design</h3>
<p>This design is both intuitive and minimal. The GUI was written in Java/Swing, a
toolkit provided by Java, as seen below in diagram 3.1.</p>
<figure><img src="/static/images/2003-12-15/3.1.png" alt="Diagram 3.1" title="Diagram 3.1"/><figcaption>Diagram 3.1</figcaption></figure>
<h2 id="artificial-intelligence">Artificial Intelligence</h2>
<p>The computer AI opponent of the program is configurable to different difficulty
levels. Each difficulty level represents a different algorithm. There are four
different difficulty levels in this version of the program; Random (easy),
Defensive, Aggressive, and Minimax (difficult).</p>
<h3 id="random-ai">Random AI</h3>
<p>The Random AI algorithm simply places pieces randomly each turn. This algorithm
can be defeated easily by human players and by the other AI algorithms. It is
also the only one that is non-deterministic. Since it randomly places pieces,
the move progression will be different each time this algorithm plays. As
described below, the Random algorithm is the only one with this characteristic.</p>
<h3 id="defensive-ai">Defensive AI</h3>
<p>The defensive AI algorithm uses a heuristic function to determine what the next
move should be. It looks at the current state of the board and assigns a value
to each of the available moves. The higher this value is, the more dangerous it
is not to move there. For instance, if the opponent has three pieces in a row, a
value of 8 is given to the space that would complete the opponent‚Äôs
four-in-a-row. If the opponent has two pieces in a row, a value of four might be
given to the adjacent square. The point of this algorithm is to block the
opponent from getting four in a row at all costs.</p>
<h3 id="aggressive-ai">Aggressive AI</h3>
<p>The Aggressive AI algorithm uses the same type of heuristic function used by the
defensive algorithm, with one key difference. The defensive algorithm only
applies the heuristic function to the opponent‚Äôs pieces on the board. The
aggressive algorithm applies it to both the opponent‚Äôs pieces and its own
pieces. Thus it simultaneously defends against potentially losing situations by
blocking the opponent from winning, and makes offensive moves maximizing the
number of pieces it has in a row. Skilled human players are still able to defeat
this algorithm fairly easily, however, since it does not look very far ahead in
the game tree.</p>
<h3 id="minimax-ai">Minimax AI</h3>
<p>This algorithm was initially going to use the minimax algorithm (as implemented
in Artificial Intelligence: A Modern Approach) to search the game tree for the
optimal move. However, the tree proved to be too massive to search in this way,
due to computational limitations. One possible solution to this problem was the
alpha-beta pruning algorithm, in which game subtrees are eliminated to cut down
on the number of computations. However, this idea was passed over for a
simplified version of the minimax algorithm. Instead of searching the entire
game tree, the algorithm used in the final version of the program only searches
the tree up to a certain point. So, in effect, the algorithm is looking four
moves ahead and making the best move based on that knowledge. The decision to
limit the lookahead to four levels was made because it is about equal to the
number of moves a skilled player can look ahead, and it is a good match for the
current power of processing technology. Thus the Minimax AI is a good match for
a skilled human player.</p>
<h2 id="results">Results</h2>
<p>One of the primary functions of this study was to learn about how the different
AI algorithms perform against one another. Due to the short length of the
matches played between to AI players, many trials were able to be conducted.
Table 5.1 is a brief summary of how the different algorithms interact.</p>
<table><thead><tr><th>Condition</th><th>Winner (most often)</th><th>Comments</th></tr></thead><tbody><tr><td>Random vs. Any Other</td><td>Any other</td><td>Since random play is seldom successful, Random AI is most often defeated. However, it can and sometimes does win against stronger AI.</td></tr><tr><td>Defensive vs. Defensive, Aggressive vs. Aggressive</td><td>Draw</td><td>It was hypothesized that whichever player went first would win most often. However, more often than not the game ended in a draw. For those games that did not end in a draw, no player won significantly more than the other.</td></tr><tr><td>Defensive vs. Aggressive</td><td>Aggressive</td><td>Since Aggressive AI takes into account more of the state than the Defensive, Aggressive will always prevail.</td></tr><tr><td>Defensive or Aggressive vs. Minimax</td><td>Minimax</td><td>Since Minimax is able to look ahead four moves, it will usually defeat both Defensive and Aggressive. There are some instances where the game will end in a draw.</td></tr><tr><td>Minimax vs. Minimax</td><td>Player 2</td><td>For some coincidental reason, when Minimax is pitted against itself, the second player always wins, and the same game is always played. This may be due to the fact that the entire game tree is not searched, so the algorithm is not perfect.</td></tr></tbody></table>
<em><p>Table 5.1 ‚Äì A summary of the results of AI vs. AI games.</p></em>
<h2 id="conclusion">Conclusion</h2>
<p>Above all else, this study was designed so that the authors could learn more
about AI. This goal was successfully accomplished. The specific area in which
the most experience was gained is that of computer game playing agent design.
While the algorithm best suited to success may be impossible to execute with
current technology, other algorithms are just as suitable to make for an
interesting playing experience. This is an important game design concept,
because more often than not, people want to win games they play. Therefore, if
the computer AI always wins because the algorithm is perfect, the game will
suffer from lack of human interest.</p>
<p>Heuristic algorithms like the Defensive and Aggressive algorithms outlined in
this study are very well suited to solve this problem. Since they do not always
win, but sometimes trick a human player, they retain a human player‚Äôs interest.
As long as no one programs a heuristic algorithm to become frustrated at losing,
they will remain one of the best solutions to a computer game-playing problem.</p>
<h2 id="references">References</h2>
<cite class="hanging-indent" id="cite:4"><p>Russell, S., Norvig, P.
<em>Artificial Intelligence, A Modern Approach</em>.
Third Edition
Pearson Education, Inc.
Prentice Hall.
Print.
2003.</p></cite>
<cite class="hanging-indent" id="cite:1"><p>Flanagan, D.
<em>Java in a Nutshell</em>.
Third Edition.
O‚ÄôReilly &amp; Associates, Inc.
Print.
1999.</p></cite>
<cite class="hanging-indent" id="cite:2"><p>Knudsen, J.
<em>Java 2D Graphics</em>.
O‚ÄôReilly &amp; Associates, Inc.
Print.
1999.</p></cite>
<cite class="hanging-indent" id="cite:3"><p>Milton-Bradley, Inc. Connect Four Game, Hasbro, Inc.</p></cite>
<aside><p>All source code is available at
<a href="https://github.com/0xadada/smart-connect-four">GitHub</a>.</p></aside></div><footer class="license_copyright__EpMnZ">This is licensed under a Creative Commons <!-- -->cc-by<!-- --> International License</footer></article></main><footer class="footer_footer__woFMY layout_layout__dCqca"><nav><p>¬© 2003-<!-- -->2024<!-- --> 0xADADA (unless otherwise noted.)<br/><span class="h-card"><span class="p-note" hidden="">0xADADA is a Software Engineer / Writer / Motorsports Driver exploring the impact of the attention economy on idleness, time, and lived experience. üßë‚Äçüíªüîßüöó‚úçÔ∏èüîí</span><a class="u-url u-uid" title="0xADADA" href="https://0xadada.pub/">0xADADA</a> <a class="c-Meta u-email" rel="me" title="0xADADA" href="mailto:0xadada.pub@protonmail.com">Email</a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on Warpcast" href="https://warpcast.com/0xadada">Farcaster</a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on Mastodon" href="https://mastodon.cloud/@0xADADA">Mastodon</a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on Bluesky" href="https://bsky.app/profile/0xadada.bsky.social">Bluesky</a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on Twitter" href="https://twitter.com/0xadada"><del>Twitter</del></a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on GitHub" href="https://github.com/0xadada">GitHub</a> <a class="u-url" rel="me nofollow external noopener" title="0xADADA on Goodreads" href="https://www.goodreads.com/review/list/60524683-0xadada?shelf=wanted">Goodreads</a> <a href="/colophon/">Colophon</a> <a href="/rss.xml">RSS</a> <img alt="0xADADA icon" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="u-photo" style="color:transparent;margin-bottom:-0.125rem" src="/static/images/meta/avatar.svg"/></span></p></nav><form action="https://buttondown.email/api/emails/embed-subscribe/0xadada" method="post" target="popupwindow"><label for="email">Sign up to get emailed when I write new things:<!-- --> </label><input type="email" id="email" name="email"/><input type="submit" value="Subscribe"/></form></footer><script src="/_next/static/chunks/webpack-e2bcd3b450e10a5e.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/60d5ae1a4351e98a.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:HL[\"/_next/static/css/01f63581d77a7b07.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"4:I[7690,[],\"\"]\n7:I[5613,[],\"\"]\n9:I[1778,[],\"\"]\na:I[5250,[\"250\",\"static/chunks/250-d7e0a94ebe194dac.js\",\"931\",\"static/chunks/app/page-84b663e6d1625d16.js\"],\"\"]\nb:I[1749,[\"250\",\"static/chunks/250-d7e0a94ebe194dac.js\",\"749\",\"static/chunks/749-1aefd436964833c3.js\",\"185\",\"static/chunks/app/layout-8a3d32e7172cce23.js\"],\"Image\"]\nd:I[8955,[],\"\"]\n8:[\"slug\",\"2003/12/15/connect-four-playing-ai-agent\",\"c\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/60d5ae1a4351e98a.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L4\",null,{\"buildId\":\"DfKcGP5FYCiGzmZp5oNcL\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/2003/12/15/connect-four-playing-ai-agent/\",\"initialTree\":[\"\",{\"children\":[[\"slug\",\"2003/12/15/connect-four-playing-ai-agent\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"2003\\\",\\\"12\\\",\\\"15\\\",\\\"connect-four-playing-ai-agent\\\"]}\",{}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"slug\",\"2003/12/15/connect-four-playing-ai-agent\",\"c\"],{\"children\":[\"__PAGE__\",{},[\"$L5\",\"$L6\",null]]},[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$8\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/01f63581d77a7b07.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}]]},[null,[\"$\",\"html\",null,{\"lang\":\"en-US\",\"children\":[\"$\",\"body\",null,{\"children\":[[\"$\",\"main\",null,{\"className\":\"layout_layout__dCqca\",\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"styles\":null}]}],[\"$\",\"footer\",null,{\"className\":\"footer_footer__woFMY layout_layout__dCqca\",\"children\":[[\"$\",\"nav\",null,{\"children\":[\"$\",\"p\",null,{\"children\":[\"¬© 2003-\",\"2024\",\" 0xADADA (unless otherwise noted.)\",[\"$\",\"br\",null,{}],[\"$\",\"span\",null,{\"className\":\"h-card\",\"children\":[[\"$\",\"span\",null,{\"className\":\"p-note\",\"hidden\":true,\"children\":\"0xADADA is a Software Engineer / Writer / Motorsports Driver exploring the impact of the attention economy on idleness, time, and lived experience. üßë‚Äçüíªüîßüöó‚úçÔ∏èüîí\"}],[\"$\",\"$La\",null,{\"className\":\"u-url u-uid\",\"href\":\"https://0xadada.pub/\",\"title\":\"0xADADA\",\"children\":\"0xADADA\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"mailto:0xadada.pub@protonmail.com\",\"className\":\"c-Meta u-email\",\"rel\":\"me\",\"title\":\"0xADADA\",\"children\":\"Email\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://warpcast.com/0xadada\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on Warpcast\",\"children\":\"Farcaster\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://mastodon.cloud/@0xADADA\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on Mastodon\",\"children\":\"Mastodon\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://bsky.app/profile/0xadada.bsky.social\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on Bluesky\",\"children\":\"Bluesky\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://twitter.com/0xadada\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on Twitter\",\"children\":[\"$\",\"del\",null,{\"children\":\"Twitter\"}]}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://github.com/0xadada\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on GitHub\",\"children\":\"GitHub\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"https://www.goodreads.com/review/list/60524683-0xadada?shelf=wanted\",\"className\":\"u-url\",\"rel\":\"me nofollow external noopener\",\"title\":\"0xADADA on Goodreads\",\"children\":\"Goodreads\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"/colophon/\",\"children\":\"Colophon\"}],\" \",[\"$\",\"$La\",null,{\"href\":\"/rss.xml\",\"children\":\"RSS\"}],\" \",[\"$\",\"$Lb\",null,{\"className\":\"u-photo\",\"src\":\"/static/images/meta/avatar.svg\",\"alt\":\"0xADADA icon\",\"width\":\"20\",\"height\":\"20\",\"style\":{\"marginBottom\":\"-0.125rem\"}}]]}]]}]}],[\"$\",\"form\",null,{\"action\":\"https://buttondown.email/api/emails/embed-subscribe/0xadada\",\"method\":\"post\",\"target\":\"popupwindow\",\"children\":[[\"$\",\"label\",null,{\"htmlFor\":\"email\",\"children\":[\"Sign up to get emailed when I write new things:\",\" \"]}],[\"$\",\"input\",null,{\"type\":\"email\",\"name\":\"email\",\"id\":\"email\"}],[\"$\",\"input\",null,{\"type\":\"submit\",\"value\":\"Subscribe\"}]]}]]}]]}]}],null]],\"initialHead\":[false,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]]\n"])</script><script>self.__next_f.push([1,"f:T40d,"])</script><script>self.__next_f.push([1,"If the total number of occupied squares in a given position is odd, the number\nof white pieces is one more than the numbers of black pieces. If the total of\noccupied squares is even, these numbers are equal. Furthermore, if a column\ncontains an empty square, all squares higher than this square are also empty. If\na position contains four connected pieces, the position concludes a game. Since\nthe last move ended the game, at least one of the four squares in the connected\ngroup must be the highest filled square in its column. If this is not the case,\nor both players have connected four pieces, the position is illegal. If one\nplayer has more than one connected group this position can only be legal if\nthese groups share a square that contains the last piece played. In the\ncalculations we are going to make, we do not rule out positions in which are\nillegal for the reasons mentioned above. We also do not rule out positions that\nare not legal, because they cannot be achieved, during normal play. Diagram 2.1\nshows such a position."])</script><script>self.__next_f.push([1,"10:T61d,"])</script><script>self.__next_f.push([1,"This diagram shows that it can be rather difficult to detect if a position is\nillegal. It is equally difficult to show which of the positions are not legal\nbecause more than one group of four connected pieces is present. We therefore\nassume that a database should contain a large number of illegal positions. We\nbelieve that in that case the order of magnitude of the upper bound presented\nbefore, is a good estimate for the magnitude of the database. This number is by\nfar too big to think seriously about making a database for Connect-Four. To see\nthis, we have to consider the number of positions that must be stored at the\nsame time when we build the database. When a retrograde analysis is applied, as\nhas been done for many endgames in chess, we need not necessarily store the\npositions consisting of, say, 20 pieces, as long as we have not yet determined\nthe value of all positions of 21 pieces. When we have determined the value of\nthese positions, we no longer need the positions consisting of 22 pieces or\nmore. Therefore we only need to be able to store all positions of n and n+1\npieces at the same time. For the 7 x 6 board, this means that we must be able to\nhold all positions of 36 and 37 pieces at the same time, a total over 1.6 x 1013\npositions. We can store the value of a position in 2 bits, since we have 4\npossible states: win for White, win for Black, draw or not checked (we can use\nthe address of the 2 bits as identification for the position). This way we need\nat least 4 Terabyte. Therefore making a database does not yet seem realistic."])</script><script>self.__next_f.push([1,"11:T413,"])</script><script>self.__next_f.push([1,"This algorithm was initially going to use the minimax algorithm (as implemented\nin Artificial Intelligence: A Modern Approach) to search the game tree for the\noptimal move. However, the tree proved to be too massive to search in this way,\ndue to computational limitations. One possible solution to this problem was the\nalpha-beta pruning algorithm, in which game subtrees are eliminated to cut down\non the number of computations. However, this idea was passed over for a\nsimplified version of the minimax algorithm. Instead of searching the entire\ngame tree, the algorithm used in the final version of the program only searches\nthe tree up to a certain point. So, in effect, the algorithm is looking four\nmoves ahead and making the best move based on that knowledge. The decision to\nlimit the lookahead to four levels was made because it is about equal to the\nnumber of moves a skilled player can look ahead, and it is a good match for the\ncurrent power of processing technology. Thus the Minimax AI is a good match for\na skilled human player."])</script><script>self.__next_f.push([1,"6:[\"$\",\"article\",null,{\"className\":\"hentry h-entry\",\"children\":[[\"$\",\"header\",null,{\"children\":[[\"$\",\"h1\",null,{\"className\":\"entry-title p-name\",\"children\":\"A Connect Four Playing AI Agent: Algorithm and Creation Process\"}],\"$undefined\",[\"$\",\"time\",null,{\"className\":\"display-date_published__A_L_d dt-published\",\"dateTime\":\"2003-12-15T00:00:00.000Z\",\"children\":\"Monday December 15, 2003\"}],[\"$\",\"span\",null,{\"className\":\"h-card page_byline__wbXsN\",\"children\":[\" by \",[\"$\",\"span\",null,{\"className\":\"fn p-author p-name\",\"children\":\"0xADADA\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"entry-content e-content\",\"children\":[[\"$\",\"center\",null,{\"children\":[\"0xADADA, Erik Ibsen, Chen Zhang \",[\"$\",\"br\",null,{}],\" Khoury College of Computer Sciences \",[\"$\",\"br\",null,{}],\" Northeastern University Boston, MA \"]}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This paper documents the creation and testing of a game playing artificial\\nintelligence (AI) agent program. The agent is designed to play a game of Connect\\nFour by Milton-Bradley. The game is played by dropping pieces into a game board\\nconsisting of a grid of 6x7 slots. The object is to make a vertical, horizontal\\nor diagonal line of four pieces before the opposing player does. The agent\\ndesigned in the current study is able to play against a human opponent or\\nagainst another AI agent.\"}],\"\\n\",[\"$\",\"hr\",null,{}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"introduction\",\"children\":\"Introduction\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In this chapter the rules of the game Connect-Four are described, as well as the\\ntask environment. We also introduce a naming convention used throughout this\\ntext.\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"the-rules-of-the-game\",\"children\":\"The Rules of the Game\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Connect-Four is a game for two persons. Both players have 21 identical pieces.\\nIn the standard form of the game, one set of pieces is red and the other set is\\nyellow. The game is played on a vertical, rectangular board consisting of 7\\nvertical columns of 6 squares each. If one piece is put in one of the columns,\\nit will fall down to the lowest unoccupied square in the column. As soon as a\\ncolumn contains 6 pieces, no other piece can be put in the column. Putting a\\npiece in one of the columns is called a move.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The players make their moves in turn. There are no rules stating that the player\\nwith, for instance, the red pieces should start. Since it is confusing to\\nidentify for each new game the color that started the game, we will assume that\\nthe sets of pieces are colored white and black instead of red and yellow. Like\\nchess and checkers (and unlike go) it is assumed that the player playing the\\nwhite pieces will make the first move.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Both Players will try to get four connected pieces, horizontally, vertically or\\ndiagonally. The first player who achieves one such group of four connected\\npieces wins the game. If all 42 pieces are played and no player has achieved\\nthis goal, the game is a draw.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Diagrams 1.1, 1.2 and 1.3 show positions in which White has won the game:\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2003-12-15/1.1.png\",\"alt\":\"Diagram 1.1\",\"title\":\"Diagram 1.1\"}],[\"$\",\"figcaption\",null,{\"children\":\"Diagram 1.1\"}]]}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2003-12-15/1.2.png\",\"alt\":\"Diagram 1.2\",\"title\":\"Diagram 1.2\"}],[\"$\",\"figcaption\",null,{\"children\":\"Diagram 1.2\"}]]}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2003-12-15/1.3.png\",\"alt\":\"Diagram 1.3\",\"title\":\"Diagram 1.3\"}],[\"$\",\"figcaption\",null,{\"children\":\"Diagram 1.3\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In the position of diagram 1.1, White has made a horizontal winning group, while\\nhis winning groups were respectively vertical and diagonal in the other two\\ndiagrams.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"A possible drawn position is shown in the diagram 1.4:\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2003-12-15/1.4.png\",\"alt\":\"Diagram 1.4\",\"title\":\"Diagram 1.4\"}],[\"$\",\"figcaption\",null,{\"children\":\"Diagram 1.4\"}]]}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"task-environment\",\"children\":\"Task Environment\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The goal of this study was to create an agent to play the game Connect Four. The\\nrules for the game were taken from the classic game of Connect Four. However,\\nthe environment and the agent program was created from scratch. On the surface\\nthe program functions as a simple Connect Four game playable between two human\\nplayers.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In order to make an appropriate agent design, the task environment must first be\\nidentified and described. Table 1.1 is a PEAS description of this task\\nenvironment. The task environment can be further categorized by several other\\nfactors, such as observability, number of agents, etc. These factors are\\ndescribed in Table 1.2.\"}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"Agent Type\"}],[\"$\",\"th\",null,{\"children\":\"Connect Four Playing Software Agent\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Performance Measure\"}],[\"$\",\"td\",null,{\"children\":\"Put four pieces adjacent or diagonal to each other, prevent opponent from doing the same.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Environment\"}],[\"$\",\"td\",null,{\"children\":\"Game Board, Agent‚Äôs pieces, and Opponent‚Äôs pieces.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Actuators\"}],[\"$\",\"td\",null,{\"children\":\"Piece placing function.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Sensors\"}],[\"$\",\"td\",null,{\"children\":\"Direct access to the state of the board.\"}]]}]]}]]}],\"\\n\",[\"$\",\"em\",null,{\"children\":[[\"$\",\"a\",null,{\"id\":\"#table:1.1\"}],[\"$\",\"p\",null,{\"children\":\"Table 1.1 ‚Äì A PEAS description of the task environment.\"}]]}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"align\":\"left\",\"children\":\"Environment Property\"}],[\"$\",\"th\",null,{\"align\":\"left\",\"children\":\"Description\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"Fully Observable vs. Partially Observable\"}],[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"The Connect Four environment is fully observable. The environment consists of the board, which has constant dimensions, and the pieces, which belong to either the player or the opponent. The agent has access to all of this information.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"Deterministic vs. Stochastic\"}],[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"This environment could be considered deterministic, as there are no random elements at work here. The only unknown is the actions of the opponent. Therefore, the environment can be classified as strategic.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"Episodic vs. Sequential\"}],[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"The environment could be either episodic or sequential, depending on the algorithm the agent uses. If the algorithm calls for random placement of a piece, then the environment is episodic. However, if the algorithm is more sophisticated, calling for prediction of the opponent‚Äôs moves, then the environment is sequential.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"Static vs. Dynamic\"}],[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"This environment is fully static. Time is not a factor in making the decision as to where to place pieces. Once it is the agent‚Äôs turn, the state cannot be changed until it makes its move. The agent is also not penalized as a function of decision time.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"Discrete vs. Continuous\"}],[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"Connect Four is a fairly simple game with a finite, albeit large, number of different states. Therefore, the environment is decidedly discrete.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"Single agent vs. multi-agent\"}],[\"$\",\"td\",null,{\"align\":\"left\",\"children\":\"In this game, there are two agents at work. From the point of view of the AI agent, there is itself, and another agent. The other agent can either be a human player or another AI agent, which may or may not use the same algorithm. Since both agents (be they human or otherwise) are out to maximize their own performance measure and minimize their opponent‚Äôs, the environment is classified as competitive multi-agent.\"}]]}]]}]]}],\"\\n\",[\"$\",\"em\",null,{\"children\":[[\"$\",\"a\",null,{\"id\":\"table:1.1\"}],[\"$\",\"p\",null,{\"children\":\"Table 1.2 ‚Äì Detailed description of the task environment properties\"}]]}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"naming-convention\",\"children\":\"Naming Convention\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In order to be able to talk about a position, it is useful to give each square a\\nname. We have chosen to use a convention as used by chess players. The 7 columns\\nare labeled ‚Äòa‚Äô through ‚Äòg‚Äô while the rows are numbered 1 through 6. In this way\\nthe lowest square in the middle column is called d1.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"It is now possible to make a list of the moves made during a game. For the game\\ndiagram 1.1 this could have been:\"}],\"\\n\",[\"$\",\"ol\",null,{\"children\":[\"\\n\",[\"$\",\"li\",null,{\"children\":\"d1, d2\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"c1, d3\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"e1, b1\"}],\"\\n\",[\"$\",\"li\",null,{\"children\":\"f1, White wins.\"}],\"\\n\"]}],\"\\n\",[\"$\",\"p\",null,{\"children\":[\"It is also easy to use the names of the squares to show where the winning group\\nwas created. In diagram 1.1 the winning group was on squares c1, d1, e1 and f1.\\nSince the squares must lie on a straight line, it is enough to specify the two\\nendpoints of the group. In this case the group can be identified with c1-f1. In\\ngeneral the notation \",[\"$\",\"code\",null,{\"children\":\"square1\"}],\" \",[\"$\",\"code\",null,{\"children\":\"square2\"}],\" will be used to identify all squares on\\nthe line with sqaure1 and square2 as endpoints.\"]}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"complexity-analysis\",\"children\":\"Complexity Analysis\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In this chapter we show why a brute force approach will not be successful at\\nthis time.\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"complexity-of-the-game\",\"children\":\"Complexity of the Game\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In order to get an idea about the complexity of the game an estimate is\\npresented of the number of different positions that can be achieved, if the game\\nis played according to the rules. A position that can occur during a game is\\ncalled a legal position, while a position that cannot be achieved is called\\nillegal.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Each square can be in one of three states: empty, white or black. Therefore it\\nis easy to see that the number of possible positions is at most 342 (‚â• 1020).\\nThis upper bound is a very crude one, and can be brought into better\\nproportions.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"$f\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2003-12-15/2.1.png\",\"alt\":\"Diagram 2.1\",\"title\":\"Diagram 2.1\"}],[\"$\",\"figcaption\",null,{\"children\":\"Diagram 2.1\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Although the position looks perfectly normal, it is clear that Black has made\\nthe first move. Therefore it is not legal simply because white is supposed to\\nmove first according to the rules.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"We have calculated the number of different positions, including all illegal\\npositions which contain too many connected groups of four pieces, and illegal\\npositions as shown in diagram 2.1. For the standard 7 x 6 board, an upper bound\\nof 7.1 x 1013 is found.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"To determine the amount of memory needed to construct a database for\\nConnect-Four this upper bound is useful. In order to show that such a\\nconstruction takes too much memory, we need a lower bound instead of an upper\\nbound. If we want to find a good lower bound of the number of possible\\npositions, we have to make sure that each position we count is legal. Therefore\\nall positions which cannot be achieved during normal play, e.g. diagram 2.1,\\nshould be ruled out. Diagram 2.2 illustrates the difficulties we are faced with\\nin determining if a position is legal.\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2003-12-15/2.2.png\",\"alt\":\"Diagram 2.2\",\"title\":\"Diagram 2.2\"}],[\"$\",\"figcaption\",null,{\"children\":\"Diagram 2.2\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The position of diagram 2.2 is a draw. Although at first sight it might look\\nlike a normal position, it cannot be achieved during normal play. This can be\\nseen as follows: the first move White made must have been d1. If Black played as\\nhis first move one of b1, d2 and f1, there is no possible second move for White.\\nTherefore Black‚Äôs second move was one of a1, c1, e1 and g1. Suppose Black played\\na1, White then must have played a2 as second move, giving the position of\\ndiagram 2.3:\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2003-12-15/2.3.png\",\"alt\":\"Diagram 2.3\",\"title\":\"Diagram 2.3\"}],[\"$\",\"figcaption\",null,{\"children\":\"Diagram 2.3\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Now Black still cannot have played b1, d2 or f1, for the same reason as before.\\nThe move on a3 is not possible either. Therefore Black must have played one of\\nthe remaining c1, e1 or g1. After one of these, and after White‚Äôs answer to it,\\nthe position did not get any better. The furthest we can get with this game is\\nshown in diagram 2.4.\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2003-12-15/2.4.png\",\"alt\":\"Diagram 2.4\",\"title\":\"Diagram 2.4\"}],[\"$\",\"figcaption\",null,{\"children\":\"Diagram 2.4\"}]]}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"In this position Black has to move. For all seven columns, the lower two squares\\nshould be filled by black pieces. Therefore after the next move of Black there\\nis no move White can make that will eventually result in the position shown in\\ndiagram 2.2. Therefore that position is illegal.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"$10\"}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"development\",\"children\":\"Development\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"interface\",\"children\":\"Interface\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The interface of the game program consists of two parts, the menu, and the game\\nboard. The menu gives the user access to the game controls, such as setting\\nwhich AI algorithm to use, and which players will be controlled by humans and\\nwhich by AI agents. One interesting feature of this particular design is that\\none can begin a game with two human players, and set up the board any way they\\nlike. Then one or both of the players can be switched to AI agents, in order to\\nsee how they react to different initial configurations of the board.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Once the players are set, the user can begin a new game. The game board is set\\nto the initial configuration of all empty squares. Players then take turns\\ndropping pieces into the 7 columns of the game board. Human players make moves\\nby clicking the button above the desired row. This design was favored over other\\ninterfaces, such as clicking directly on the game board, partially because of\\ntime restraints, and partially because it more closely approximates the way the\\nreal game is played, by dropping pieces into the top of the board. The AI\\nagents, of course, automatically make their moves, so their pieces appear very\\nsoon after the opponent makes their move. Since the AI agents are very fast at\\nmaking their decisions, AI vs. AI games of Connect Four are for the most part\\nvery short.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"When the game is over, a window pops up that notifies the user of the outcome.\\nIf the game results in a win for some player, the message states that that\\nplayer has won. However, if the game ends in a draw, then this message is\\nrelayed to the user instead. From that point, the user can either quit or begin\\na new game.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"As a side note, in early versions of the program, there was one other form of\\ninterface present. The list of moves in sequential order was output to a text\\nwindow, along with system messages such as which player was victorious. This\\nlist of moves proved very valuable for the debugging process. At one point, when\\npitting AI agents against each other, the program became stuck in an infinite\\nloop. It was very beneficial to be able to see what moves led up to the loop and\\nwhat moves the AI was trying to make during the loop.\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"design\",\"children\":\"Design\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"This design is both intuitive and minimal. The GUI was written in Java/Swing, a\\ntoolkit provided by Java, as seen below in diagram 3.1.\"}],\"\\n\",[\"$\",\"figure\",null,{\"children\":[[\"$\",\"img\",null,{\"src\":\"/static/images/2003-12-15/3.1.png\",\"alt\":\"Diagram 3.1\",\"title\":\"Diagram 3.1\"}],[\"$\",\"figcaption\",null,{\"children\":\"Diagram 3.1\"}]]}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"artificial-intelligence\",\"children\":\"Artificial Intelligence\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The computer AI opponent of the program is configurable to different difficulty\\nlevels. Each difficulty level represents a different algorithm. There are four\\ndifferent difficulty levels in this version of the program; Random (easy),\\nDefensive, Aggressive, and Minimax (difficult).\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"random-ai\",\"children\":\"Random AI\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The Random AI algorithm simply places pieces randomly each turn. This algorithm\\ncan be defeated easily by human players and by the other AI algorithms. It is\\nalso the only one that is non-deterministic. Since it randomly places pieces,\\nthe move progression will be different each time this algorithm plays. As\\ndescribed below, the Random algorithm is the only one with this characteristic.\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"defensive-ai\",\"children\":\"Defensive AI\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The defensive AI algorithm uses a heuristic function to determine what the next\\nmove should be. It looks at the current state of the board and assigns a value\\nto each of the available moves. The higher this value is, the more dangerous it\\nis not to move there. For instance, if the opponent has three pieces in a row, a\\nvalue of 8 is given to the space that would complete the opponent‚Äôs\\nfour-in-a-row. If the opponent has two pieces in a row, a value of four might be\\ngiven to the adjacent square. The point of this algorithm is to block the\\nopponent from getting four in a row at all costs.\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"aggressive-ai\",\"children\":\"Aggressive AI\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"The Aggressive AI algorithm uses the same type of heuristic function used by the\\ndefensive algorithm, with one key difference. The defensive algorithm only\\napplies the heuristic function to the opponent‚Äôs pieces on the board. The\\naggressive algorithm applies it to both the opponent‚Äôs pieces and its own\\npieces. Thus it simultaneously defends against potentially losing situations by\\nblocking the opponent from winning, and makes offensive moves maximizing the\\nnumber of pieces it has in a row. Skilled human players are still able to defeat\\nthis algorithm fairly easily, however, since it does not look very far ahead in\\nthe game tree.\"}],\"\\n\",[\"$\",\"h3\",null,{\"id\":\"minimax-ai\",\"children\":\"Minimax AI\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"$11\"}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"results\",\"children\":\"Results\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"One of the primary functions of this study was to learn about how the different\\nAI algorithms perform against one another. Due to the short length of the\\nmatches played between to AI players, many trials were able to be conducted.\\nTable 5.1 is a brief summary of how the different algorithms interact.\"}],\"\\n\",[\"$\",\"table\",null,{\"children\":[[\"$\",\"thead\",null,{\"children\":[\"$\",\"tr\",null,{\"children\":[[\"$\",\"th\",null,{\"children\":\"Condition\"}],[\"$\",\"th\",null,{\"children\":\"Winner (most often)\"}],[\"$\",\"th\",null,{\"children\":\"Comments\"}]]}]}],[\"$\",\"tbody\",null,{\"children\":[[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Random vs. Any Other\"}],[\"$\",\"td\",null,{\"children\":\"Any other\"}],[\"$\",\"td\",null,{\"children\":\"Since random play is seldom successful, Random AI is most often defeated. However, it can and sometimes does win against stronger AI.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Defensive vs. Defensive, Aggressive vs. Aggressive\"}],[\"$\",\"td\",null,{\"children\":\"Draw\"}],[\"$\",\"td\",null,{\"children\":\"It was hypothesized that whichever player went first would win most often. However, more often than not the game ended in a draw. For those games that did not end in a draw, no player won significantly more than the other.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Defensive vs. Aggressive\"}],[\"$\",\"td\",null,{\"children\":\"Aggressive\"}],[\"$\",\"td\",null,{\"children\":\"Since Aggressive AI takes into account more of the state than the Defensive, Aggressive will always prevail.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Defensive or Aggressive vs. Minimax\"}],[\"$\",\"td\",null,{\"children\":\"Minimax\"}],[\"$\",\"td\",null,{\"children\":\"Since Minimax is able to look ahead four moves, it will usually defeat both Defensive and Aggressive. There are some instances where the game will end in a draw.\"}]]}],[\"$\",\"tr\",null,{\"children\":[[\"$\",\"td\",null,{\"children\":\"Minimax vs. Minimax\"}],[\"$\",\"td\",null,{\"children\":\"Player 2\"}],[\"$\",\"td\",null,{\"children\":\"For some coincidental reason, when Minimax is pitted against itself, the second player always wins, and the same game is always played. This may be due to the fact that the entire game tree is not searched, so the algorithm is not perfect.\"}]]}]]}]]}],\"\\n\",[\"$\",\"em\",null,{\"children\":[\"$\",\"p\",null,{\"children\":\"Table 5.1 ‚Äì A summary of the results of AI vs. AI games.\"}]}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"conclusion\",\"children\":\"Conclusion\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Above all else, this study was designed so that the authors could learn more\\nabout AI. This goal was successfully accomplished. The specific area in which\\nthe most experience was gained is that of computer game playing agent design.\\nWhile the algorithm best suited to success may be impossible to execute with\\ncurrent technology, other algorithms are just as suitable to make for an\\ninteresting playing experience. This is an important game design concept,\\nbecause more often than not, people want to win games they play. Therefore, if\\nthe computer AI always wins because the algorithm is perfect, the game will\\nsuffer from lack of human interest.\"}],\"\\n\",[\"$\",\"p\",null,{\"children\":\"Heuristic algorithms like the Defensive and Aggressive algorithms outlined in\\nthis study are very well suited to solve this problem. Since they do not always\\nwin, but sometimes trick a human player, they retain a human player‚Äôs interest.\\nAs long as no one programs a heuristic algorithm to become frustrated at losing,\\nthey will remain one of the best solutions to a computer game-playing problem.\"}],\"\\n\",[\"$\",\"h2\",null,{\"id\":\"references\",\"children\":\"References\"}],\"\\n\",[\"$\",\"cite\",null,{\"className\":\"hanging-indent\",\"id\":\"cite:4\",\"children\":[\"$\",\"p\",null,{\"children\":[\"Russell, S., Norvig, P.\\n\",[\"$\",\"em\",null,{\"children\":\"Artificial Intelligence, A Modern Approach\"}],\".\\nThird Edition\\nPearson Education, Inc.\\nPrentice Hall.\\nPrint.\\n2003.\"]}]}],\"\\n\",[\"$\",\"cite\",null,{\"className\":\"hanging-indent\",\"id\":\"cite:1\",\"children\":[\"$\",\"p\",null,{\"children\":[\"Flanagan, D.\\n\",[\"$\",\"em\",null,{\"children\":\"Java in a Nutshell\"}],\".\\nThird Edition.\\nO‚ÄôReilly \u0026 Associates, Inc.\\nPrint.\\n1999.\"]}]}],\"\\n\",[\"$\",\"cite\",null,{\"className\":\"hanging-indent\",\"id\":\"cite:2\",\"children\":[\"$\",\"p\",null,{\"children\":[\"Knudsen, J.\\n\",[\"$\",\"em\",null,{\"children\":\"Java 2D Graphics\"}],\".\\nO‚ÄôReilly \u0026 Associates, Inc.\\nPrint.\\n1999.\"]}]}],\"\\n\",[\"$\",\"cite\",null,{\"className\":\"hanging-indent\",\"id\":\"cite:3\",\"children\":[\"$\",\"p\",null,{\"children\":\"Milton-Bradley, Inc. Connect Four Game, Hasbro, Inc.\"}]}],\"\\n\",[\"$\",\"aside\",null,{\"children\":[\"$\",\"p\",null,{\"children\":[\"All source code is available at\\n\",[\"$\",\"a\",null,{\"href\":\"https://github.com/0xadada/smart-connect-four\",\"children\":\"GitHub\"}],\".\"]}]}]]}],[\"$\",\"footer\",null,{\"className\":\"license_copyright__EpMnZ\",\"children\":[\"This is licensed under a Creative Commons \",\"cc-by\",\" International License\"]}]]}]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"A Connect Four Playing AI Agent: Algorithm and Creation Process\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"This paper documents the creation and testing of a game playing artificial intelligence (AI) agent program.  The agent is designed to play a game of Connect Four by Milton-Bradely.\"}],[\"$\",\"link\",\"4\",{\"rel\":\"author\",\"href\":\"https://0xadada.pub\"}],[\"$\",\"meta\",\"5\",{\"name\":\"author\",\"content\":\"0xADADA\"}],[\"$\",\"meta\",\"6\",{\"name\":\"keywords\",\"content\":\"projects,artificial intelligence,software engineering\"}],[\"$\",\"link\",\"7\",{\"rel\":\"alternate\",\"type\":\"application/rss+xml\",\"href\":\"https://0xadada.pub/rss.xml\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:title\",\"content\":\"A Connect Four Playing AI Agent: Algorithm and Creation Process\"}],[\"$\",\"meta\",\"9\",{\"property\":\"og:description\",\"content\":\"This paper documents the creation and testing of a game playing artificial intelligence (AI) agent program.  The agent is designed to play a game of Connect Four by Milton-Bradely.\"}],[\"$\",\"meta\",\"10\",{\"property\":\"og:url\",\"content\":\"https://0xadada.pub/2003/12/15/connect-four-playing-ai-agent/\"}],[\"$\",\"meta\",\"11\",{\"property\":\"og:site_name\",\"content\":\"0xADADA\"}],[\"$\",\"meta\",\"12\",{\"property\":\"og:locale\",\"content\":\"en_US\"}],[\"$\",\"meta\",\"13\",{\"property\":\"og:image\",\"content\":\"https://0xadada.pub/static/images/meta/avatar.svg\"}],[\"$\",\"meta\",\"14\",{\"property\":\"og:image:width\",\"content\":\"660\"}],[\"$\",\"meta\",\"15\",{\"property\":\"og:image:height\",\"content\":\"660\"}],[\"$\",\"meta\",\"16\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"17\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"18\",{\"name\":\"twitter:title\",\"content\":\"A Connect Four Playing AI Agent: Algorithm and Creation Process\"}],[\"$\",\"meta\",\"19\",{\"name\":\"twitter:description\",\"content\":\"This paper documents the creation and testing of a game playing artificial intelligence (AI) agent program.  The agent is designed to play a game of Connect Four by Milton-Bradely.\"}],[\"$\",\"meta\",\"20\",{\"name\":\"twitter:image\",\"content\":\"https://0xadada.pub/static/images/meta/avatar.svg\"}],[\"$\",\"meta\",\"21\",{\"name\":\"twitter:image:width\",\"content\":\"660\"}],[\"$\",\"meta\",\"22\",{\"name\":\"twitter:image:height\",\"content\":\"660\"}],[\"$\",\"link\",\"23\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"48x48\"}],[\"$\",\"link\",\"24\",{\"rel\":\"apple-touch-icon\",\"href\":\"/apple-icon.png?b764b3a1dbf00a82\",\"type\":\"image/png\",\"sizes\":\"180x180\"}]]\n"])</script><script>self.__next_f.push([1,"5:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>